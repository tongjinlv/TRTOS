; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\user\prj_insectv2\obj\stm32l1xx_aes.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\user\prj_insectv2\obj\stm32l1xx_aes.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\src -I..\USER -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx -I..\Driver -I..\Configs -I..\Boot -I..\Tos -I..\Tools -I..\FS\TQFS -I..\USER\Prj_4.3LCD -I..\USER\Prj_CanBus -I..\USER\Prj_Sensor -I..\GUI\MGui -I..\FuncTask -I..\USER\Prj_Really -I..\USER\Prj_PdaTran -I..\USB\WHID -I..\FS -I..\GUI\TGui -I..\GUI -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -IE:\Soft\keil472a\ARM\RV31\INC -IE:\Soft\keil472a\ARM\CMSIS\Include -IE:\Soft\keil472a\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DBOARD_InsectV2 -DUSE_STDPERIPH_DRIVER --omf_browse=..\user\prj_insectv2\obj\stm32l1xx_aes.crf ..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_aes.c]
                          THUMB

                          AREA ||i.AES_ClearFlag||, CODE, READONLY, ALIGN=2

                  AES_ClearFlag PROC
;;;489      */
;;;490    void AES_ClearFlag(uint32_t AES_FLAG)
000000  2801              CMP      r0,#1
;;;491    {
;;;492      /* Check the parameters */
;;;493      assert_param(IS_AES_FLAG(AES_FLAG));
;;;494    
;;;495      /* Check if AES_FLAG is AES_FLAG_CCF */
;;;496      if (AES_FLAG == AES_FLAG_CCF)
000002  d106              BNE      |L1.18|
;;;497      {
;;;498        /* Clear CCF flag by setting CCFC bit */
;;;499        AES->CR |= (uint32_t) AES_CR_CCFC;
000004  4906              LDR      r1,|L1.32|
000006  6809              LDR      r1,[r1,#0]
000008  f0410180          ORR      r1,r1,#0x80
00000c  4a04              LDR      r2,|L1.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L1.30|
                  |L1.18|
;;;500      }
;;;501      else /* AES_FLAG is AES_FLAG_RDERR or AES_FLAG_WRERR */
;;;502      {
;;;503        /* Clear RDERR and WRERR flags by setting ERRC bit */
;;;504        AES->CR |= (uint32_t) AES_CR_ERRC;
000012  4903              LDR      r1,|L1.32|
000014  6809              LDR      r1,[r1,#0]
000016  f4417180          ORR      r1,r1,#0x100
00001a  4a01              LDR      r2,|L1.32|
00001c  6011              STR      r1,[r2,#0]
                  |L1.30|
;;;505      }
;;;506    }
00001e  4770              BX       lr
;;;507    
                          ENDP

                  |L1.32|
                          DCD      0x50060000

                          AREA ||i.AES_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  AES_ClearITPendingBit PROC
;;;577      */
;;;578    void AES_ClearITPendingBit(uint32_t AES_IT)
000000  4903              LDR      r1,|L2.16|
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_AES_IT(AES_IT));
;;;582    
;;;583      /* Clear the interrupt pending bit */
;;;584      AES->CR |= (uint32_t) (AES_IT >> (uint32_t) 0x00000002);
000002  6809              LDR      r1,[r1,#0]
000004  ea410190          ORR      r1,r1,r0,LSR #2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;585    }
00000c  4770              BX       lr
;;;586    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x50060000

                          AREA ||i.AES_Cmd||, CODE, READONLY, ALIGN=2

                  AES_Cmd PROC
;;;198      */
;;;199    void AES_Cmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L3.16|
;;;200    {
;;;201      /* Check the parameter */
;;;202      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;203    
;;;204      if (NewState != DISABLE)
;;;205      {
;;;206        /* Enable the AES peripheral */
;;;207        AES->CR |= (uint32_t) AES_CR_EN;   /**< AES Enable */
000002  4907              LDR      r1,|L3.32|
000004  6809              LDR      r1,[r1,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  4a05              LDR      r2,|L3.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L3.28|
                  |L3.16|
;;;208      }
;;;209      else
;;;210      {
;;;211        /* Disable the AES peripheral */
;;;212        AES->CR &= (uint32_t)(~AES_CR_EN);  /**< AES Disable */
000010  4903              LDR      r1,|L3.32|
000012  6809              LDR      r1,[r1,#0]
000014  f0210101          BIC      r1,r1,#1
000018  4a01              LDR      r2,|L3.32|
00001a  6011              STR      r1,[r2,#0]
                  |L3.28|
;;;213      }
;;;214    }
00001c  4770              BX       lr
;;;215    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x50060000

                          AREA ||i.AES_DMAConfig||, CODE, READONLY, ALIGN=2

                  AES_DMAConfig PROC
;;;383      */
;;;384    void AES_DMAConfig(uint32_t AES_DMATransfer, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;385    {
;;;386      /* Check the parameter */
;;;387      assert_param(IS_AES_DMA_TRANSFER(AES_DMATransfer));
;;;388    
;;;389      if (NewState != DISABLE)
;;;390      {
;;;391        /* Enable the DMA transfer */
;;;392        AES->CR |= (uint32_t) AES_DMATransfer;
000002  4a06              LDR      r2,|L4.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;393      }
;;;394      else
;;;395      {
;;;396        /* Disable the DMA transfer */
;;;397        AES->CR &= (uint32_t)(~AES_DMATransfer);
00000e  4a03              LDR      r2,|L4.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  601a              STR      r2,[r3,#0]
                  |L4.24|
;;;398      }
;;;399    }
000018  4770              BX       lr
;;;400    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x50060000

                          AREA ||i.AES_DeInit||, CODE, READONLY, ALIGN=1

                  AES_DeInit PROC
;;;114      */
;;;115    void AES_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117      /* Enable AES reset state */
;;;118      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_AES, ENABLE);
000002  2101              MOVS     r1,#1
000004  06c8              LSLS     r0,r1,#27
000006  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;119      /* Release AES from reset state */
;;;120      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_AES, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f6000          MOV      r0,#0x8000000
000010  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;121    }
000014  bd10              POP      {r4,pc}
;;;122    
                          ENDP


                          AREA ||i.AES_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  AES_GetFlagStatus PROC
;;;457      */
;;;458    FlagStatus AES_GetFlagStatus(uint32_t AES_FLAG)
000000  4601              MOV      r1,r0
;;;459    {
;;;460      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;461    
;;;462      /* Check parameters */
;;;463      assert_param(IS_AES_FLAG(AES_FLAG));
;;;464    
;;;465      if ((AES->SR & AES_FLAG) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L6.20|
000006  6852              LDR      r2,[r2,#4]
000008  420a              TST      r2,r1
00000a  d001              BEQ      |L6.16|
;;;466      {
;;;467        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L6.18|
                  |L6.16|
;;;468      }
;;;469      else
;;;470      {
;;;471        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;472      }
;;;473        
;;;474      /* Return the AES_FLAG status */
;;;475      return  bitstatus;
;;;476    }
000012  4770              BX       lr
;;;477    
                          ENDP

                  |L6.20|
                          DCD      0x50060000

                          AREA ||i.AES_GetITStatus||, CODE, READONLY, ALIGN=2

                  AES_GetITStatus PROC
;;;515      */
;;;516    ITStatus AES_GetITStatus(uint32_t AES_IT)
000000  b510              PUSH     {r4,lr}
;;;517    {
000002  4601              MOV      r1,r0
;;;518      ITStatus itstatus = RESET;
000004  2000              MOVS     r0,#0
;;;519      uint32_t cciebitstatus = RESET, ccfbitstatus = RESET;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;520    
;;;521      /* Check parameters */
;;;522      assert_param(IS_AES_GET_IT(AES_IT));
;;;523    
;;;524      cciebitstatus = AES->CR & AES_CR_CCIE;
00000a  4c10              LDR      r4,|L7.76|
00000c  6824              LDR      r4,[r4,#0]
00000e  f4047200          AND      r2,r4,#0x200
;;;525      ccfbitstatus =  AES->SR & AES_SR_CCF;
000012  4c0e              LDR      r4,|L7.76|
000014  6864              LDR      r4,[r4,#4]
000016  f0040301          AND      r3,r4,#1
;;;526    
;;;527      /* Check if AES_IT is AES_IT_CC */
;;;528      if (AES_IT == AES_IT_CC)
00001a  f5b17f00          CMP      r1,#0x200
00001e  d105              BNE      |L7.44|
;;;529      {
;;;530        /* Check the status of the specified AES interrupt */
;;;531        if (((cciebitstatus) != (uint32_t)RESET) && ((ccfbitstatus) != (uint32_t)RESET))
000020  b112              CBZ      r2,|L7.40|
000022  b10b              CBZ      r3,|L7.40|
;;;532        {
;;;533          /* Interrupt occurred */
;;;534          itstatus = SET;
000024  2001              MOVS     r0,#1
000026  e010              B        |L7.74|
                  |L7.40|
;;;535        }
;;;536        else
;;;537        {
;;;538          /* Interrupt didn't occur */
;;;539          itstatus = RESET;
000028  2000              MOVS     r0,#0
00002a  e00e              B        |L7.74|
                  |L7.44|
;;;540        }
;;;541      }
;;;542      else /* AES_IT is AES_IT_ERR */
;;;543      {
;;;544        /* Check the status of the specified AES interrupt */
;;;545        if ((AES->CR & AES_CR_ERRIE) != RESET)
00002c  4c07              LDR      r4,|L7.76|
00002e  6824              LDR      r4,[r4,#0]
000030  f4146f80          TST      r4,#0x400
000034  d008              BEQ      |L7.72|
;;;546        {
;;;547          /* Check if WRERR or RDERR flags are set */
;;;548          if ((AES->SR & (uint32_t)(AES_SR_WRERR | AES_SR_RDERR)) != (uint16_t)RESET)
000036  4c05              LDR      r4,|L7.76|
000038  6864              LDR      r4,[r4,#4]
00003a  f0140f06          TST      r4,#6
00003e  d001              BEQ      |L7.68|
;;;549          {
;;;550            /* Interrupt occurred */
;;;551            itstatus = SET;
000040  2001              MOVS     r0,#1
000042  e002              B        |L7.74|
                  |L7.68|
;;;552          }
;;;553          else
;;;554          {
;;;555            /* Interrupt didn't occur */
;;;556            itstatus = RESET;
000044  2000              MOVS     r0,#0
000046  e000              B        |L7.74|
                  |L7.72|
;;;557          }
;;;558        }
;;;559        else
;;;560        {
;;;561          /* Interrupt didn't occur */
;;;562          itstatus = (ITStatus) RESET;
000048  2000              MOVS     r0,#0
                  |L7.74|
;;;563        }
;;;564      }
;;;565    
;;;566      /* Return the AES_IT status */
;;;567      return itstatus;
;;;568    }
00004a  bd10              POP      {r4,pc}
;;;569    
                          ENDP

                  |L7.76|
                          DCD      0x50060000

                          AREA ||i.AES_ITConfig||, CODE, READONLY, ALIGN=2

                  AES_ITConfig PROC
;;;429      */
;;;430    void AES_ITConfig(uint32_t AES_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L8.14|
;;;431    {
;;;432      /* Check the parameters */
;;;433      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;434      assert_param(IS_AES_IT(AES_IT));
;;;435    
;;;436      if (NewState != DISABLE)
;;;437      {
;;;438        AES->CR |= (uint32_t) AES_IT;    /**< AES_IT Enable */
000002  4a06              LDR      r2,|L8.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L8.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;439      }
;;;440      else
;;;441      {
;;;442        AES->CR &= (uint32_t)(~AES_IT);  /**< AES_IT Disable */
00000e  4a03              LDR      r2,|L8.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L8.28|
000016  601a              STR      r2,[r3,#0]
                  |L8.24|
;;;443      }
;;;444    }
000018  4770              BX       lr
;;;445    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x50060000

                          AREA ||i.AES_IVInit||, CODE, READONLY, ALIGN=2

                  AES_IVInit PROC
;;;183      */
;;;184    void AES_IVInit(AES_IVInitTypeDef* AES_IVInitStruct)
000000  4a04              LDR      r2,|L9.20|
;;;185    {
;;;186      AES->IVR0 = AES_IVInitStruct->AES_IV0;
000002  6801              LDR      r1,[r0,#0]
000004  6211              STR      r1,[r2,#0x20]
;;;187      AES->IVR1 = AES_IVInitStruct->AES_IV1;
000006  6841              LDR      r1,[r0,#4]
000008  6251              STR      r1,[r2,#0x24]
;;;188      AES->IVR2 = AES_IVInitStruct->AES_IV2;
00000a  6881              LDR      r1,[r0,#8]
00000c  6291              STR      r1,[r2,#0x28]
;;;189      AES->IVR3 = AES_IVInitStruct->AES_IV3;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  62d1              STR      r1,[r2,#0x2c]
;;;190    }
000012  4770              BX       lr
;;;191    
                          ENDP

                  |L9.20|
                          DCD      0x50060000

                          AREA ||i.AES_IVStructInit||, CODE, READONLY, ALIGN=1

                  AES_IVStructInit PROC
;;;264      */
;;;265    void AES_IVStructInit(AES_IVInitTypeDef* AES_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;266    {
;;;267      AES_IVInitStruct->AES_IV0 = 0x00000000;
000002  6001              STR      r1,[r0,#0]
;;;268      AES_IVInitStruct->AES_IV1 = 0x00000000;
000004  6041              STR      r1,[r0,#4]
;;;269      AES_IVInitStruct->AES_IV2 = 0x00000000;
000006  6081              STR      r1,[r0,#8]
;;;270      AES_IVInitStruct->AES_IV3 = 0x00000000;
000008  60c1              STR      r1,[r0,#0xc]
;;;271    }
00000a  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.AES_Init||, CODE, READONLY, ALIGN=2

                  AES_Init PROC
;;;134      */
;;;135    void AES_Init(AES_InitTypeDef* AES_InitStruct)
000000  2100              MOVS     r1,#0
;;;136    {
;;;137      uint32_t tmpreg = 0;
;;;138      
;;;139      /* Check the parameters */
;;;140      assert_param(IS_AES_MODE(AES_InitStruct->AES_Operation));
;;;141      assert_param(IS_AES_CHAINING(AES_InitStruct->AES_Chaining));
;;;142      assert_param(IS_AES_DATATYPE(AES_InitStruct->AES_DataType));
;;;143    
;;;144      /* Get AES CR register value */
;;;145      tmpreg = AES->CR;
000002  4a06              LDR      r2,|L11.28|
000004  6811              LDR      r1,[r2,#0]
;;;146      
;;;147      /* Clear DATATYPE[1:0], MODE[1:0] and CHMOD[1:0] bits */
;;;148      tmpreg &= (uint32_t)CR_CLEAR_MASK;
000006  f021017e          BIC      r1,r1,#0x7e
;;;149      
;;;150      tmpreg |= (AES_InitStruct->AES_Operation | AES_InitStruct->AES_Chaining | AES_InitStruct->AES_DataType);
00000a  e9d02300          LDRD     r2,r3,[r0,#0]
00000e  431a              ORRS     r2,r2,r3
000010  6883              LDR      r3,[r0,#8]
000012  431a              ORRS     r2,r2,r3
000014  4311              ORRS     r1,r1,r2
;;;151    
;;;152      AES->CR = (uint32_t) tmpreg;
000016  4a01              LDR      r2,|L11.28|
000018  6011              STR      r1,[r2,#0]
;;;153    }
00001a  4770              BX       lr
;;;154    
                          ENDP

                  |L11.28|
                          DCD      0x50060000

                          AREA ||i.AES_KeyInit||, CODE, READONLY, ALIGN=2

                  AES_KeyInit PROC
;;;164      */
;;;165    void AES_KeyInit(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  4a04              LDR      r2,|L12.20|
;;;166    {
;;;167      AES->KEYR0 = AES_KeyInitStruct->AES_Key0;
000002  6801              LDR      r1,[r0,#0]
000004  6111              STR      r1,[r2,#0x10]
;;;168      AES->KEYR1 = AES_KeyInitStruct->AES_Key1;
000006  6841              LDR      r1,[r0,#4]
000008  6151              STR      r1,[r2,#0x14]
;;;169      AES->KEYR2 = AES_KeyInitStruct->AES_Key2;
00000a  6881              LDR      r1,[r0,#8]
00000c  6191              STR      r1,[r2,#0x18]
;;;170      AES->KEYR3 = AES_KeyInitStruct->AES_Key3;
00000e  68c1              LDR      r1,[r0,#0xc]
000010  61d1              STR      r1,[r2,#0x1c]
;;;171    }
000012  4770              BX       lr
;;;172    
                          ENDP

                  |L12.20|
                          DCD      0x50060000

                          AREA ||i.AES_KeyStructInit||, CODE, READONLY, ALIGN=1

                  AES_KeyStructInit PROC
;;;250      */
;;;251    void AES_KeyStructInit(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;252    {
;;;253      AES_KeyInitStruct->AES_Key0 = 0x00000000;
000002  6001              STR      r1,[r0,#0]
;;;254      AES_KeyInitStruct->AES_Key1 = 0x00000000;
000004  6041              STR      r1,[r0,#4]
;;;255      AES_KeyInitStruct->AES_Key2 = 0x00000000;
000006  6081              STR      r1,[r0,#8]
;;;256      AES_KeyInitStruct->AES_Key3 = 0x00000000;
000008  60c1              STR      r1,[r0,#0xc]
;;;257    }
00000a  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.AES_ReadIV||, CODE, READONLY, ALIGN=2

                  AES_ReadIV PROC
;;;347      */
;;;348    void AES_ReadIV(AES_IVInitTypeDef* AES_IVInitStruct)
000000  4906              LDR      r1,|L14.28|
;;;349    {
;;;350      AES_IVInitStruct->AES_IV0 = AES->IVR0;
000002  6a09              LDR      r1,[r1,#0x20]
000004  6001              STR      r1,[r0,#0]
;;;351      AES_IVInitStruct->AES_IV1 = AES->IVR1;
000006  4905              LDR      r1,|L14.28|
000008  6a49              LDR      r1,[r1,#0x24]
00000a  6041              STR      r1,[r0,#4]
;;;352      AES_IVInitStruct->AES_IV2 = AES->IVR2;
00000c  4903              LDR      r1,|L14.28|
00000e  6a89              LDR      r1,[r1,#0x28]
000010  6081              STR      r1,[r0,#8]
;;;353      AES_IVInitStruct->AES_IV3 = AES->IVR3;
000012  4902              LDR      r1,|L14.28|
000014  6ac9              LDR      r1,[r1,#0x2c]
000016  60c1              STR      r1,[r0,#0xc]
;;;354    }
000018  4770              BX       lr
;;;355    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x50060000

                          AREA ||i.AES_ReadKey||, CODE, READONLY, ALIGN=2

                  AES_ReadKey PROC
;;;326      */
;;;327    void AES_ReadKey(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  4906              LDR      r1,|L15.28|
;;;328    {
;;;329      AES_KeyInitStruct->AES_Key0 = AES->KEYR0;
000002  6909              LDR      r1,[r1,#0x10]
000004  6001              STR      r1,[r0,#0]
;;;330      AES_KeyInitStruct->AES_Key1 = AES->KEYR1;
000006  4905              LDR      r1,|L15.28|
000008  6949              LDR      r1,[r1,#0x14]
00000a  6041              STR      r1,[r0,#4]
;;;331      AES_KeyInitStruct->AES_Key2 = AES->KEYR2;
00000c  4903              LDR      r1,|L15.28|
00000e  6989              LDR      r1,[r1,#0x18]
000010  6081              STR      r1,[r0,#8]
;;;332      AES_KeyInitStruct->AES_Key3 = AES->KEYR3;
000012  4902              LDR      r1,|L15.28|
000014  69c9              LDR      r1,[r1,#0x1c]
000016  60c1              STR      r1,[r0,#0xc]
;;;333    }
000018  4770              BX       lr
;;;334    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x50060000

                          AREA ||i.AES_ReadSubData||, CODE, READONLY, ALIGN=2

                  AES_ReadSubData PROC
;;;310      */
;;;311    uint32_t AES_ReadSubData(void)
000000  4801              LDR      r0,|L16.8|
;;;312    {
;;;313      /* Read Data */
;;;314      return AES->DOUTR;
000002  68c0              LDR      r0,[r0,#0xc]
;;;315    }
000004  4770              BX       lr
;;;316    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x50060000

                          AREA ||i.AES_StructInit||, CODE, READONLY, ALIGN=1

                  AES_StructInit PROC
;;;237      */
;;;238    void AES_StructInit(AES_InitTypeDef* AES_InitStruct)
000000  2100              MOVS     r1,#0
;;;239    {
;;;240      AES_InitStruct->AES_Operation = AES_Operation_Encryp;
000002  6001              STR      r1,[r0,#0]
;;;241      AES_InitStruct->AES_Chaining = AES_Chaining_ECB;
000004  6041              STR      r1,[r0,#4]
;;;242      AES_InitStruct->AES_DataType = AES_DataType_32b;
000006  6081              STR      r1,[r0,#8]
;;;243    }
000008  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.AES_WriteSubData||, CODE, READONLY, ALIGN=2

                  AES_WriteSubData PROC
;;;297      */
;;;298    void AES_WriteSubData(uint32_t Data)
000000  4901              LDR      r1,|L18.8|
;;;299    {
;;;300      /* Write Data */
;;;301      AES->DINR = Data;
000002  6088              STR      r0,[r1,#8]
;;;302    }
000004  4770              BX       lr
;;;303    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x50060000

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_aes.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32l1xx_aes_c_8ada0bca____REV16|
#line 113 "..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_stm32l1xx_aes_c_8ada0bca____REV16| PROC
#line 114

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32l1xx_aes_c_8ada0bca____REVSH|
#line 131
|__asm___15_stm32l1xx_aes_c_8ada0bca____REVSH| PROC
#line 132

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
