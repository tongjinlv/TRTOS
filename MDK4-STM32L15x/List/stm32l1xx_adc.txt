; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\user\prj_insectv2\obj\stm32l1xx_adc.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\user\prj_insectv2\obj\stm32l1xx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\src -I..\USER -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx -I..\Driver -I..\Configs -I..\Boot -I..\Tos -I..\Tools -I..\FS\TQFS -I..\USER\Prj_4.3LCD -I..\USER\Prj_CanBus -I..\USER\Prj_Sensor -I..\GUI\MGui -I..\FuncTask -I..\USER\Prj_Really -I..\USER\Prj_PdaTran -I..\USB\WHID -I..\FS -I..\GUI\TGui -I..\GUI -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -IE:\Soft\keil472a\ARM\RV31\INC -IE:\Soft\keil472a\ARM\CMSIS\Include -IE:\Soft\keil472a\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DBOARD_InsectV2 -DUSE_STDPERIPH_DRIVER --omf_browse=..\user\prj_insectv2\obj\stm32l1xx_adc.crf ..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;563      */
;;;564    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  460a              MOV      r2,r1
;;;565    {
;;;566      uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;567    
;;;568      /* Check the parameters */
;;;569      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;570      assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;571    
;;;572      /* Get the old register value */
;;;573      tmpreg = ADCx->CR1;
000004  6841              LDR      r1,[r0,#4]
;;;574      /* Clear AWDEN, JAWDEN and AWDSGL bits */   
;;;575      tmpreg &= CR1_AWDMODE_RESET;
000006  4b02              LDR      r3,|L1.16|
000008  4019              ANDS     r1,r1,r3
;;;576      /* Set the analog watchdog enable mode */
;;;577      tmpreg |= ADC_AnalogWatchdog;
00000a  4311              ORRS     r1,r1,r2
;;;578      /* Store the new register value */
;;;579      ADCx->CR1 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;580    }
00000e  4770              BX       lr
;;;581    
                          ENDP

                  |L1.16|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;653      */
;;;654    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  460a              MOV      r2,r1
;;;655    {
;;;656      uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;657    
;;;658      /* Check the parameters */
;;;659      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;660      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;661    
;;;662      /* Get the old register value */
;;;663      tmpreg = ADCx->CR1;
000004  6841              LDR      r1,[r0,#4]
;;;664      /* Clear the Analog watchdog channel select bits */
;;;665      tmpreg &= CR1_AWDCH_RESET;
000006  f021011f          BIC      r1,r1,#0x1f
;;;666      /* Set the Analog watchdog channel */
;;;667      tmpreg |= ADC_Channel;
00000a  4311              ORRS     r1,r1,r2
;;;668      /* Store the new register value */
;;;669      ADCx->CR1 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;670    }
00000e  4770              BX       lr
;;;671    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;590      */
;;;591    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  6281              STR      r1,[r0,#0x28]
;;;592                                            uint16_t LowThreshold)
;;;593    {
;;;594      /* Check the parameters */
;;;595      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;596      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;597      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;598    
;;;599      /* Set the ADCx high threshold */
;;;600      ADCx->HTR = HighThreshold;
;;;601      /* Set the ADCx low threshold */
;;;602      ADCx->LTR = LowThreshold;
000002  62c2              STR      r2,[r0,#0x2c]
;;;603    }
000004  4770              BX       lr
;;;604    
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;1577     */
;;;1578   void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;1579   {
;;;1580     /* Check the parameters */
;;;1581     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1582     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1583   
;;;1584     if (NewState != DISABLE)
;;;1585     {
;;;1586       /* Enable the selected ADC automatic injected group conversion */
;;;1587       ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
000002  6842              LDR      r2,[r0,#4]
000004  f4426280          ORR      r2,r2,#0x400
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       /* Disable the selected ADC automatic injected group conversion */
;;;1592       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
00000c  6842              LDR      r2,[r0,#4]
00000e  f4226280          BIC      r2,r2,#0x400
000012  6042              STR      r2,[r0,#4]
                  |L4.20|
;;;1593     }
;;;1594   }
000014  4770              BX       lr
;;;1595   
                          ENDP


                          AREA ||i.ADC_BankSelection||, CODE, READONLY, ALIGN=1

                  ADC_BankSelection PROC
;;;381      */
;;;382    void ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank)
000000  b121              CBZ      r1,|L5.12|
;;;383    {
;;;384      /* Check the parameters */
;;;385      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;386      assert_param(IS_ADC_BANK(ADC_Bank));
;;;387    
;;;388      if (ADC_Bank != ADC_Bank_A)
;;;389      {
;;;390        /* Set the ADC_CFG bit to select the ADC Bank B channels */
;;;391        ADCx->CR2 |= (uint32_t)ADC_CR2_CFG;
000002  6882              LDR      r2,[r0,#8]
000004  f0420204          ORR      r2,r2,#4
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L5.20|
                  |L5.12|
;;;392      }
;;;393      else
;;;394      {
;;;395        /* Reset the ADC_CFG bit to select the ADC Bank A channels */
;;;396        ADCx->CR2 &= (uint32_t)(~ADC_CR2_CFG);
00000c  6882              LDR      r2,[r0,#8]
00000e  f0220204          BIC      r2,r2,#4
000012  6082              STR      r2,[r0,#8]
                  |L5.20|
;;;397      }
;;;398    }
000014  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1815     */
;;;1816   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
000000  43ca              MVNS     r2,r1
;;;1817   {
;;;1818     /* Check the parameters */
;;;1819     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1820     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1821   
;;;1822     /* Clear the selected ADC flags */
;;;1823     ADCx->SR = ~(uint32_t)ADC_FLAG;
000002  6002              STR      r2,[r0,#0]
;;;1824   }
000004  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1877     */
;;;1878   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  2200              MOVS     r2,#0
;;;1879   {
;;;1880     uint8_t itmask = 0;
;;;1881   
;;;1882     /* Check the parameters */
;;;1883     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1884     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1885   
;;;1886     /* Get the ADC IT index */
;;;1887     itmask = (uint8_t)(ADC_IT >> 8);
000002  120a              ASRS     r2,r1,#8
;;;1888   
;;;1889     /* Clear the selected ADC interrupt pending bits */
;;;1890     ADCx->SR = ~(uint32_t)itmask;
000004  43d3              MVNS     r3,r2
000006  6003              STR      r3,[r0,#0]
;;;1891   }
000008  4770              BX       lr
;;;1892   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;355      */
;;;356    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;357    {
;;;358      /* Check the parameters */
;;;359      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;360      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;361    
;;;362      if (NewState != DISABLE)
;;;363      {
;;;364        /* Set the ADON bit to wake up the ADC from power down mode */
;;;365        ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
000002  6882              LDR      r2,[r0,#8]
000004  f0420201          ORR      r2,r2,#1
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L8.20|
                  |L8.12|
;;;366      }
;;;367      else
;;;368      {
;;;369        /* Disable the selected ADC peripheral */
;;;370        ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
00000c  6882              LDR      r2,[r0,#8]
00000e  f0220201          BIC      r2,r2,#1
000012  6082              STR      r2,[r0,#8]
                  |L8.20|
;;;371      }
;;;372    }
000014  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  ADC_CommonInit PROC
;;;314      */
;;;315    void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                           
000000  4601              MOV      r1,r0
;;;316    {
;;;317      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;318      
;;;319      /* Check the parameters */
;;;320      assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
;;;321    
;;;322      /*---------------------------- ADC CCR Configuration -----------------*/
;;;323      /* Get the ADC CCR value */
;;;324      tmpreg = ADC->CCR;
000004  4a04              LDR      r2,|L9.24|
000006  6810              LDR      r0,[r2,#0]
;;;325    
;;;326      /* Clear ADCPRE bit */ 
;;;327      tmpreg &= CR_CLEAR_MASK;
000008  f4203040          BIC      r0,r0,#0x30000
;;;328      
;;;329      /* Configure ADCx: ADC prescaler according to ADC_Prescaler */                
;;;330      tmpreg |= (uint32_t)(ADC_CommonInitStruct->ADC_Prescaler);        
00000c  680a              LDR      r2,[r1,#0]
00000e  4310              ORRS     r0,r0,r2
;;;331                    
;;;332      /* Write to ADC CCR */
;;;333      ADC->CCR = tmpreg;
000010  4a01              LDR      r2,|L9.24|
000012  6010              STR      r0,[r2,#0]
;;;334    }
000014  4770              BX       lr
;;;335    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40012704

                          AREA ||i.ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  ADC_CommonStructInit PROC
;;;341      */
;;;342    void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                      
000000  2100              MOVS     r1,#0
;;;343    {
;;;344      /* Reset ADC init structure parameters values */
;;;345      /* Initialize the ADC_Prescaler member */
;;;346      ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div1;
000002  6001              STR      r1,[r0,#0]
;;;347    }
000004  4770              BX       lr
;;;348    
                          ENDP


                          AREA ||i.ADC_ContinuousModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_ContinuousModeCmd PROC
;;;1051     */
;;;1052   void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L11.12|
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1056     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1057   
;;;1058     if (NewState != DISABLE)
;;;1059     {
;;;1060       /* Enable the selected ADC continuous conversion mode */
;;;1061       ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
000002  6882              LDR      r2,[r0,#8]
000004  f0420202          ORR      r2,r2,#2
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L11.20|
                  |L11.12|
;;;1062     }
;;;1063     else
;;;1064     {
;;;1065       /* Disable the selected ADC continuous conversion mode */
;;;1066       ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
00000c  6882              LDR      r2,[r0,#8]
00000e  f0220202          BIC      r2,r2,#2
000012  6082              STR      r2,[r0,#8]
                  |L11.20|
;;;1067     }
;;;1068   }
000014  4770              BX       lr
;;;1069   
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;1173     */
;;;1174   void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L12.12|
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;1178     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1179   
;;;1180     if (NewState != DISABLE)
;;;1181     {
;;;1182       /* Enable the selected ADC DMA request */
;;;1183       ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
000002  6882              LDR      r2,[r0,#8]
000004  f4427280          ORR      r2,r2,#0x100
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L12.20|
                  |L12.12|
;;;1184     }
;;;1185     else
;;;1186     {
;;;1187       /* Disable the selected ADC DMA request */
;;;1188       ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
00000c  6882              LDR      r2,[r0,#8]
00000e  f4227280          BIC      r2,r2,#0x100
000012  6082              STR      r2,[r0,#8]
                  |L12.20|
;;;1189     }
;;;1190   }
000014  4770              BX       lr
;;;1191   
                          ENDP


                          AREA ||i.ADC_DMARequestAfterLastTransferCmd||, CODE, READONLY, ALIGN=1

                  ADC_DMARequestAfterLastTransferCmd PROC
;;;1199     */
;;;1200   void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;1201   {
;;;1202     /* Check the parameters */
;;;1203     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1204     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1205   
;;;1206     if (NewState != DISABLE)
;;;1207     {
;;;1208       /* Enable the selected ADC DMA request after last transfer */
;;;1209       ADCx->CR2 |= ADC_CR2_DDS;
000002  6882              LDR      r2,[r0,#8]
000004  f4427200          ORR      r2,r2,#0x200
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L13.20|
                  |L13.12|
;;;1210     }
;;;1211     else
;;;1212     {
;;;1213       /* Disable the selected ADC DMA request after last transfer */
;;;1214       ADCx->CR2 &= (uint32_t)~ADC_CR2_DDS;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4227200          BIC      r2,r2,#0x200
000012  6082              STR      r2,[r0,#8]
                  |L13.20|
;;;1215     }
;;;1216   }
000014  4770              BX       lr
;;;1217   
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;189      */
;;;190    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;191    {
000002  4604              MOV      r4,r0
;;;192      /* Check the parameters */
;;;193      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;194    
;;;195      if(ADCx == ADC1)
000004  4805              LDR      r0,|L14.28|
000006  4284              CMP      r4,r0
000008  d107              BNE      |L14.26|
;;;196      {
;;;197        /* Enable ADC1 reset state */
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1540              ASRS     r0,r0,#21
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;199        /* Release ADC1 from reset state */
;;;200        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  2100              MOVS     r1,#0
000014  1560              ASRS     r0,r4,#21
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L14.26|
;;;201      }
;;;202    }
00001a  bd10              POP      {r4,pc}
;;;203    
                          ENDP

                  |L14.28|
                          DCD      0x40012400

                          AREA ||i.ADC_DelaySelectionConfig||, CODE, READONLY, ALIGN=1

                  ADC_DelaySelectionConfig PROC
;;;498      */
;;;499    void ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength)
000000  460a              MOV      r2,r1
;;;500    {
;;;501      uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;502       
;;;503      /* Check the parameters */
;;;504      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;505      assert_param(IS_ADC_DELAY_LENGTH(ADC_DelayLength));
;;;506    
;;;507      /* Get the old register value */    
;;;508      tmpreg = ADCx->CR2;
000004  6881              LDR      r1,[r0,#8]
;;;509      /* Clear the old delay length */
;;;510      tmpreg &= CR2_DELS_RESET;
000006  f02101f0          BIC      r1,r1,#0xf0
;;;511      /* Set the delay length */
;;;512      tmpreg |= ADC_DelayLength;
00000a  4311              ORRS     r1,r1,r2
;;;513      /* Store the new register value */
;;;514      ADCx->CR2 = tmpreg;
00000c  6081              STR      r1,[r0,#8]
;;;515    
;;;516    }
00000e  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;1077     */
;;;1078   void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  b510              PUSH     {r4,lr}
;;;1079   {
000002  460a              MOV      r2,r1
;;;1080     uint32_t tmpreg1 = 0;
000004  2100              MOVS     r1,#0
;;;1081     uint32_t tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1085     assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;1086   
;;;1087     /* Get the old register value */
;;;1088     tmpreg1 = ADCx->CR1;
000008  6841              LDR      r1,[r0,#4]
;;;1089     /* Clear the old discontinuous mode channel count */
;;;1090     tmpreg1 &= CR1_DISCNUM_RESET;
00000a  f4214160          BIC      r1,r1,#0xe000
;;;1091     /* Set the discontinuous mode channel count */
;;;1092     tmpreg2 = Number - 1;
00000e  1e53              SUBS     r3,r2,#1
;;;1093     tmpreg1 |= tmpreg2 << 13;
000010  ea413143          ORR      r1,r1,r3,LSL #13
;;;1094     /* Store the new register value */
;;;1095     ADCx->CR1 = tmpreg1;
000014  6041              STR      r1,[r0,#4]
;;;1096   }
000016  bd10              POP      {r4,pc}
;;;1097   
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;1106     */
;;;1107   void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;1108   {
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1111     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1112   
;;;1113     if (NewState != DISABLE)
;;;1114     {
;;;1115       /* Enable the selected ADC regular discontinuous mode */
;;;1116       ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
000002  6842              LDR      r2,[r0,#4]
000004  f4426200          ORR      r2,r2,#0x800
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L17.20|
                  |L17.12|
;;;1117     }
;;;1118     else
;;;1119     {
;;;1120       /* Disable the selected ADC regular discontinuous mode */
;;;1121       ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
00000c  6842              LDR      r2,[r0,#4]
00000e  f4226200          BIC      r2,r2,#0x800
000012  6042              STR      r2,[r0,#4]
                  |L17.20|
;;;1122     }
;;;1123   }
000014  4770              BX       lr
;;;1124   
                          ENDP


                          AREA ||i.ADC_EOCOnEachRegularChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_EOCOnEachRegularChannelCmd PROC
;;;1026     */
;;;1027   void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L18.12|
;;;1028   {
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1031     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1032   
;;;1033     if (NewState != DISABLE)
;;;1034     {
;;;1035       /* Enable the selected ADC EOC rising on each regular channel conversion */
;;;1036       ADCx->CR2 |= ADC_CR2_EOCS;
000002  6882              LDR      r2,[r0,#8]
000004  f4426280          ORR      r2,r2,#0x400
000008  6082              STR      r2,[r0,#8]
00000a  e003              B        |L18.20|
                  |L18.12|
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       /* Disable the selected ADC EOC rising on each regular channel conversion */
;;;1041       ADCx->CR2 &= (uint32_t)~ADC_CR2_EOCS;
00000c  6882              LDR      r2,[r0,#8]
00000e  f4226280          BIC      r2,r2,#0x400
000012  6082              STR      r2,[r0,#8]
                  |L18.20|
;;;1042     }
;;;1043   }
000014  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;1477     */
;;;1478   void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  460a              MOV      r2,r1
;;;1479   {
;;;1480     uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1481   
;;;1482     /* Check the parameters */
;;;1483     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1484     assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;1485   
;;;1486     /* Get the old register value */
;;;1487     tmpreg = ADCx->CR2;
000004  6881              LDR      r1,[r0,#8]
;;;1488     /* Clear the old external event selection for injected group */
;;;1489     tmpreg &= CR2_JEXTSEL_RESET;
000006  f4212170          BIC      r1,r1,#0xf0000
;;;1490     /* Set the external event selection for injected group */
;;;1491     tmpreg |= ADC_ExternalTrigInjecConv;
00000a  4311              ORRS     r1,r1,r2
;;;1492     /* Store the new register value */
;;;1493     ADCx->CR2 = tmpreg;
00000c  6081              STR      r1,[r0,#8]
;;;1494   }
00000e  4770              BX       lr
;;;1495   
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvEdgeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvEdgeConfig PROC
;;;1509     */
;;;1510   void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
000000  460a              MOV      r2,r1
;;;1511   {
;;;1512     uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1513   
;;;1514     /* Check the parameters */
;;;1515     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1516     assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
;;;1517   
;;;1518     /* Get the old register value */
;;;1519     tmpreg = ADCx->CR2;
000004  6881              LDR      r1,[r0,#8]
;;;1520     /* Clear the old external trigger edge for injected group */
;;;1521     tmpreg &= CR2_JEXTEN_RESET;
000006  f4211140          BIC      r1,r1,#0x300000
;;;1522     /* Set the new external trigger edge for injected group */
;;;1523     tmpreg |= ADC_ExternalTrigInjecConvEdge;
00000a  4311              ORRS     r1,r1,r2
;;;1524     /* Store the new register value */
;;;1525     ADCx->CR2 = tmpreg;
00000c  6081              STR      r1,[r0,#8]
;;;1526   }
00000e  4770              BX       lr
;;;1527   
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;1129     */
;;;1130   uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1131   {
;;;1132     /* Check the parameters */
;;;1133     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1134   
;;;1135     /* Return the selected ADC conversion value */
;;;1136     return (uint16_t) ADCx->DR;
000002  6d88              LDR      r0,[r1,#0x58]
000004  b280              UXTH     r0,r0
;;;1137   }
000006  4770              BX       lr
;;;1138   
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1779     */
;;;1780   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1781   {
;;;1782     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1783   
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1786     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1787   
;;;1788     /* Check the status of the specified ADC flag */
;;;1789     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000004  6813              LDR      r3,[r2,#0]
000006  420b              TST      r3,r1
000008  d001              BEQ      |L22.14|
;;;1790     {
;;;1791       /* ADC_FLAG is set */
;;;1792       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L22.16|
                  |L22.14|
;;;1793     }
;;;1794     else
;;;1795     {
;;;1796       /* ADC_FLAG is reset */
;;;1797       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L22.16|
;;;1798     }
;;;1799     /* Return the ADC_FLAG status */
;;;1800     return  bitstatus;
;;;1801   }
000010  4770              BX       lr
;;;1802   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1836     */
;;;1837   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1838   {
000002  4602              MOV      r2,r0
;;;1839     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1840     uint32_t itmask = 0, enablestatus = 0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;1841   
;;;1842     /* Check the parameters */
;;;1843     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1844     assert_param(IS_ADC_IT(ADC_IT));
;;;1845   
;;;1846     /* Get the ADC IT index */
;;;1847     itmask = (uint32_t)((uint32_t)ADC_IT >> 8);
00000a  0a0b              LSRS     r3,r1,#8
;;;1848   
;;;1849     /* Get the ADC_IT enable bit status */
;;;1850     enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)); 
00000c  6855              LDR      r5,[r2,#4]
00000e  2601              MOVS     r6,#1
000010  408e              LSLS     r6,r6,r1
000012  ea050406          AND      r4,r5,r6
;;;1851   
;;;1852     /* Check the status of the specified ADC interrupt */
;;;1853     if (((uint32_t)(ADCx->SR & (uint32_t)itmask) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
000016  6815              LDR      r5,[r2,#0]
000018  421d              TST      r5,r3
00001a  d002              BEQ      |L23.34|
00001c  b10c              CBZ      r4,|L23.34|
;;;1854     {                                                         
;;;1855       /* ADC_IT is set */
;;;1856       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L23.36|
                  |L23.34|
;;;1857     }
;;;1858     else
;;;1859     {
;;;1860       /* ADC_IT is reset */
;;;1861       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L23.36|
;;;1862     }
;;;1863     /* Return the ADC_IT status */
;;;1864     return  bitstatus;
;;;1865   }
000024  bd70              POP      {r4-r6,pc}
;;;1866   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1632     */
;;;1633   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b508              PUSH     {r3,lr}
;;;1634   {
000002  4602              MOV      r2,r0
;;;1635     __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1636     
;;;1637     /* Check the parameters */
;;;1638     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1639     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1640   
;;;1641     tmp = (uint32_t)ADCx;
000008  9200              STR      r2,[sp,#0]
;;;1642     tmp += ADC_InjectedChannel + JDR_OFFSET;
00000a  f1010030          ADD      r0,r1,#0x30
00000e  9b00              LDR      r3,[sp,#0]
000010  4418              ADD      r0,r0,r3
000012  9000              STR      r0,[sp,#0]
;;;1643     
;;;1644     /* Returns the selected injected channel conversion data value */
;;;1645     return (uint16_t) (*(__IO uint32_t*)  tmp); 
000014  9800              LDR      r0,[sp,#0]
000016  6800              LDR      r0,[r0,#0]
000018  b280              UXTH     r0,r0
;;;1646   }
00001a  bd08              POP      {r3,pc}
;;;1647   
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;997      */
;;;998    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;999    {
;;;1000     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1001   
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1004   
;;;1005     /* Check the status of SWSTART bit */
;;;1006     if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f0124f80          TST      r2,#0x40000000
00000a  d001              BEQ      |L25.16|
;;;1007     {
;;;1008       /* SWSTART bit is set */
;;;1009       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L25.18|
                  |L25.16|
;;;1010     }
;;;1011     else
;;;1012     {
;;;1013       /* SWSTART bit is reset */
;;;1014       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L25.18|
;;;1015     }
;;;1016     /* Return the SWSTART bit status */
;;;1017     return  bitstatus;
;;;1018   }
000012  4770              BX       lr
;;;1019   
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;1546     */
;;;1547   FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;1548   {
;;;1549     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1550   
;;;1551     /* Check the parameters */
;;;1552     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1553   
;;;1554     /* Check the status of JSWSTART bit */
;;;1555     if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
000004  688a              LDR      r2,[r1,#8]
000006  f4120f80          TST      r2,#0x400000
00000a  d001              BEQ      |L26.16|
;;;1556     {
;;;1557       /* JSWSTART bit is set */
;;;1558       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L26.18|
                  |L26.16|
;;;1559     }
;;;1560     else
;;;1561     {
;;;1562       /* JSWSTART bit is reset */
;;;1563       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L26.18|
;;;1564     }
;;;1565     /* Return the JSWSTART bit status */
;;;1566     return  bitstatus;
;;;1567   }
000012  4770              BX       lr
;;;1568   
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;1738     */
;;;1739   void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
000000  b510              PUSH     {r4,lr}
;;;1740   {
000002  460b              MOV      r3,r1
;;;1741     uint32_t itmask = 0;
000004  2100              MOVS     r1,#0
;;;1742   
;;;1743     /* Check the parameters */
;;;1744     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1745     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1746     assert_param(IS_ADC_IT(ADC_IT)); 
;;;1747   
;;;1748     /* Get the ADC IT index */
;;;1749     itmask = (uint8_t)ADC_IT;
000006  b2d9              UXTB     r1,r3
;;;1750     itmask = (uint32_t)0x01 << itmask;    
000008  2401              MOVS     r4,#1
00000a  fa04f101          LSL      r1,r4,r1
;;;1751   
;;;1752     if (NewState != DISABLE)
00000e  b11a              CBZ      r2,|L27.24|
;;;1753     {
;;;1754       /* Enable the selected ADC interrupts */
;;;1755       ADCx->CR1 |= itmask;
000010  6844              LDR      r4,[r0,#4]
000012  430c              ORRS     r4,r4,r1
000014  6044              STR      r4,[r0,#4]
000016  e002              B        |L27.30|
                  |L27.24|
;;;1756     }
;;;1757     else
;;;1758     {
;;;1759       /* Disable the selected ADC interrupts */
;;;1760       ADCx->CR1 &= (~(uint32_t)itmask);
000018  6844              LDR      r4,[r0,#4]
00001a  438c              BICS     r4,r4,r1
00001c  6044              STR      r4,[r0,#4]
                  |L27.30|
;;;1761     }
;;;1762   }
00001e  bd10              POP      {r4,pc}
;;;1763   
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;216      */
;;;217    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
000000  b530              PUSH     {r4,r5,lr}
;;;218    {
000002  4602              MOV      r2,r0
;;;219      uint32_t tmpreg1 = 0;
000004  2000              MOVS     r0,#0
;;;220      uint8_t tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;221      
;;;222      /* Check the parameters */
;;;223      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;224      assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
;;;225      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;226      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
;;;227      assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
;;;228      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
;;;229      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;230      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
;;;231      
;;;232      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;233      /* Get the ADCx CR1 value */
;;;234      tmpreg1 = ADCx->CR1;
000008  6850              LDR      r0,[r2,#4]
;;;235      /* Clear RES and SCAN bits */ 
;;;236      tmpreg1 &= CR1_CLEAR_MASK;
00000a  4c10              LDR      r4,|L28.76|
00000c  4020              ANDS     r0,r0,r4
;;;237      /* Configure ADCx: scan conversion mode and resolution */
;;;238      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;239      /* Set RES bit according to ADC_Resolution value */ 
;;;240      tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
00000e  790d              LDRB     r5,[r1,#4]
000010  680c              LDR      r4,[r1,#0]
000012  ea442405          ORR      r4,r4,r5,LSL #8
000016  4320              ORRS     r0,r0,r4
;;;241      /* Write to ADCx CR1 */
;;;242      ADCx->CR1 = tmpreg1;
000018  6050              STR      r0,[r2,#4]
;;;243      
;;;244      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;245      /* Get the ADCx CR2 value */
;;;246      tmpreg1 = ADCx->CR2;
00001a  6890              LDR      r0,[r2,#8]
;;;247      /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
;;;248      tmpreg1 &= CR2_CLEAR_MASK;
00001c  4c0c              LDR      r4,|L28.80|
00001e  4020              ANDS     r0,r0,r4
;;;249      /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
;;;250      /* Set ALIGN bit according to ADC_DataAlign value */
;;;251      /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
;;;252      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;253      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;254      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
000020  e9d15403          LDRD     r5,r4,[r1,#0xc]
000024  432c              ORRS     r4,r4,r5
000026  688d              LDR      r5,[r1,#8]
000028  432c              ORRS     r4,r4,r5
00002a  794d              LDRB     r5,[r1,#5]
00002c  ea440445          ORR      r4,r4,r5,LSL #1
000030  4320              ORRS     r0,r0,r4
;;;255                  ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;256      /* Write to ADCx CR2 */
;;;257      ADCx->CR2 = tmpreg1;
000032  6090              STR      r0,[r2,#8]
;;;258      
;;;259      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;260      /* Get the ADCx SQR1 value */
;;;261      tmpreg1 = ADCx->SQR1;
000034  6b10              LDR      r0,[r2,#0x30]
;;;262      /* Clear L bits */
;;;263      tmpreg1 &= SQR1_L_RESET;
000036  f02070f8          BIC      r0,r0,#0x1f00000
;;;264      /* Configure ADCx: regular channel sequence length */
;;;265      /* Set L bits according to ADC_NbrOfConversion value */ 
;;;266      tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
00003a  7d0c              LDRB     r4,[r1,#0x14]
00003c  1e64              SUBS     r4,r4,#1
00003e  b2e4              UXTB     r4,r4
000040  4323              ORRS     r3,r3,r4
;;;267      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
000042  ea405003          ORR      r0,r0,r3,LSL #20
;;;268      /* Write to ADCx SQR1 */
;;;269      ADCx->SQR1 = tmpreg1;
000046  6310              STR      r0,[r2,#0x30]
;;;270    }
000048  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

00004a  0000              DCW      0x0000
                  |L28.76|
                          DCD      0xfcfffeff
                  |L28.80|
                          DCD      0xc0fff7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;1311     */
;;;1312   void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1313   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1314     uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
000006  2000              MOVS     r0,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;1315   
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1318     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1319     assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;1320     assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;1321     
;;;1322     /* If ADC_Channel_30 or ADC_Channel_31 is selected */
;;;1323     if (ADC_Channel > ADC_Channel_29)
00000c  291d              CMP      r1,#0x1d
00000e  dd11              BLE      |L29.52|
;;;1324     {
;;;1325       /* Get the old register value */
;;;1326       tmpreg1 = ADCx->SMPR0;
000010  6de0              LDR      r0,[r4,#0x5c]
;;;1327       /* Calculate the mask to clear */
;;;1328       tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
000012  f1a1071e          SUB      r7,r1,#0x1e
000016  eb070c47          ADD      r12,r7,r7,LSL #1
00001a  2707              MOVS     r7,#7
00001c  fa07f20c          LSL      r2,r7,r12
;;;1329       /* Clear the old sample time */
;;;1330       tmpreg1 &= ~tmpreg2;
000020  4390              BICS     r0,r0,r2
;;;1331       /* Calculate the mask to set */
;;;1332       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
000022  f1a1071e          SUB      r7,r1,#0x1e
000026  eb070747          ADD      r7,r7,r7,LSL #1
00002a  fa03f207          LSL      r2,r3,r7
;;;1333       /* Set the new sample time */
;;;1334       tmpreg1 |= tmpreg2;
00002e  4310              ORRS     r0,r0,r2
;;;1335       /* Store the new register value */
;;;1336       ADCx->SMPR0 = tmpreg1;
000030  65e0              STR      r0,[r4,#0x5c]
000032  e034              B        |L29.158|
                  |L29.52|
;;;1337     }
;;;1338     /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
;;;1339     else if (ADC_Channel > ADC_Channel_19)
000034  2913              CMP      r1,#0x13
000036  dd11              BLE      |L29.92|
;;;1340     {
;;;1341       /* Get the old register value */
;;;1342       tmpreg1 = ADCx->SMPR1;
000038  68e0              LDR      r0,[r4,#0xc]
;;;1343       /* Calculate the mask to clear */
;;;1344       tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
00003a  f1a10714          SUB      r7,r1,#0x14
00003e  eb070c47          ADD      r12,r7,r7,LSL #1
000042  2707              MOVS     r7,#7
000044  fa07f20c          LSL      r2,r7,r12
;;;1345       /* Clear the old sample time */
;;;1346       tmpreg1 &= ~tmpreg2;
000048  4390              BICS     r0,r0,r2
;;;1347       /* Calculate the mask to set */
;;;1348       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
00004a  f1a10714          SUB      r7,r1,#0x14
00004e  eb070747          ADD      r7,r7,r7,LSL #1
000052  fa03f207          LSL      r2,r3,r7
;;;1349       /* Set the new sample time */
;;;1350       tmpreg1 |= tmpreg2;
000056  4310              ORRS     r0,r0,r2
;;;1351       /* Store the new register value */
;;;1352       ADCx->SMPR1 = tmpreg1;
000058  60e0              STR      r0,[r4,#0xc]
00005a  e020              B        |L29.158|
                  |L29.92|
;;;1353     }  
;;;1354     /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
;;;1355     else if (ADC_Channel > ADC_Channel_9)
00005c  2909              CMP      r1,#9
00005e  dd11              BLE      |L29.132|
;;;1356     {
;;;1357       /* Get the old register value */
;;;1358       tmpreg1 = ADCx->SMPR2;
000060  6920              LDR      r0,[r4,#0x10]
;;;1359       /* Calculate the mask to clear */
;;;1360       tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
000062  f1a1070a          SUB      r7,r1,#0xa
000066  eb070c47          ADD      r12,r7,r7,LSL #1
00006a  2707              MOVS     r7,#7
00006c  fa07f20c          LSL      r2,r7,r12
;;;1361       /* Clear the old sample time */
;;;1362       tmpreg1 &= ~tmpreg2;
000070  4390              BICS     r0,r0,r2
;;;1363       /* Calculate the mask to set */
;;;1364       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000072  f1a1070a          SUB      r7,r1,#0xa
000076  eb070747          ADD      r7,r7,r7,LSL #1
00007a  fa03f207          LSL      r2,r3,r7
;;;1365       /* Set the new sample time */
;;;1366       tmpreg1 |= tmpreg2;
00007e  4310              ORRS     r0,r0,r2
;;;1367       /* Store the new register value */
;;;1368       ADCx->SMPR2 = tmpreg1;
000080  6120              STR      r0,[r4,#0x10]
000082  e00c              B        |L29.158|
                  |L29.132|
;;;1369     }
;;;1370     else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;1371     {
;;;1372       /* Get the old register value */
;;;1373       tmpreg1 = ADCx->SMPR3;
000084  6960              LDR      r0,[r4,#0x14]
;;;1374       /* Calculate the mask to clear */
;;;1375       tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
000086  eb010c41          ADD      r12,r1,r1,LSL #1
00008a  2707              MOVS     r7,#7
00008c  fa07f20c          LSL      r2,r7,r12
;;;1376       /* Clear the old sample time */
;;;1377       tmpreg1 &= ~tmpreg2;
000090  4390              BICS     r0,r0,r2
;;;1378       /* Calculate the mask to set */
;;;1379       tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000092  eb010741          ADD      r7,r1,r1,LSL #1
000096  fa03f207          LSL      r2,r3,r7
;;;1380       /* Set the new sample time */
;;;1381       tmpreg1 |= tmpreg2;
00009a  4310              ORRS     r0,r0,r2
;;;1382       /* Store the new register value */
;;;1383       ADCx->SMPR3 = tmpreg1;
00009c  6160              STR      r0,[r4,#0x14]
                  |L29.158|
;;;1384     }
;;;1385     
;;;1386     /* Rank configuration */
;;;1387     /* Get the old register value */
;;;1388     tmpreg1 = ADCx->JSQR;
00009e  6c60              LDR      r0,[r4,#0x44]
;;;1389     /* Get JL value: Number = JL+1 */
;;;1390     tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
0000a0  f3c05601          UBFX     r6,r0,#20,#2
;;;1391     /* Calculate the mask to clear: ((Rank-1)+(4- (JL+1))) */ 
;;;1392     tmpreg2 = (uint32_t)(JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
0000a4  1cef              ADDS     r7,r5,#3
0000a6  f1060c01          ADD      r12,r6,#1
0000aa  eba7070c          SUB      r7,r7,r12
0000ae  eb070c87          ADD      r12,r7,r7,LSL #2
0000b2  271f              MOVS     r7,#0x1f
0000b4  fa07f20c          LSL      r2,r7,r12
;;;1393     /* Clear the old JSQx bits for the selected rank */
;;;1394     tmpreg1 &= ~tmpreg2;
0000b8  4390              BICS     r0,r0,r2
;;;1395     /* Calculate the mask to set: ((Rank-1)+(4- (JL+1))) */ 
;;;1396     tmpreg2 = (uint32_t)(((uint32_t)(ADC_Channel)) << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
0000ba  1cef              ADDS     r7,r5,#3
0000bc  f1060c01          ADD      r12,r6,#1
0000c0  eba7070c          SUB      r7,r7,r12
0000c4  eb070787          ADD      r7,r7,r7,LSL #2
0000c8  fa01f207          LSL      r2,r1,r7
;;;1397     /* Set the JSQx bits for the selected rank */
;;;1398     tmpreg1 |= tmpreg2;
0000cc  4310              ORRS     r0,r0,r2
;;;1399     /* Store the new register value */
;;;1400     ADCx->JSQR = tmpreg1;
0000ce  6460              STR      r0,[r4,#0x44]
;;;1401   }
0000d0  bdf0              POP      {r4-r7,pc}
;;;1402   
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;1603     */
;;;1604   void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  b121              CBZ      r1,|L30.12|
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609   
;;;1610     if (NewState != DISABLE)
;;;1611     {
;;;1612       /* Enable the selected ADC injected discontinuous mode */
;;;1613       ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
000002  6842              LDR      r2,[r0,#4]
000004  f4425280          ORR      r2,r2,#0x1000
000008  6042              STR      r2,[r0,#4]
00000a  e003              B        |L30.20|
                  |L30.12|
;;;1614     }
;;;1615     else
;;;1616     {
;;;1617       /* Disable the selected ADC injected discontinuous mode */
;;;1618       ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
00000c  6842              LDR      r2,[r0,#4]
00000e  f4225280          BIC      r2,r2,#0x1000
000012  6042              STR      r2,[r0,#4]
                  |L30.20|
;;;1619     }
;;;1620   }
000014  4770              BX       lr
;;;1621   
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;1409     */
;;;1410   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  b510              PUSH     {r4,lr}
;;;1411   {
000002  460a              MOV      r2,r1
;;;1412     uint32_t tmpreg1 = 0;
000004  2100              MOVS     r1,#0
;;;1413     uint32_t tmpreg2 = 0;
000006  2300              MOVS     r3,#0
;;;1414   
;;;1415     /* Check the parameters */
;;;1416     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1417     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1418     
;;;1419     /* Get the old register value */
;;;1420     tmpreg1 = ADCx->JSQR;
000008  6c41              LDR      r1,[r0,#0x44]
;;;1421     /* Clear the old injected sequence length JL bits */
;;;1422     tmpreg1 &= JSQR_JL_RESET;
00000a  f4211140          BIC      r1,r1,#0x300000
;;;1423     /* Set the injected sequence length JL bits */
;;;1424     tmpreg2 = Length - 1; 
00000e  1e53              SUBS     r3,r2,#1
;;;1425     tmpreg1 |= tmpreg2 << 20;
000010  ea415103          ORR      r1,r1,r3,LSL #20
;;;1426     /* Store the new register value */
;;;1427     ADCx->JSQR = tmpreg1;
000014  6441              STR      r1,[r0,#0x44]
;;;1428   }
000016  bd10              POP      {r4,pc}
;;;1429   
                          ENDP


                          AREA ||i.ADC_PowerDownCmd||, CODE, READONLY, ALIGN=1

                  ADC_PowerDownCmd PROC
;;;447      */
;;;448    void ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState)
000000  b11a              CBZ      r2,|L32.10|
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;452      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;453      assert_param(IS_ADC_POWER_DOWN(ADC_PowerDown));
;;;454      
;;;455      if (NewState != DISABLE)
;;;456      {
;;;457        /* Enable the ADC power-down during Delay and/or Idle phase */
;;;458        ADCx->CR1 |= ADC_PowerDown;
000002  6843              LDR      r3,[r0,#4]
000004  430b              ORRS     r3,r3,r1
000006  6043              STR      r3,[r0,#4]
000008  e002              B        |L32.16|
                  |L32.10|
;;;459      }
;;;460      else
;;;461      {
;;;462        /* Disable The ADC power-down during Delay and/or Idle phase */
;;;463        ADCx->CR1 &= (uint32_t)~ADC_PowerDown;
00000a  6843              LDR      r3,[r0,#4]
00000c  438b              BICS     r3,r3,r1
00000e  6043              STR      r3,[r0,#4]
                  |L32.16|
;;;464      }
;;;465    }
000010  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;821      */
;;;822    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b5f0              PUSH     {r4-r7,lr}
;;;823    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;824      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000006  2000              MOVS     r0,#0
000008  2100              MOVS     r1,#0
;;;825    
;;;826      /* Check the parameters */
;;;827      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;828      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;829      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;830      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;831    
;;;832      /* If ADC_Channel_30 or ADC_Channel_31 is selected */
;;;833      if (ADC_Channel > ADC_Channel_29)
00000a  2d1d              CMP      r5,#0x1d
00000c  dd11              BLE      |L33.50|
;;;834      {
;;;835        /* Get the old register value */
;;;836        tmpreg1 = ADCx->SMPR0;
00000e  6de0              LDR      r0,[r4,#0x5c]
;;;837        /* Calculate the mask to clear */
;;;838        tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
000010  f1a5061e          SUB      r6,r5,#0x1e
000014  eb060746          ADD      r7,r6,r6,LSL #1
000018  2607              MOVS     r6,#7
00001a  fa06f107          LSL      r1,r6,r7
;;;839        /* Clear the old sample time */
;;;840        tmpreg1 &= ~tmpreg2;
00001e  4388              BICS     r0,r0,r1
;;;841        /* Calculate the mask to set */
;;;842        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
000020  f1a5061e          SUB      r6,r5,#0x1e
000024  eb060646          ADD      r6,r6,r6,LSL #1
000028  fa03f106          LSL      r1,r3,r6
;;;843        /* Set the new sample time */
;;;844        tmpreg1 |= tmpreg2;
00002c  4308              ORRS     r0,r0,r1
;;;845        /* Store the new register value */
;;;846        ADCx->SMPR0 = tmpreg1;
00002e  65e0              STR      r0,[r4,#0x5c]
000030  e034              B        |L33.156|
                  |L33.50|
;;;847      }
;;;848      /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
;;;849      else if (ADC_Channel > ADC_Channel_19)
000032  2d13              CMP      r5,#0x13
000034  dd11              BLE      |L33.90|
;;;850      {
;;;851        /* Get the old register value */
;;;852        tmpreg1 = ADCx->SMPR1;
000036  68e0              LDR      r0,[r4,#0xc]
;;;853        /* Calculate the mask to clear */
;;;854        tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
000038  f1a50614          SUB      r6,r5,#0x14
00003c  eb060746          ADD      r7,r6,r6,LSL #1
000040  2607              MOVS     r6,#7
000042  fa06f107          LSL      r1,r6,r7
;;;855        /* Clear the old sample time */
;;;856        tmpreg1 &= ~tmpreg2;
000046  4388              BICS     r0,r0,r1
;;;857        /* Calculate the mask to set */
;;;858        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
000048  f1a50614          SUB      r6,r5,#0x14
00004c  eb060646          ADD      r6,r6,r6,LSL #1
000050  fa03f106          LSL      r1,r3,r6
;;;859        /* Set the new sample time */
;;;860        tmpreg1 |= tmpreg2;
000054  4308              ORRS     r0,r0,r1
;;;861        /* Store the new register value */
;;;862        ADCx->SMPR1 = tmpreg1;
000056  60e0              STR      r0,[r4,#0xc]
000058  e020              B        |L33.156|
                  |L33.90|
;;;863      }
;;;864      /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
;;;865      else if (ADC_Channel > ADC_Channel_9)
00005a  2d09              CMP      r5,#9
00005c  dd11              BLE      |L33.130|
;;;866      {
;;;867        /* Get the old register value */
;;;868        tmpreg1 = ADCx->SMPR2;
00005e  6920              LDR      r0,[r4,#0x10]
;;;869        /* Calculate the mask to clear */
;;;870        tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
000060  f1a5060a          SUB      r6,r5,#0xa
000064  eb060746          ADD      r7,r6,r6,LSL #1
000068  2607              MOVS     r6,#7
00006a  fa06f107          LSL      r1,r6,r7
;;;871        /* Clear the old sample time */
;;;872        tmpreg1 &= ~tmpreg2;
00006e  4388              BICS     r0,r0,r1
;;;873        /* Calculate the mask to set */
;;;874        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000070  f1a5060a          SUB      r6,r5,#0xa
000074  eb060646          ADD      r6,r6,r6,LSL #1
000078  fa03f106          LSL      r1,r3,r6
;;;875        /* Set the new sample time */
;;;876        tmpreg1 |= tmpreg2;
00007c  4308              ORRS     r0,r0,r1
;;;877        /* Store the new register value */
;;;878        ADCx->SMPR2 = tmpreg1;
00007e  6120              STR      r0,[r4,#0x10]
000080  e00c              B        |L33.156|
                  |L33.130|
;;;879      }
;;;880      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;881      {
;;;882        /* Get the old register value */
;;;883        tmpreg1 = ADCx->SMPR3;
000082  6960              LDR      r0,[r4,#0x14]
;;;884        /* Calculate the mask to clear */
;;;885        tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
000084  eb050745          ADD      r7,r5,r5,LSL #1
000088  2607              MOVS     r6,#7
00008a  fa06f107          LSL      r1,r6,r7
;;;886        /* Clear the old sample time */
;;;887        tmpreg1 &= ~tmpreg2;
00008e  4388              BICS     r0,r0,r1
;;;888        /* Calculate the mask to set */
;;;889        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000090  eb050645          ADD      r6,r5,r5,LSL #1
000094  fa03f106          LSL      r1,r3,r6
;;;890        /* Set the new sample time */
;;;891        tmpreg1 |= tmpreg2;
000098  4308              ORRS     r0,r0,r1
;;;892        /* Store the new register value */
;;;893        ADCx->SMPR3 = tmpreg1;
00009a  6160              STR      r0,[r4,#0x14]
                  |L33.156|
;;;894      }
;;;895      /* For Rank 1 to 6 */
;;;896      if (Rank < 7)
00009c  2a07              CMP      r2,#7
00009e  da0f              BGE      |L33.192|
;;;897      {
;;;898        /* Get the old register value */
;;;899        tmpreg1 = ADCx->SQR5;
0000a0  6c20              LDR      r0,[r4,#0x40]
;;;900        /* Calculate the mask to clear */
;;;901        tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
0000a2  1e56              SUBS     r6,r2,#1
0000a4  eb060786          ADD      r7,r6,r6,LSL #2
0000a8  261f              MOVS     r6,#0x1f
0000aa  fa06f107          LSL      r1,r6,r7
;;;902        /* Clear the old SQx bits for the selected rank */
;;;903        tmpreg1 &= ~tmpreg2;
0000ae  4388              BICS     r0,r0,r1
;;;904        /* Calculate the mask to set */
;;;905        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
0000b0  1e56              SUBS     r6,r2,#1
0000b2  eb060686          ADD      r6,r6,r6,LSL #2
0000b6  fa05f106          LSL      r1,r5,r6
;;;906        /* Set the SQx bits for the selected rank */
;;;907        tmpreg1 |= tmpreg2;
0000ba  4308              ORRS     r0,r0,r1
;;;908        /* Store the new register value */
;;;909        ADCx->SQR5 = tmpreg1;
0000bc  6420              STR      r0,[r4,#0x40]
0000be  e04a              B        |L33.342|
                  |L33.192|
;;;910      }
;;;911      /* For Rank 7 to 12 */
;;;912      else if (Rank < 13)
0000c0  2a0d              CMP      r2,#0xd
0000c2  da0f              BGE      |L33.228|
;;;913      {
;;;914        /* Get the old register value */
;;;915        tmpreg1 = ADCx->SQR4;
0000c4  6be0              LDR      r0,[r4,#0x3c]
;;;916        /* Calculate the mask to clear */
;;;917        tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
0000c6  1fd6              SUBS     r6,r2,#7
0000c8  eb060786          ADD      r7,r6,r6,LSL #2
0000cc  261f              MOVS     r6,#0x1f
0000ce  fa06f107          LSL      r1,r6,r7
;;;918        /* Clear the old SQx bits for the selected rank */
;;;919        tmpreg1 &= ~tmpreg2;
0000d2  4388              BICS     r0,r0,r1
;;;920        /* Calculate the mask to set */
;;;921        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
0000d4  1fd6              SUBS     r6,r2,#7
0000d6  eb060686          ADD      r6,r6,r6,LSL #2
0000da  fa05f106          LSL      r1,r5,r6
;;;922        /* Set the SQx bits for the selected rank */
;;;923        tmpreg1 |= tmpreg2;
0000de  4308              ORRS     r0,r0,r1
;;;924        /* Store the new register value */
;;;925        ADCx->SQR4 = tmpreg1;
0000e0  63e0              STR      r0,[r4,#0x3c]
0000e2  e038              B        |L33.342|
                  |L33.228|
;;;926      }  
;;;927      /* For Rank 13 to 18 */
;;;928      else if (Rank < 19)
0000e4  2a13              CMP      r2,#0x13
0000e6  da11              BGE      |L33.268|
;;;929      {
;;;930        /* Get the old register value */
;;;931        tmpreg1 = ADCx->SQR3;
0000e8  6ba0              LDR      r0,[r4,#0x38]
;;;932        /* Calculate the mask to clear */
;;;933        tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
0000ea  f1a2060d          SUB      r6,r2,#0xd
0000ee  eb060786          ADD      r7,r6,r6,LSL #2
0000f2  261f              MOVS     r6,#0x1f
0000f4  fa06f107          LSL      r1,r6,r7
;;;934        /* Clear the old SQx bits for the selected rank */
;;;935        tmpreg1 &= ~tmpreg2;
0000f8  4388              BICS     r0,r0,r1
;;;936        /* Calculate the mask to set */
;;;937        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
0000fa  f1a2060d          SUB      r6,r2,#0xd
0000fe  eb060686          ADD      r6,r6,r6,LSL #2
000102  fa05f106          LSL      r1,r5,r6
;;;938        /* Set the SQx bits for the selected rank */
;;;939        tmpreg1 |= tmpreg2;
000106  4308              ORRS     r0,r0,r1
;;;940        /* Store the new register value */
;;;941        ADCx->SQR3 = tmpreg1;
000108  63a0              STR      r0,[r4,#0x38]
00010a  e024              B        |L33.342|
                  |L33.268|
;;;942      }
;;;943        
;;;944      /* For Rank 19 to 24 */
;;;945      else if (Rank < 25)
00010c  2a19              CMP      r2,#0x19
00010e  da11              BGE      |L33.308|
;;;946      {
;;;947        /* Get the old register value */
;;;948        tmpreg1 = ADCx->SQR2;
000110  6b60              LDR      r0,[r4,#0x34]
;;;949        /* Calculate the mask to clear */
;;;950        tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
000112  f1a20613          SUB      r6,r2,#0x13
000116  eb060786          ADD      r7,r6,r6,LSL #2
00011a  261f              MOVS     r6,#0x1f
00011c  fa06f107          LSL      r1,r6,r7
;;;951        /* Clear the old SQx bits for the selected rank */
;;;952        tmpreg1 &= ~tmpreg2;
000120  4388              BICS     r0,r0,r1
;;;953        /* Calculate the mask to set */
;;;954        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
000122  f1a20613          SUB      r6,r2,#0x13
000126  eb060686          ADD      r6,r6,r6,LSL #2
00012a  fa05f106          LSL      r1,r5,r6
;;;955        /* Set the SQx bits for the selected rank */
;;;956        tmpreg1 |= tmpreg2;
00012e  4308              ORRS     r0,r0,r1
;;;957        /* Store the new register value */
;;;958        ADCx->SQR2 = tmpreg1;
000130  6360              STR      r0,[r4,#0x34]
000132  e010              B        |L33.342|
                  |L33.308|
;;;959      }   
;;;960      
;;;961      /* For Rank 25 to 28 */
;;;962      else
;;;963      {
;;;964        /* Get the old register value */
;;;965        tmpreg1 = ADCx->SQR1;
000134  6b20              LDR      r0,[r4,#0x30]
;;;966        /* Calculate the mask to clear */
;;;967        tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
000136  f1a20619          SUB      r6,r2,#0x19
00013a  eb060786          ADD      r7,r6,r6,LSL #2
00013e  261f              MOVS     r6,#0x1f
000140  fa06f107          LSL      r1,r6,r7
;;;968        /* Clear the old SQx bits for the selected rank */
;;;969        tmpreg1 &= ~tmpreg2;
000144  4388              BICS     r0,r0,r1
;;;970        /* Calculate the mask to set */
;;;971        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
000146  f1a20619          SUB      r6,r2,#0x19
00014a  eb060686          ADD      r6,r6,r6,LSL #2
00014e  fa05f106          LSL      r1,r5,r6
;;;972        /* Set the SQx bits for the selected rank */
;;;973        tmpreg1 |= tmpreg2;
000152  4308              ORRS     r0,r0,r1
;;;974        /* Store the new register value */
;;;975        ADCx->SQR1 = tmpreg1;
000154  6320              STR      r0,[r4,#0x30]
                  |L33.342|
;;;976      }
;;;977    }
000156  bdf0              POP      {r4-r7,pc}
;;;978    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1442     */
;;;1443   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b508              PUSH     {r3,lr}
;;;1444   {
;;;1445     __IO uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
000004  9300              STR      r3,[sp,#0]
;;;1446     
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1449     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1450     assert_param(IS_ADC_OFFSET(Offset));  
;;;1451     
;;;1452     tmp = (uint32_t)ADCx;
000006  9000              STR      r0,[sp,#0]
;;;1453     tmp += ADC_InjectedChannel;
000008  9b00              LDR      r3,[sp,#0]
00000a  440b              ADD      r3,r3,r1
00000c  9300              STR      r3,[sp,#0]
;;;1454     
;;;1455     /* Set the selected injected channel data offset */
;;;1456     *(__IO uint32_t *) tmp = (uint32_t)Offset;
00000e  9b00              LDR      r3,[sp,#0]
000010  601a              STR      r2,[r3,#0]
;;;1457   }
000012  bd08              POP      {r3,pc}
;;;1458   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConv PROC
;;;983      */
;;;984    void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;985    {
;;;986      /* Check the parameters */
;;;987      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;988    
;;;989      /* Enable the selected ADC conversion for regular group */
;;;990      ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
000002  f0414180          ORR      r1,r1,#0x40000000
000006  6081              STR      r1,[r0,#8]
;;;991    }
000008  4770              BX       lr
;;;992    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConv PROC
;;;1533     */
;;;1534   void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;1535   {
;;;1536     /* Check the parameters */
;;;1537     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1538     /* Enable the selected ADC conversion for injected group */
;;;1539     ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
000002  f4410180          ORR      r1,r1,#0x400000
000006  6081              STR      r1,[r0,#8]
;;;1540   }
000008  4770              BX       lr
;;;1541   
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;282      */
;;;283    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
000000  2100              MOVS     r1,#0
;;;284    {
;;;285      /* Reset ADC init structure parameters values */
;;;286      /* Initialize the ADC_Resolution member */
;;;287      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
000002  6001              STR      r1,[r0,#0]
;;;288    
;;;289      /* Initialize the ADC_ScanConvMode member */
;;;290      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000004  7101              STRB     r1,[r0,#4]
;;;291    
;;;292      /* Initialize the ADC_ContinuousConvMode member */
;;;293      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;294    
;;;295      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;296      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
000008  6081              STR      r1,[r0,#8]
;;;297    
;;;298      /* Initialize the ADC_ExternalTrigConv member */
;;;299      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
00000a  f04f7140          MOV      r1,#0x3000000
00000e  60c1              STR      r1,[r0,#0xc]
;;;300    
;;;301      /* Initialize the ADC_DataAlign member */
;;;302      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
000010  2100              MOVS     r1,#0
000012  6101              STR      r1,[r0,#0x10]
;;;303    
;;;304      /* Initialize the ADC_NbrOfConversion member */
;;;305      ADC_InitStruct->ADC_NbrOfConversion = 1;
000014  2101              MOVS     r1,#1
000016  7501              STRB     r1,[r0,#0x14]
;;;306    }
000018  4770              BX       lr
;;;307    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;703      */
;;;704    void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
000000  b130              CBZ      r0,|L38.16|
;;;705    {
;;;706      /* Check the parameters */
;;;707      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;708    
;;;709      if (NewState != DISABLE)
;;;710      {
;;;711        /* Enable the temperature sensor and Vrefint channel*/
;;;712        ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
000002  4907              LDR      r1,|L38.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4410100          ORR      r1,r1,#0x800000
00000a  4a05              LDR      r2,|L38.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L38.28|
                  |L38.16|
;;;713      }
;;;714      else
;;;715      {
;;;716        /* Disable the temperature sensor and Vrefint channel*/
;;;717        ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
000010  4903              LDR      r1,|L38.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4210100          BIC      r1,r1,#0x800000
000018  4a01              LDR      r2,|L38.32|
00001a  6011              STR      r1,[r2,#0]
                  |L38.28|
;;;718      }
;;;719    }
00001c  4770              BX       lr
;;;720    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0x40012704

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_adc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32l1xx_adc_c_e11a2ea2____REV16|
#line 113 "..\\Libraries\\CMSIS\\CM3\\CoreSupport\\core_cmInstr.h"
|__asm___15_stm32l1xx_adc_c_e11a2ea2____REV16| PROC
#line 114

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32l1xx_adc_c_e11a2ea2____REVSH|
#line 131
|__asm___15_stm32l1xx_adc_c_e11a2ea2____REVSH| PROC
#line 132

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
