L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c"
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_adc.c
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file provides firmware functions to manage the following 
N  *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
N  *           + Initialization and Configuration
N  *           + Power saving
N  *           + Analog Watchdog configuration
N  *           + Temperature Sensor & Vrefint (Voltage Reference internal) management 
N  *           + Regular Channels Configuration
N  *           + Regular Channels DMA Configuration
N  *           + Injected channels Configuration
N  *           + Interrupts and flags management
N  *         
N  *  @verbatim
N================================================================================
N                      ##### How to use this driver #####
N================================================================================
N    [..]
N    (#) Configure the ADC Prescaler, conversion resolution and data alignment 
N        using the ADC_Init() function.
N    (#) Activate the ADC peripheral using ADC_Cmd() function.
N    
N    *** Regular channels group configuration ***
N    ============================================
N    [..]
N    (+) To configure the ADC regular channels group features, use 
N        ADC_Init() and ADC_RegularChannelConfig() functions.
N    (+) To activate the continuous mode, use the ADC_continuousModeCmd()
N        function.
N    (+) To configurate and activate the Discontinuous mode, use the 
N        ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
N    (+) To read the ADC converted values, use the ADC_GetConversionValue()
N        function.
N  
N    *** DMA for Regular channels group features configuration ***
N    =============================================================
N    [..]
N    (+) To enable the DMA mode for regular channels group, use the 
N               ADC_DMACmd() function.
N    (+) To enable the generation of DMA requests continuously at the end
N               of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
N               function.
N             
N    *** Injected channels group configuration ***
N    =============================================
N    [..]
N    (+) To configure the ADC Injected channels group features, use 
N        ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
N        functions.
N    (+) To activate the continuous mode, use the ADC_continuousModeCmd()
N        function.
N    (+) To activate the Injected Discontinuous mode, use the 
N        ADC_InjectedDiscModeCmd() function.
N    (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
N        function.
N    (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
N        function.
N
N  @endverbatim
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N  
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx_adc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_adc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the ADC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_ADC_H
N#define __STM32L1xx_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
L 1 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32L1xx High-density, Medium-density
N  *          and Medium-density Plus devices.
N  *
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32l1xx
N  * @{
N  */
N    
N#ifndef __STM32L1XX_H
N#define __STM32L1XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target STM32L device used in your 
N   application 
N  */
N
N#if !defined (STM32L1XX_MD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_HD)
X#if !0L && !0L && !0L
N
N/* #define STM32L1XX_MD  */   /*!< - Ultra Low Power Medium-density devices: STM32L151x6xx, STM32L151x8xx,
N                                     STM32L151xBxx, STM32L152x6xx, STM32L152x8xx and STM32L152xBxx. 
N                                   - Ultra Low Power Medium-density Value Line devices: STM32L100x6xx,
N                                     STM32L100x8xx and STM32L100xBxx.  */
N
N/* #define STM32L1XX_MDP */   /*!< - Ultra Low Power Medium-density Plus devices: STM32L151xCxx, STM32L152xCxx and STM32L162xCxx 
N                                   - Ultra Low Power Medium-density Plus Value Line devices: STM32L100xCxx  */
N
N#define STM32L1XX_HD     /*!< Ultra Low Power High-density devices: STM32L151xDxx, STM32L152xDxx and STM32L162xDxx */
N#endif
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N#if !defined (STM32L1XX_MD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_HD)
X#if !0L && !0L && !1L
S #error "Please select first the target STM32L1xx device used in your application (in stm32l1xx.h file)"
N#endif
N
N#if !defined  USE_STDPERIPH_DRIVER
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
N#endif
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */
N#if !defined  (HSE_VALUE)
X#if !0L
N#define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
N#endif
N
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
N#endif
N
N/**
N * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
N   Timeout value 
N   */
N#if !defined  (HSI_STARTUP_TIMEOUT)
X#if !0L
N#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSI start up */
N#endif
N
N#if !defined  (HSI_VALUE)
X#if !0L
N#define HSI_VALUE  ((uint32_t)16000000) /*!< Value of the Internal High Speed oscillator in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif
N
N#if !defined  (LSI_VALUE)
X#if !0L
N#define LSI_VALUE  ((uint32_t)37000)    /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif
N
N#if !defined  (LSE_VALUE)
X#if !0L
N#define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif
N
N/**
N * @brief STM32L1xx Standard Peripheral Library version number V1.2.0
N   */
N#define __STM32L1XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __STM32L1XX_STDPERIPH_VERSION_SUB1   (0x02) /*!< [23:16] sub1 version */
N#define __STM32L1XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __STM32L1XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32L1XX_STDPERIPH_VERSION       ( (__STM32L1XX_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__STM32L1XX_STDPERIPH_VERSION_RC))
X#define __STM32L1XX_STDPERIPH_VERSION       ( (__STM32L1XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32L1XX_STDPERIPH_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief STM32L1xx Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
N#define __CM3_REV                 0x200 /*!< Cortex-M3 Revision r2p0                      */
N#define __MPU_PRESENT             1     /*!< STM32L1 provides MPU                         */
N#define __NVIC_PRIO_BITS          4     /*!< STM32L1 uses 4 Bits for the Priority Levels  */
N#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
N 
N/*!< Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ******************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt                 */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                         */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                       */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                          */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                    */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                          */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                      */
N
N/******  STM32L specific Interrupt Numbers ***********************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                               */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt               */
N  TAMPER_STAMP_IRQn           = 2,      /*!< Tamper and Time Stamp through EXTI Line Interrupts      */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup Timer through EXTI Line Interrupt            */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                  */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                    */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                    */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                    */
N  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                    */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                    */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                    */
N  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                         */
N  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                         */
N  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                         */
N  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                         */
N  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                         */
N  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                         */
N  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                         */
N  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                   */
N  USB_HP_IRQn                 = 19,     /*!< USB High Priority Interrupt                             */
N  USB_LP_IRQn                 = 20,     /*!< USB Low Priority Interrupt                              */
N  DAC_IRQn                    = 21,     /*!< DAC Interrupt                                           */
N  COMP_IRQn                   = 22,     /*!< Comparator through EXTI Line Interrupt                  */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                           */
N  LCD_IRQn                    = 24,     /*!< LCD Interrupt                                           */
N  TIM9_IRQn                   = 25,     /*!< TIM9 global Interrupt                                   */
N  TIM10_IRQn                  = 26,     /*!< TIM10 global Interrupt                                  */
N  TIM11_IRQn                  = 27,     /*!< TIM11 global Interrupt                                  */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                   */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                   */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                   */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                    */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                    */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                    */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                    */
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                   */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                   */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                 */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                 */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                 */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                         */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm through EXTI Line Interrupt                   */
N  USB_FS_WKUP_IRQn            = 42,     /*!< USB FS WakeUp from suspend through EXTI Line Interrupt  */
N  TIM6_IRQn                   = 43,     /*!< TIM6 global Interrupt                                   */
N#ifdef STM32L1XX_MD
S  TIM7_IRQn                   = 44      /*!< TIM7 global Interrupt                                   */
N#endif /* STM32L1XX_MD */
N
N#ifdef STM32L1XX_MDP
S  TIM7_IRQn                   = 44,     /*!< TIM7 global Interrupt                                   */
S  TIM5_IRQn                   = 46,     /*!< TIM5 global Interrupt                                   */
S  SPI3_IRQn                   = 47,     /*!< SPI3 global Interrupt                                   */
S  DMA2_Channel1_IRQn          = 50,     /*!< DMA2 Channel 1 global Interrupt                         */
S  DMA2_Channel2_IRQn          = 51,     /*!< DMA2 Channel 2 global Interrupt                         */
S  DMA2_Channel3_IRQn          = 52,     /*!< DMA2 Channel 3 global Interrupt                         */
S  DMA2_Channel4_IRQn          = 53,     /*!< DMA2 Channel 4 global Interrupt                         */
S  DMA2_Channel5_IRQn          = 54,     /*!< DMA2 Channel 5 global Interrupt                         */
S  AES_IRQn                    = 55,     /*!< AES global Interrupt                                    */
S  COMP_ACQ_IRQn               = 56      /*!< Comparator Channel Acquisition global Interrupt         */
N#endif /* STM32L1XX_MDP */
N
N#ifdef STM32L1XX_HD
N  TIM7_IRQn                   = 44,     /*!< TIM7 global Interrupt                                   */
N  SDIO_IRQn                   = 45,     /*!< SDIO global Interrupt                                   */
N  TIM5_IRQn                   = 46,     /*!< TIM5 global Interrupt                                   */
N  SPI3_IRQn                   = 47,     /*!< SPI3 global Interrupt                                   */
N  UART4_IRQn                  = 48,     /*!< UART4 global Interrupt                                  */
N  UART5_IRQn                  = 49,     /*!< UART5 global Interrupt                                  */
N  DMA2_Channel1_IRQn          = 50,     /*!< DMA2 Channel 1 global Interrupt                         */
N  DMA2_Channel2_IRQn          = 51,     /*!< DMA2 Channel 2 global Interrupt                         */
N  DMA2_Channel3_IRQn          = 52,     /*!< DMA2 Channel 3 global Interrupt                         */
N  DMA2_Channel4_IRQn          = 53,     /*!< DMA2 Channel 4 global Interrupt                         */
N  DMA2_Channel5_IRQn          = 54,     /*!< DMA2 Channel 5 global Interrupt                         */
N  AES_IRQn                    = 55,     /*!< AES global Interrupt                                    */
N  COMP_ACQ_IRQn               = 56      /*!< Comparator Channel Acquisition global Interrupt         */
N#endif /* STM32L1XX_HD */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm3.h"
L 1 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     22. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "E:\Soft\keil472a\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 121 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\core_cm3.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\Libraries\CMSIS\CM3\CoreSupport\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V2.02
N * @date     01. June. 2011
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H__
N#define __CORE_CMINSTR_H__
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  @ingroup CMSIS
N  Access to dedicated instructions
N  @{
N*/
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
Sextern uint32_t __REV16(uint32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM uint32_t __REV16(uint32_t value)
Xstatic __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
Sextern int32_t __REVSH(int32_t value);
N#else  /* (__ARMCC_VERSION >= 400677)  */
Nstatic __INLINE __ASM int32_t __REVSH(int32_t value)
Xstatic __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif /* __ARMCC_VERSION  */
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#if (__ARMCC_VERSION < 400000)
X#if (5030076 < 400000)
Sextern void __CLREX(void);
N#else  /* (__ARMCC_VERSION >= 400000)  */
N#define __CLREX                           __clrex
N#endif /* __ARMCC_VERSION  */
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#include <intrinsics.h>                     /* IAR Intrinsics   */
S
S#pragma diag_suppress=Pe940
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S#define __NOP                           __no_operation
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFI(void)
S{
S  __ASM ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
Sstatic __INLINE  void __WFE(void)
S{
S  __ASM ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
Sstatic __INLINE  void __SEV(void)
S{
S  __ASM ("sev");
S}
S
S
S/* intrinsic     void __ISB(void)            (see intrinsics.h) */
S/* intrinsic     void __DSB(void)            (see intrinsics.h) */
S/* intrinsic     void __DMB(void)            (see intrinsics.h) */
S/* intrinsic uint32_t __REV(uint32_t value)  (see intrinsics.h) */
S/* intrinsic          __SSAT                 (see intrinsics.h) */
S/* intrinsic          __USAT                 (see intrinsics.h) */
S
S#if (__VER__) < 6020000
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __REV16(uint32_t value)
S{
S  __ASM("rev16 r0, r0");
S}
S#endif
S
S
S/* intrinsic uint32_t __REVSH(uint32_t value)  (see intrinsics.h */
S
S
S#if       (__CORTEX_M >= 0x03)
S
S#if (__VER__) < 6020000
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
Sstatic uint32_t __RBIT(uint32_t value)
S{
S  __ASM("rbit r0, r0");
S}
S#endif
S
S
S#if (__VER__) < 6020000
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
Sstatic uint8_t __LDREXB(volatile uint8_t *addr)
S{
S  __ASM("ldrexb r0, [r0]");
S}
S#endif
S
S#if (__VER__) < 6020000
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
Sstatic uint16_t __LDREXH(volatile uint16_t *addr)
S{
S  __ASM("ldrexh r0, [r0]");
S}
S#endif
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S/* intrinsic unsigned long __LDREX(unsigned long *)  (see intrinsics.h) */
Sstatic uint32_t __LDREXW(volatile uint32_t *addr)
S{
S  __ASM("ldrex r0, [r0]");
S}
S
S
S#if (__VER__) < 6020000
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S  __ASM("strexb r0, r0, [r1]");
S}
S#endif
S
S
S#if (__VER__) < 6020000
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
Sstatic uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S  __ASM("strexh r0, r0, [r1]");
S}
S#endif
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long)  (see intrinsics.h )*/
Sstatic uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S  __ASM("strex r0, r0, [r1]");
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
Sstatic __INLINE void __CLREX(void)
S{
S  __ASM ("clrex");
S}
S
S/* intrinsic   unsigned char __CLZ( unsigned long )      (see intrinsics.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S#pragma diag_default=Pe940
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H__ */
L 122 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\Libraries\CMSIS\CM3\CoreSupport\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V2.01
N * @date     06. December 2010
N *
N * @note
N * Copyright (C) 2009-2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H__
N#define __CORE_CMFUNC_H__
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if defined ( __CC_ARM   ) /*------------------ RealView Compiler ----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_CONTROL(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_CONTROL(uint32_t control);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get ISPR Register
N
N    This function returns the content of the ISPR Register.
N
N    \return               ISPR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_IPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_APSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_xPSR(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_PSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_PSP(uint32_t topOfProcStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_MSP(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_MSP(uint32_t topOfMainStack);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_PRIMASK(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_PRIMASK(uint32_t priMask);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x03) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_BASEPRI(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_BASEPRI(uint32_t basePri);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          uint32_t __get_FAULTMASK(void);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N#endif /*  __ARMCC_VERSION  */
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N#if       (__ARMCC_VERSION <  400000)
X#if       (5030076 <  400000)
Sextern          void __set_FAULTMASK(uint32_t faultMask);
N#else  /* (__ARMCC_VERSION >= 400000) */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N#endif /*  __ARMCC_VERSION  */
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x03) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N #elif (defined (__ICCARM__)) /*---------------- ICC Compiler ---------------------*/
S/* IAR iccarm specific functions */
S
S#if defined (__ICCARM__)
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
S#endif
S
S#pragma diag_suppress=Pe940
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __enable_irq                              __enable_interrupt
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S#define __disable_irq                             __disable_interrupt
S
S
S/* intrinsic unsigned long __get_CONTROL( void ); (see intrinsic.h) */
S/* intrinsic void __set_CONTROL( unsigned long ); (see intrinsic.h) */
S
S
S#if (__VER__) < 6020000
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
Sstatic uint32_t __get_IPSR(void)
S{
S  __ASM("mrs r0, ipsr");
S}
S#endif
S
S#if (__VER__) < 6020000
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
Sstatic uint32_t __get_APSR(void)
S{
S  __ASM("mrs r0, apsr");
S}
S#endif
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
Sstatic uint32_t __get_xPSR(void)
S{
S  __ASM("mrs r0, psr");           // assembler does not know "xpsr"
S}
S
S
S#if (__VER__) < 6020000
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
Sstatic uint32_t __get_PSP(void)
S{
S  __ASM("mrs r0, psp");
S}
S#endif
S
S
S#if (__VER__) < 6020000
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
Sstatic void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM("msr psp, r0");
S}
S#endif
S
S
S#if (__VER__) < 6020000
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
Sstatic uint32_t __get_MSP(void)
S{
S  __ASM("mrs r0, msp");
S}
S#endif
S
S#if (__VER__) < 6020000
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
Sstatic void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM("msr msp, r0");
S}
S#endif
S
S/* intrinsic unsigned long __get_PRIMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_PRIMASK( unsigned long ); (see intrinsic.h) */
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __enable_fault_irq(void)
S{
S  __ASM ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
Sstatic __INLINE void __disable_fault_irq(void)
S{
S  __ASM ("cpsid f");
S}
S
S
S/* intrinsic unsigned long __get_BASEPRI( void );   (see intrinsic.h) */
S/* intrinsic void __set_BASEPRI( unsigned long );   (see intrinsic.h) */
S/* intrinsic unsigned long __get_FAULTMASK( void ); (see intrinsic.h) */
S/* intrinsic void __set_FAULTMASK(unsigned long);   (see intrinsic.h) */
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
Sstatic uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmrs r0, fpscr");
S#else
S  return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
Sstatic void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM("vmsr fpscr, r0");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S#pragma diag_default=Pe940
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get ISPR Register
S
S    This function returns the content of the ISPR Register.
S
S    \return               ISPR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) static __INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1)
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) static __INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1)
S  __ASM volatile ("MSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif (defined (__TASKING__)) /*--------------- TASKING Compiler -----------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H__ */
L 123 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\core_cm3.h" 2
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x03) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
X#if (0x200 < 0x0201)                    
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((1L) && (0x200 >= 0x200))
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
X  volatile uint32_t ACTLR;                    
N#else
S       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];                                  
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];                                  
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];                                   
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 267 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx.h" 2
N#include "system_stm32l1xx.h"
L 1 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\system_stm32l1xx.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32l1xx.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    31-December-2010
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.
N  ******************************************************************************  
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
N  ******************************************************************************  
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32l1xx_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32L1XX_H
N#define __SYSTEM_STM32L1XX_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32L1xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32L1xx_System_Exported_types
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L1xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L1xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32L1xx_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32L1XX_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
L 268 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/** 
N  * @brief  __RAM_FUNC definition
N  */ 
N#if defined ( __CC_ARM   )
X#if 1L
N/* ARM Compiler
N   ------------
N   RAM functions are defined using the toolchain options. 
N   Functions that are executed in RAM should reside in a separate source module.
N   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
N   area of a module to a memory space in physical RAM.
N   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
N   dialog. 
N*/
N #define __RAM_FUNC FLASH_Status 
N
N#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
S*/
S #define __RAM_FUNC __ramfunc FLASH_Status
S
S#elif defined   (  __GNUC__  )
S/* GNU Compiler
S   ------------
S   RAM functions are defined using a specific toolchain attribute 
S   "__attribute__((section(".data")))". 
S*/
S #define __RAM_FUNC FLASH_Status __attribute__((section(".data")))
S
S#elif defined   (  __TASKING__  )
S/* TASKING Compiler
S   ----------------
S   RAM functions are defined using a specific toolchain pragma. This pragma is 
S   defined in the stm32l1xx_flash_ramfunc.c 
S*/
S #define __RAM_FUNC  FLASH_Status
S
N#endif
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;           /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;            
N  __IO uint32_t CR1;          /*!< ADC control register 1,                      Address offset: 0x04 */
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;          /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;           
N  __IO uint32_t SMPR1;        /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;         
N  __IO uint32_t SMPR2;        /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;         
N  __IO uint32_t SMPR3;        /*!< ADC sample time register 3,                  Address offset: 0x14 */
X  volatile uint32_t SMPR3;         
N  __IO uint32_t JOFR1;        /*!< ADC injected channel data offset register 1, Address offset: 0x18 */
X  volatile uint32_t JOFR1;         
N  __IO uint32_t JOFR2;        /*!< ADC injected channel data offset register 2, Address offset: 0x1C */
X  volatile uint32_t JOFR2;         
N  __IO uint32_t JOFR3;        /*!< ADC injected channel data offset register 3, Address offset: 0x20 */
X  volatile uint32_t JOFR3;         
N  __IO uint32_t JOFR4;        /*!< ADC injected channel data offset register 4, Address offset: 0x24 */
X  volatile uint32_t JOFR4;         
N  __IO uint32_t HTR;          /*!< ADC watchdog higher threshold register,      Address offset: 0x28 */
X  volatile uint32_t HTR;           
N  __IO uint32_t LTR;          /*!< ADC watchdog lower threshold register,       Address offset: 0x2C */
X  volatile uint32_t LTR;           
N  __IO uint32_t SQR1;         /*!< ADC regular sequence register 1,             Address offset: 0x30 */
X  volatile uint32_t SQR1;          
N  __IO uint32_t SQR2;         /*!< ADC regular sequence register 2,             Address offset: 0x34 */
X  volatile uint32_t SQR2;          
N  __IO uint32_t SQR3;         /*!< ADC regular sequence register 3,             Address offset: 0x38 */
X  volatile uint32_t SQR3;          
N  __IO uint32_t SQR4;         /*!< ADC regular sequence register 4,             Address offset: 0x3C */
X  volatile uint32_t SQR4;          
N  __IO uint32_t SQR5;         /*!< ADC regular sequence register 5,             Address offset: 0x40 */
X  volatile uint32_t SQR5;          
N  __IO uint32_t JSQR;         /*!< ADC injected sequence register,              Address offset: 0x44 */
X  volatile uint32_t JSQR;          
N  __IO uint32_t JDR1;         /*!< ADC injected data register 1,                Address offset: 0x48 */
X  volatile uint32_t JDR1;          
N  __IO uint32_t JDR2;         /*!< ADC injected data register 2,                Address offset: 0x4C */
X  volatile uint32_t JDR2;          
N  __IO uint32_t JDR3;         /*!< ADC injected data register 3,                Address offset: 0x50 */
X  volatile uint32_t JDR3;          
N  __IO uint32_t JDR4;         /*!< ADC injected data register 4,                Address offset: 0x54 */
X  volatile uint32_t JDR4;          
N  __IO uint32_t DR;           /*!< ADC regular data register,                   Address offset: 0x58 */
X  volatile uint32_t DR;            
N  __IO uint32_t SMPR0;        /*!< ADC sample time register 0,                  Address offset: 0x5C */
X  volatile uint32_t SMPR0;         
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CSR;          /*!< ADC common status register,                  Address offset: ADC1 base address + 0x300 */
X  volatile uint32_t CSR;           
N  __IO uint32_t CCR;          /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
X  volatile uint32_t CCR;           
N} ADC_Common_TypeDef;
N
N
N/** 
N  * @brief AES hardware accelerator
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< AES control register,                        Address offset: 0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t SR;           /*!< AES status register,                         Address offset: 0x04 */
X  volatile uint32_t SR;            
N  __IO uint32_t DINR;         /*!< AES data input register,                     Address offset: 0x08 */
X  volatile uint32_t DINR;          
N  __IO uint32_t DOUTR;        /*!< AES data output register,                    Address offset: 0x0C */
X  volatile uint32_t DOUTR;         
N  __IO uint32_t KEYR0;        /*!< AES key register 0,                          Address offset: 0x10 */
X  volatile uint32_t KEYR0;         
N  __IO uint32_t KEYR1;        /*!< AES key register 1,                          Address offset: 0x14 */
X  volatile uint32_t KEYR1;         
N  __IO uint32_t KEYR2;        /*!< AES key register 2,                          Address offset: 0x18 */
X  volatile uint32_t KEYR2;         
N  __IO uint32_t KEYR3;        /*!< AES key register 3,                          Address offset: 0x1C */
X  volatile uint32_t KEYR3;         
N  __IO uint32_t IVR0;         /*!< AES initialization vector register 0,        Address offset: 0x20 */
X  volatile uint32_t IVR0;          
N  __IO uint32_t IVR1;         /*!< AES initialization vector register 1,        Address offset: 0x24 */
X  volatile uint32_t IVR1;          
N  __IO uint32_t IVR2;         /*!< AES initialization vector register 2,        Address offset: 0x28 */
X  volatile uint32_t IVR2;          
N  __IO uint32_t IVR3;         /*!< AES initialization vector register 3,        Address offset: 0x2C */
X  volatile uint32_t IVR3;          
N} AES_TypeDef;
N
N/** 
N  * @brief Comparator 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;          /*!< COMP comparator control and status register, Address offset: 0x00 */
X  volatile uint32_t CSR;           
N} COMP_TypeDef;
N
N/** 
N  * @brief CRC calculation unit
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;           /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;            
N  __IO uint8_t  IDR;          /*!< CRC Independent data register,               Address offset: 0x04 */
X  volatile uint8_t  IDR;           
N  uint8_t   RESERVED0;        /*!< Reserved,                                    0x05                 */
N  uint16_t  RESERVED1;        /*!< Reserved,                                    0x06                 */
N  __IO uint32_t CR;           /*!< CRC Control register,                        Address offset: 0x08 */ 
X  volatile uint32_t CR;             
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< DAC control register,                                     Address offset: 0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t SWTRIGR;      /*!< DAC software trigger register,                            Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;       
N  __IO uint32_t DHR12R1;      /*!< DAC channel1 12-bit right-aligned data holding register,  Address offset: 0x08 */
X  volatile uint32_t DHR12R1;       
N  __IO uint32_t DHR12L1;      /*!< DAC channel1 12-bit left aligned data holding register,   Address offset: 0x0C */
X  volatile uint32_t DHR12L1;       
N  __IO uint32_t DHR8R1;       /*!< DAC channel1 8-bit right aligned data holding register,   Address offset: 0x10 */
X  volatile uint32_t DHR8R1;        
N  __IO uint32_t DHR12R2;      /*!< DAC channel2 12-bit right aligned data holding register,  Address offset: 0x14 */
X  volatile uint32_t DHR12R2;       
N  __IO uint32_t DHR12L2;      /*!< DAC channel2 12-bit left aligned data holding register,   Address offset: 0x18 */
X  volatile uint32_t DHR12L2;       
N  __IO uint32_t DHR8R2;       /*!< DAC channel2 8-bit right-aligned data holding register,   Address offset: 0x1C */
X  volatile uint32_t DHR8R2;        
N  __IO uint32_t DHR12RD;      /*!< Dual DAC 12-bit right-aligned data holding register,      Address offset: 0x20 */
X  volatile uint32_t DHR12RD;       
N  __IO uint32_t DHR12LD;      /*!< DUAL DAC 12-bit left aligned data holding register,       Address offset: 0x24 */
X  volatile uint32_t DHR12LD;       
N  __IO uint32_t DHR8RD;       /*!< DUAL DAC 8-bit right aligned data holding register,       Address offset: 0x28 */
X  volatile uint32_t DHR8RD;        
N  __IO uint32_t DOR1;         /*!< DAC channel1 data output register,                        Address offset: 0x2C */
X  volatile uint32_t DOR1;          
N  __IO uint32_t DOR2;         /*!< DAC channel2 data output register,                        Address offset: 0x30 */
X  volatile uint32_t DOR2;          
N  __IO uint32_t SR;           /*!< DAC status register,                                      Address offset: 0x34 */
X  volatile uint32_t SR;            
N} DAC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
X  volatile uint32_t IDCODE;        
N  __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
X  volatile uint32_t CR;            
N  __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
X  volatile uint32_t APB1FZ;        
N  __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
X  volatile uint32_t APB2FZ;        
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< DMA channel x configuration register        */
X  volatile uint32_t CCR;           
N  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register       */
X  volatile uint32_t CNDTR;         
N  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register   */
X  volatile uint32_t CPAR;          
N  __IO uint32_t CMAR;         /*!< DMA channel x memory address register       */
X  volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< DMA interrupt status register,               Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,           Address offset: 0x04 */
X  volatile uint32_t IFCR;          
N} DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;          /*!< EXTI interrupt mask register,                 Address offset: 0x00 */
X  volatile uint32_t IMR;           
N  __IO uint32_t EMR;          /*!< EXTI event mask register,                     Address offset: 0x04 */
X  volatile uint32_t EMR;           
N  __IO uint32_t RTSR;         /*!< EXTI rising edge trigger selection register,  Address offset: 0x08 */
X  volatile uint32_t RTSR;          
N  __IO uint32_t FTSR;         /*!< EXTI Falling edge trigger selection register, Address offset: 0x0C */
X  volatile uint32_t FTSR;          
N  __IO uint32_t SWIER;        /*!< EXTI software interrupt event register,       Address offset: 0x10 */
X  volatile uint32_t SWIER;         
N  __IO uint32_t PR;           /*!< EXTI pending register,                        Address offset: 0x14 */
X  volatile uint32_t PR;            
N} EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;          /*!< Access control register,                     Address offset: 0x00 */
X  volatile uint32_t ACR;           
N  __IO uint32_t PECR;         /*!< Program/erase control register,              Address offset: 0x04 */
X  volatile uint32_t PECR;          
N  __IO uint32_t PDKEYR;       /*!< Power down key register,                     Address offset: 0x08 */
X  volatile uint32_t PDKEYR;        
N  __IO uint32_t PEKEYR;       /*!< Program/erase key register,                  Address offset: 0x0c */
X  volatile uint32_t PEKEYR;        
N  __IO uint32_t PRGKEYR;      /*!< Program memory key register,                 Address offset: 0x10 */
X  volatile uint32_t PRGKEYR;       
N  __IO uint32_t OPTKEYR;      /*!< Option byte key register,                    Address offset: 0x14 */
X  volatile uint32_t OPTKEYR;       
N  __IO uint32_t SR;           /*!< Status register,                             Address offset: 0x18 */
X  volatile uint32_t SR;            
N  __IO uint32_t OBR;          /*!< Option byte register,                        Address offset: 0x1c */
X  volatile uint32_t OBR;           
N  __IO uint32_t WRPR;         /*!< Write protection register,                   Address offset: 0x20 */
X  volatile uint32_t WRPR;          
N  uint32_t   RESERVED[23];    /*!< Reserved,                                    0x24                 */
N  __IO uint32_t WRPR1;        /*!< Write protection register 1,                 Address offset: 0x28 */
X  volatile uint32_t WRPR1;         
N  __IO uint32_t WRPR2;        /*!< Write protection register 2,                 Address offset: 0x2C */
X  volatile uint32_t WRPR2;         
N} FLASH_TypeDef;
N
N/** 
N  * @brief Option Bytes Registers
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t RDP;               /*!< Read protection register,               Address offset: 0x00 */
X  volatile uint32_t RDP;                
N  __IO uint32_t USER;              /*!< user register,                          Address offset: 0x04 */
X  volatile uint32_t USER;               
N  __IO uint32_t WRP01;             /*!< write protection register 0 1,          Address offset: 0x08 */
X  volatile uint32_t WRP01;              
N  __IO uint32_t WRP23;             /*!< write protection register 2 3,          Address offset: 0x0C */
X  volatile uint32_t WRP23;              
N  __IO uint32_t WRP45;             /*!< write protection register 4 5,          Address offset: 0x10 */
X  volatile uint32_t WRP45;              
N  __IO uint32_t WRP67;             /*!< write protection register 6 7,          Address offset: 0x14 */
X  volatile uint32_t WRP67;              
N  __IO uint32_t WRP89;             /*!< write protection register 8 9,          Address offset: 0x18 */
X  volatile uint32_t WRP89;              
N  __IO uint32_t WRP1011;           /*!< write protection register 10 11,        Address offset: 0x1C */
X  volatile uint32_t WRP1011;            
N} OB_TypeDef;
N
N/** 
N  * @brief Operational Amplifier (OPAMP)
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;          /*!< OPAMP control/status register,                     Address offset: 0x00 */
X  volatile uint32_t CSR;           
N  __IO uint32_t OTR;          /*!< OPAMP offset trimming register for normal mode,    Address offset: 0x04 */ 
X  volatile uint32_t OTR;            
N  __IO uint32_t LPOTR;        /*!< OPAMP offset trimming register for low power mode, Address offset: 0x08 */
X  volatile uint32_t LPOTR;         
N} OPAMP_TypeDef;
N
N/** 
N  * @brief Flexible Static Memory Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t BTCR[8];      /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */
X  volatile uint32_t BTCR[8];       
N} FSMC_Bank1_TypeDef; 
N
N/** 
N  * @brief Flexible Static Memory Controller Bank1E
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t BWTR[7];      /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
X  volatile uint32_t BWTR[7];       
N} FSMC_Bank1E_TypeDef;        
N
N/** 
N  * @brief General Purpose IO
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;        /*!< GPIO port mode register,                     Address offset: 0x00      */
X  volatile uint32_t MODER;         
N  __IO uint16_t OTYPER;       /*!< GPIO port output type register,              Address offset: 0x04      */
X  volatile uint16_t OTYPER;        
N  uint16_t RESERVED0;         /*!< Reserved,                                    0x06                      */
N  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,             Address offset: 0x08      */
X  volatile uint32_t OSPEEDR;       
N  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,        Address offset: 0x0C      */
X  volatile uint32_t PUPDR;         
N  __IO uint16_t IDR;          /*!< GPIO port input data register,               Address offset: 0x10      */
X  volatile uint16_t IDR;           
N  uint16_t RESERVED1;         /*!< Reserved,                                    0x12                      */
N  __IO uint16_t ODR;          /*!< GPIO port output data register,              Address offset: 0x14      */
X  volatile uint16_t ODR;           
N  uint16_t RESERVED2;         /*!< Reserved,                                    0x16                      */
N  __IO uint16_t BSRRL;        /*!< GPIO port bit set/reset low registerBSRR,    Address offset: 0x18      */
X  volatile uint16_t BSRRL;         
N  __IO uint16_t BSRRH;        /*!< GPIO port bit set/reset high registerBSRR,   Address offset: 0x1A      */
X  volatile uint16_t BSRRH;         
N  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,       Address offset: 0x1C      */
X  volatile uint32_t LCKR;          
N  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,        Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];        
N  __IO uint16_t BRR;          /*!< GPIO bit reset register,                     Address offset: 0x28      */
X  volatile uint16_t BRR;           
N  uint16_t RESERVED3;         /*!< Reserved,                                    0x2A                      */
N} GPIO_TypeDef;
N
N/** 
N  * @brief SysTem Configuration
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
X  volatile uint32_t MEMRMP;        
N  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
X  volatile uint32_t PMC;           
N  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
X  volatile uint32_t EXTICR[4];     
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;          /*!< I2C Control register 1,                      Address offset: 0x00 */
X  volatile uint16_t CR1;           
N  uint16_t  RESERVED0;        /*!< Reserved,                                    0x02                 */
N  __IO uint16_t CR2;          /*!< I2C Control register 2,                      Address offset: 0x04 */
X  volatile uint16_t CR2;           
N  uint16_t  RESERVED1;        /*!< Reserved,                                    0x06                 */
N  __IO uint16_t OAR1;         /*!< I2C Own address register 1,                  Address offset: 0x08 */
X  volatile uint16_t OAR1;          
N  uint16_t  RESERVED2;        /*!< Reserved,                                    0x0A                 */
N  __IO uint16_t OAR2;         /*!< I2C Own address register 2,                  Address offset: 0x0C */
X  volatile uint16_t OAR2;          
N  uint16_t  RESERVED3;        /*!< Reserved,                                    0x0E                 */
N  __IO uint16_t DR;           /*!< I2C Data register,                           Address offset: 0x10 */
X  volatile uint16_t DR;            
N  uint16_t  RESERVED4;        /*!< Reserved,                                    0x12                 */
N  __IO uint16_t SR1;          /*!< I2C Status register 1,                       Address offset: 0x14 */
X  volatile uint16_t SR1;           
N  uint16_t  RESERVED5;        /*!< Reserved,                                    0x16                 */
N  __IO uint16_t SR2;          /*!< I2C Status register 2,                       Address offset: 0x18 */
X  volatile uint16_t SR2;           
N  uint16_t  RESERVED6;        /*!< Reserved,                                    0x1A                 */
N  __IO uint16_t CCR;          /*!< I2C Clock control register,                  Address offset: 0x1C */
X  volatile uint16_t CCR;           
N  uint16_t  RESERVED7;        /*!< Reserved,                                    0x1E                 */
N  __IO uint16_t TRISE;        /*!< I2C TRISE register,                          Address offset: 0x20 */
X  volatile uint16_t TRISE;         
N  uint16_t  RESERVED8;        /*!< Reserved,                                    0x22                 */
N} I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;           /*!< Key register,                                Address offset: 0x00 */
X  volatile uint32_t KR;            
N  __IO uint32_t PR;           /*!< Prescaler register,                          Address offset: 0x04 */
X  volatile uint32_t PR;            
N  __IO uint32_t RLR;          /*!< Reload register,                             Address offset: 0x08 */
X  volatile uint32_t RLR;           
N  __IO uint32_t SR;           /*!< Status register,                             Address offset: 0x0C */
X  volatile uint32_t SR;            
N} IWDG_TypeDef;
N
N
N/** 
N  * @brief LCD
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;        /*!< LCD control register,              Address offset: 0x00 */
X  volatile uint32_t CR;         
N  __IO uint32_t FCR;       /*!< LCD frame control register,        Address offset: 0x04 */
X  volatile uint32_t FCR;        
N  __IO uint32_t SR;        /*!< LCD status register,               Address offset: 0x08 */
X  volatile uint32_t SR;         
N  __IO uint32_t CLR;       /*!< LCD clear register,                Address offset: 0x0C */
X  volatile uint32_t CLR;        
N  uint32_t RESERVED;       /*!< Reserved,                          Address offset: 0x10 */
N  __IO uint32_t RAM[16];   /*!< LCD display memory,           Address offset: 0x14-0x50 */
X  volatile uint32_t RAM[16];    
N} LCD_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< RCC clock control register,                                   Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t ICSCR;         /*!< RCC Internal clock sources calibration register,              Address offset: 0x04 */
X  volatile uint32_t ICSCR;          
N  __IO uint32_t CFGR;          /*!< RCC Clock configuration register,                             Address offset: 0x08 */
X  volatile uint32_t CFGR;           
N  __IO uint32_t CIR;           /*!< RCC Clock interrupt register,                                 Address offset: 0x0C */
X  volatile uint32_t CIR;            
N  __IO uint32_t AHBRSTR;       /*!< RCC AHB peripheral reset register,                            Address offset: 0x10 */
X  volatile uint32_t AHBRSTR;        
N  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                           Address offset: 0x14 */
X  volatile uint32_t APB2RSTR;       
N  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                           Address offset: 0x18 */
X  volatile uint32_t APB1RSTR;       
N  __IO uint32_t AHBENR;        /*!< RCC AHB peripheral clock enable register,                     Address offset: 0x1C */
X  volatile uint32_t AHBENR;         
N  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                    Address offset: 0x20 */
X  volatile uint32_t APB2ENR;        
N  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                    Address offset: 0x24 */
X  volatile uint32_t APB1ENR;        
N  __IO uint32_t AHBLPENR;      /*!< RCC AHB peripheral clock enable in low power mode register,   Address offset: 0x28 */
X  volatile uint32_t AHBLPENR;       
N  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register,  Address offset: 0x2C */
X  volatile uint32_t APB2LPENR;      
N  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register,  Address offset: 0x30 */
X  volatile uint32_t APB1LPENR;      
N  __IO uint32_t CSR;           /*!< RCC Control/status register,                                  Address offset: 0x34 */
X  volatile uint32_t CSR;            
N} RCC_TypeDef;
N
N/** 
N  * @brief Routing Interface 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ICR;       /*!< RI input capture register,             Address offset: 0x00 */
X  volatile uint32_t ICR;        
N  __IO uint32_t ASCR1;     /*!< RI analog switches control register,   Address offset: 0x04 */
X  volatile uint32_t ASCR1;      
N  __IO uint32_t ASCR2;     /*!< RI analog switch control register 2,   Address offset: 0x08 */
X  volatile uint32_t ASCR2;      
N  __IO uint32_t HYSCR1;     /*!< RI hysteresis control register,       Address offset: 0x0C */
X  volatile uint32_t HYSCR1;      
N  __IO uint32_t HYSCR2;     /*!< RI Hysteresis control register,       Address offset: 0x10 */
X  volatile uint32_t HYSCR2;      
N  __IO uint32_t HYSCR3;     /*!< RI Hysteresis control register,       Address offset: 0x14 */
X  volatile uint32_t HYSCR3;      
N  __IO uint32_t HYSCR4;     /*!< RI Hysteresis control register,       Address offset: 0x18 */
X  volatile uint32_t HYSCR4;      
N} RI_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
X  volatile uint32_t CR;                                                                                                      
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;        
N  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
X  volatile uint32_t WUTR;        
N  __IO uint32_t CALIBR;     /*!< RTC calibration register,                                  Address offset: 0x18 */
X  volatile uint32_t CALIBR;      
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N  __IO uint32_t ALRMBR;     /*!< RTC alarm B register,                                      Address offset: 0x20 */
X  volatile uint32_t ALRMBR;      
N  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RRTC calibration register,                                 Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
X  volatile uint32_t TAFCR;       
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N  __IO uint32_t ALRMBSSR;   /*!< RTC alarm B sub second register,                           Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR;    
N  uint32_t RESERVED7;       /*!< Reserved, 0x4C                                                                  */
N  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                     Address offset: 0x50 */
X  volatile uint32_t BKP0R;       
N  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                     Address offset: 0x54 */
X  volatile uint32_t BKP1R;       
N  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                     Address offset: 0x58 */
X  volatile uint32_t BKP2R;       
N  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                     Address offset: 0x5C */
X  volatile uint32_t BKP3R;       
N  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                     Address offset: 0x60 */
X  volatile uint32_t BKP4R;       
N  __IO uint32_t BKP5R;      /*!< RTC backup register 5,                                     Address offset: 0x64 */
X  volatile uint32_t BKP5R;       
N  __IO uint32_t BKP6R;      /*!< RTC backup register 6,                                     Address offset: 0x68 */
X  volatile uint32_t BKP6R;       
N  __IO uint32_t BKP7R;      /*!< RTC backup register 7,                                     Address offset: 0x6C */
X  volatile uint32_t BKP7R;       
N  __IO uint32_t BKP8R;      /*!< RTC backup register 8,                                     Address offset: 0x70 */
X  volatile uint32_t BKP8R;       
N  __IO uint32_t BKP9R;      /*!< RTC backup register 9,                                     Address offset: 0x74 */
X  volatile uint32_t BKP9R;       
N  __IO uint32_t BKP10R;     /*!< RTC backup register 10,                                    Address offset: 0x78 */
X  volatile uint32_t BKP10R;      
N  __IO uint32_t BKP11R;     /*!< RTC backup register 11,                                    Address offset: 0x7C */
X  volatile uint32_t BKP11R;      
N  __IO uint32_t BKP12R;     /*!< RTC backup register 12,                                    Address offset: 0x80 */
X  volatile uint32_t BKP12R;      
N  __IO uint32_t BKP13R;     /*!< RTC backup register 13,                                    Address offset: 0x84 */
X  volatile uint32_t BKP13R;      
N  __IO uint32_t BKP14R;     /*!< RTC backup register 14,                                    Address offset: 0x88 */
X  volatile uint32_t BKP14R;      
N  __IO uint32_t BKP15R;     /*!< RTC backup register 15,                                    Address offset: 0x8C */
X  volatile uint32_t BKP15R;      
N  __IO uint32_t BKP16R;     /*!< RTC backup register 16,                                    Address offset: 0x90 */
X  volatile uint32_t BKP16R;      
N  __IO uint32_t BKP17R;     /*!< RTC backup register 17,                                    Address offset: 0x94 */
X  volatile uint32_t BKP17R;      
N  __IO uint32_t BKP18R;     /*!< RTC backup register 18,                                    Address offset: 0x98 */
X  volatile uint32_t BKP18R;      
N  __IO uint32_t BKP19R;     /*!< RTC backup register 19,                                    Address offset: 0x9C */
X  volatile uint32_t BKP19R;      
N  __IO uint32_t BKP20R;     /*!< RTC backup register 20,                                    Address offset: 0xA0 */
X  volatile uint32_t BKP20R;      
N  __IO uint32_t BKP21R;     /*!< RTC backup register 21,                                    Address offset: 0xA4 */
X  volatile uint32_t BKP21R;      
N  __IO uint32_t BKP22R;     /*!< RTC backup register 22,                                    Address offset: 0xA8 */
X  volatile uint32_t BKP22R;      
N  __IO uint32_t BKP23R;     /*!< RTC backup register 23,                                    Address offset: 0xAC */
X  volatile uint32_t BKP23R;      
N  __IO uint32_t BKP24R;     /*!< RTC backup register 24,                                    Address offset: 0xB0 */
X  volatile uint32_t BKP24R;      
N  __IO uint32_t BKP25R;     /*!< RTC backup register 25,                                    Address offset: 0xB4 */
X  volatile uint32_t BKP25R;      
N  __IO uint32_t BKP26R;     /*!< RTC backup register 26,                                    Address offset: 0xB8 */
X  volatile uint32_t BKP26R;      
N  __IO uint32_t BKP27R;     /*!< RTC backup register 27,                                    Address offset: 0xBC */
X  volatile uint32_t BKP27R;      
N  __IO uint32_t BKP28R;     /*!< RTC backup register 28,                                    Address offset: 0xC0 */
X  volatile uint32_t BKP28R;      
N  __IO uint32_t BKP29R;     /*!< RTC backup register 29,                                    Address offset: 0xC4 */
X  volatile uint32_t BKP29R;      
N  __IO uint32_t BKP30R;     /*!< RTC backup register 30,                                    Address offset: 0xC8 */
X  volatile uint32_t BKP30R;      
N  __IO uint32_t BKP31R;     /*!< RTC backup register 31,                                    Address offset: 0xCC */
X  volatile uint32_t BKP31R;      
N} RTC_TypeDef;
N
N/** 
N  * @brief SD host Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t POWER;          /*!< SDIO power control register,    Address offset: 0x00 */
X  volatile uint32_t POWER;           
N  __IO uint32_t CLKCR;          /*!< SDI clock control register,     Address offset: 0x04 */
X  volatile uint32_t CLKCR;           
N  __IO uint32_t ARG;            /*!< SDIO argument register,         Address offset: 0x08 */
X  volatile uint32_t ARG;             
N  __IO uint32_t CMD;            /*!< SDIO command register,          Address offset: 0x0C */
X  volatile uint32_t CMD;             
N  __I uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
X  volatile const uint32_t  RESPCMD;         
N  __I uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
X  volatile const uint32_t  RESP1;           
N  __I uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
X  volatile const uint32_t  RESP2;           
N  __I uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
X  volatile const uint32_t  RESP3;           
N  __I uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
X  volatile const uint32_t  RESP4;           
N  __IO uint32_t DTIMER;         /*!< SDIO data timer register,       Address offset: 0x24 */
X  volatile uint32_t DTIMER;          
N  __IO uint32_t DLEN;           /*!< SDIO data length register,      Address offset: 0x28 */
X  volatile uint32_t DLEN;            
N  __IO uint32_t DCTRL;          /*!< SDIO data control register,     Address offset: 0x2C */
X  volatile uint32_t DCTRL;           
N  __I uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
X  volatile const uint32_t  DCOUNT;          
N  __I uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
X  volatile const uint32_t  STA;             
N  __IO uint32_t ICR;            /*!< SDIO interrupt clear register,  Address offset: 0x38 */
X  volatile uint32_t ICR;             
N  __IO uint32_t MASK;           /*!< SDIO mask register,             Address offset: 0x3C */
X  volatile uint32_t MASK;            
N  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
N  __I uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
X  volatile const uint32_t  FIFOCNT;         
N  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
N  __IO uint32_t FIFO;           /*!< SDIO data FIFO register,        Address offset: 0x80 */
X  volatile uint32_t FIFO;            
N} SDIO_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
X  volatile uint16_t CR1;         
N  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                           */
N  __IO uint16_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
X  volatile uint16_t CR2;         
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                           */
N  __IO uint16_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
X  volatile uint16_t SR;          
N  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                           */
N  __IO uint16_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
X  volatile uint16_t DR;          
N  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                           */
N  __IO uint16_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
X  volatile uint16_t CRCPR;       
N  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                           */
N  __IO uint16_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
X  volatile uint16_t RXCRCR;      
N  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                           */
N  __IO uint16_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
X  volatile uint16_t TXCRCR;      
N  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                           */
N  __IO uint16_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
X  volatile uint16_t I2SCFGR;     
N  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                                           */
N  __IO uint16_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
X  volatile uint16_t I2SPR;       
N  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                                           */
N} SPI_TypeDef;
N
N/** 
N  * @brief TIM
N  */
N
Ntypedef struct
N{
N  __IO uint16_t CR1;          /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint16_t CR1;           
N  uint16_t      RESERVED0;    /*!< Reserved, 0x02                                            */
N  __IO uint16_t CR2;          /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint16_t CR2;           
N  uint16_t      RESERVED1;    /*!< Reserved, 0x06                                            */
N  __IO uint16_t SMCR;         /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint16_t SMCR;          
N  uint16_t      RESERVED2;    /*!< Reserved, 0x0A                                            */
N  __IO uint16_t DIER;         /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint16_t DIER;          
N  uint16_t      RESERVED3;    /*!< Reserved, 0x0E                                            */
N  __IO uint16_t SR;           /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint16_t SR;            
N  uint16_t      RESERVED4;    /*!< Reserved, 0x12                                            */
N  __IO uint16_t EGR;          /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint16_t EGR;           
N  uint16_t      RESERVED5;    /*!< Reserved, 0x16                                            */
N  __IO uint16_t CCMR1;        /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint16_t CCMR1;         
N  uint16_t      RESERVED6;    /*!< Reserved, 0x1A                                            */
N  __IO uint16_t CCMR2;        /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint16_t CCMR2;         
N  uint16_t      RESERVED7;    /*!< Reserved, 0x1E                                            */
N  __IO uint16_t CCER;         /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint16_t CCER;          
N  uint16_t      RESERVED8;    /*!< Reserved, 0x22                                            */
N  __IO uint32_t CNT;          /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;           
N  __IO uint16_t PSC;          /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint16_t PSC;           
N  uint16_t      RESERVED10;   /*!< Reserved, 0x2A                                            */
N  __IO uint32_t ARR;          /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;           
N  uint32_t      RESERVED12;   /*!< Reserved, 0x30                                            */
N  __IO uint32_t CCR1;         /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;          
N  __IO uint32_t CCR2;         /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;          
N  __IO uint32_t CCR3;         /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;          
N  __IO uint32_t CCR4;         /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;          
N  uint32_t      RESERVED17;   /*!< Reserved, 0x44                                            */
N  __IO uint16_t DCR;          /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint16_t DCR;           
N  uint16_t      RESERVED18;   /*!< Reserved, 0x4A                                            */
N  __IO uint16_t DMAR;         /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint16_t DMAR;          
N  uint16_t      RESERVED19;   /*!< Reserved, 0x4E                                            */
N  __IO uint16_t OR;           /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint16_t OR;            
N  uint16_t      RESERVED20;   /*!< Reserved, 0x52                                            */
N} TIM_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N 
Ntypedef struct
N{
N  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
X  volatile uint16_t SR;          
N  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
N  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
X  volatile uint16_t DR;          
N  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
N  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
X  volatile uint16_t BRR;         
N  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
N  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
X  volatile uint16_t CR1;         
N  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
N  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
X  volatile uint16_t CR2;         
N  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
N  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
X  volatile uint16_t CR3;         
N  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
N  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
X  volatile uint16_t GTPR;        
N  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
N} USART_TypeDef;
N
N/** 
N  * @brief Window WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
N#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
N
N#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
N#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
N
N#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define LCD_BASE              (APB1PERIPH_BASE + 0x2400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N#define COMP_BASE             (APB1PERIPH_BASE + 0x7C00)
N#define RI_BASE               (APB1PERIPH_BASE + 0x7C04)
N#define OPAMP_BASE            (APB1PERIPH_BASE + 0x7C5C)
N
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define TIM9_BASE             (APB2PERIPH_BASE + 0x0800)
N#define TIM10_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define TIM11_BASE            (APB2PERIPH_BASE + 0x1000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC_BASE              (APB2PERIPH_BASE + 0x2700)
N#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N
N#define GPIOA_BASE            (AHBPERIPH_BASE + 0x0000)
N#define GPIOB_BASE            (AHBPERIPH_BASE + 0x0400)
N#define GPIOC_BASE            (AHBPERIPH_BASE + 0x0800)
N#define GPIOD_BASE            (AHBPERIPH_BASE + 0x0C00)
N#define GPIOE_BASE            (AHBPERIPH_BASE + 0x1000)
N#define GPIOH_BASE            (AHBPERIPH_BASE + 0x1400)
N#define GPIOF_BASE            (AHBPERIPH_BASE + 0x1800)
N#define GPIOG_BASE            (AHBPERIPH_BASE + 0x1C00)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x3800)
N
N
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x3C00) /*!< FLASH registers base address */
N#define OB_BASE               ((uint32_t)0x1FF80000)    /*!< FLASH Option Bytes base address */
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x6000)
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (DMA1_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (DMA1_BASE + 0x0080)
N
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x6400)
N#define DMA2_Channel1_BASE    (DMA2_BASE + 0x0008)
N#define DMA2_Channel2_BASE    (DMA2_BASE + 0x001C)
N#define DMA2_Channel3_BASE    (DMA2_BASE + 0x0030)
N#define DMA2_Channel4_BASE    (DMA2_BASE + 0x0044)
N#define DMA2_Channel5_BASE    (DMA2_BASE + 0x0058)
N
N#define AES_BASE              ((uint32_t)0x50060000)
N
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
N
N#define DBGMCU_BASE           ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define LCD                 ((LCD_TypeDef *) LCD_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define UART4               ((USART_TypeDef *) UART4_BASE)
N#define UART5               ((USART_TypeDef *) UART5_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define COMP                ((COMP_TypeDef *) COMP_BASE)
N#define RI                  ((RI_TypeDef *) RI_BASE)
N#define OPAMP               ((OPAMP_TypeDef *) OPAMP_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
N#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
N#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE) 
N
N#define AES                 ((AES_TypeDef *) AES_BASE)
N
N#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N
N/** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog to Digital Converter (ADC)                     */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for ADC_SR register  ********************/
N#define  ADC_SR_AWD                          ((uint32_t)0x00000001)        /*!< Analog watchdog flag */
N#define  ADC_SR_EOC                          ((uint32_t)0x00000002)        /*!< End of conversion */
N#define  ADC_SR_JEOC                         ((uint32_t)0x00000004)        /*!< Injected channel end of conversion */
N#define  ADC_SR_JSTRT                        ((uint32_t)0x00000008)        /*!< Injected channel Start flag */
N#define  ADC_SR_STRT                         ((uint32_t)0x00000010)        /*!< Regular channel Start flag */
N#define  ADC_SR_OVR                          ((uint32_t)0x00000020)        /*!< Overrun flag */
N#define  ADC_SR_ADONS                        ((uint32_t)0x00000040)        /*!< ADC ON status */
N#define  ADC_SR_RCNR                         ((uint32_t)0x00000100)        /*!< Regular channel not ready flag */
N#define  ADC_SR_JCNR                         ((uint32_t)0x00000200)        /*!< Injected channel not ready flag */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
N#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
N#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
N#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
N#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
N#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
N#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
N#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
N
N#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
N#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
N#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
N
N#define  ADC_CR1_PDD                         ((uint32_t)0x00010000)        /*!< Power Down during Delay phase */
N#define  ADC_CR1_PDI                         ((uint32_t)0x00020000)        /*!< Power Down during Idle phase */
N
N#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
N#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
N
N#define  ADC_CR1_RES                         ((uint32_t)0x03000000)        /*!< RES[1:0] bits (Resolution) */
N#define  ADC_CR1_RES_0                       ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_CR1_RES_1                       ((uint32_t)0x02000000)        /*!< Bit 1 */
N
N#define  ADC_CR1_OVRIE                       ((uint32_t)0x04000000)        /*!< Overrun interrupt enable */
N  
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
N#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
N#define  ADC_CR2_CFG                         ((uint32_t)0x00000004)        /*!< ADC Configuration */
N
N#define  ADC_CR2_DELS                        ((uint32_t)0x00000070)        /*!< DELS[2:0] bits (Delay selection) */
N#define  ADC_CR2_DELS_0                      ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  ADC_CR2_DELS_1                      ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  ADC_CR2_DELS_2                      ((uint32_t)0x00000040)        /*!< Bit 2 */
N
N#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
N#define  ADC_CR2_DDS                         ((uint32_t)0x00000200)        /*!< DMA disable selection (Single ADC) */
N#define  ADC_CR2_EOCS                        ((uint32_t)0x00000400)        /*!< End of conversion selection */
N#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
N
N#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x000F0000)        /*!< JEXTSEL[3:0] bits (External event select for injected group) */
N#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  ADC_CR2_JEXTSEL_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  ADC_CR2_JEXTEN                      ((uint32_t)0x00300000)        /*!< JEXTEN[1:0] bits (External Trigger Conversion mode for injected channels) */
N#define  ADC_CR2_JEXTEN_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_CR2_JEXTEN_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00400000)        /*!< Start Conversion of injected channels */
N
N#define  ADC_CR2_EXTSEL                      ((uint32_t)0x0F000000)        /*!< EXTSEL[3:0] bits (External Event Select for regular group) */
N#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  ADC_CR2_EXTSEL_3                    ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  ADC_CR2_EXTEN                       ((uint32_t)0x30000000)        /*!< EXTEN[1:0] bits (External Trigger Conversion mode for regular channels) */
N#define  ADC_CR2_EXTEN_0                     ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  ADC_CR2_EXTEN_1                     ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!< Start Conversion of regular channels */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define  ADC_SMPR1_SMP20                     ((uint32_t)0x00000007)        /*!< SMP20[2:0] bits (Channel 20 Sample time selection) */
N#define  ADC_SMPR1_SMP20_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP20_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP20_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP21                     ((uint32_t)0x00000038)        /*!< SMP21[2:0] bits (Channel 21 Sample time selection) */
N#define  ADC_SMPR1_SMP21_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP21_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP21_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP22                     ((uint32_t)0x000001C0)        /*!< SMP22[2:0] bits (Channel 22 Sample time selection) */
N#define  ADC_SMPR1_SMP22_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP22_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP22_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP23                     ((uint32_t)0x00000E00)        /*!< SMP23[2:0] bits (Channel 23 Sample time selection) */
N#define  ADC_SMPR1_SMP23_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP23_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP23_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP24                     ((uint32_t)0x00007000)        /*!< SMP24[2:0] bits (Channel 24 Sample time selection) */
N#define  ADC_SMPR1_SMP24_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP24_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP24_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP25                     ((uint32_t)0x00038000)        /*!< SMP25[2:0] bits (Channel 25 Sample time selection) */
N#define  ADC_SMPR1_SMP25_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP25_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP25_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP26                     ((uint32_t)0x001C0000)        /*!< SMP26[2:0] bits (Channel 26 Sample time selection) */
N#define  ADC_SMPR1_SMP26_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP26_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP26_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP27                     ((uint32_t)0x00E00000)        /*!< SMP27[2:0] bits (Channel 27 Sample time selection) */
N#define  ADC_SMPR1_SMP27_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP27_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP27_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP28                     ((uint32_t)0x07000000)        /*!< SMP28[2:0] bits (Channel 28 Sample time selection) */
N#define  ADC_SMPR1_SMP28_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP28_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP28_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define  ADC_SMPR1_SMP29                     ((uint32_t)0x38000000)        /*!< SMP29[2:0] bits (Channel 29 Sample time selection) */
N#define  ADC_SMPR1_SMP29_0                   ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP29_1                   ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP29_2                   ((uint32_t)0x20000000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define  ADC_SMPR2_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define  ADC_SMPR2_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define  ADC_SMPR2_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define  ADC_SMPR2_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define  ADC_SMPR2_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define  ADC_SMPR2_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR2_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define  ADC_SMPR2_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define  ADC_SMPR2_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP18                     ((uint32_t)0x07000000)        /*!< SMP18[2:0] bits (Channel 18 Sample time selection) */
N#define  ADC_SMPR2_SMP18_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP18_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP18_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define  ADC_SMPR2_SMP19                     ((uint32_t)0x38000000)        /*!< SMP19[2:0] bits (Channel 19 Sample time selection) */
N#define  ADC_SMPR2_SMP19_0                   ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP19_1                   ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP19_2                   ((uint32_t)0x20000000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_SMPR3 register  *******************/
N#define  ADC_SMPR3_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define  ADC_SMPR3_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
N 
N#define  ADC_SMPR3_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define  ADC_SMPR3_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define  ADC_SMPR3_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define  ADC_SMPR3_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define  ADC_SMPR3_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR3_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define  ADC_SMPR3_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define  ADC_SMPR3_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define  ADC_SMPR3_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define  ADC_SMPR3_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define  ADC_SMPR3_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define  ADC_JOFR1_JOFFSET1                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define  ADC_JOFR2_JOFFSET2                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define  ADC_JOFR3_JOFFSET3                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define  ADC_JOFR4_JOFFSET4                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define  ADC_HTR_HT                          ((uint32_t)0x00000FFF)        /*!< Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define  ADC_LTR_LT                          ((uint32_t)0x00000FFF)         /*!< Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
N#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  ADC_SQR1_SQ28                       ((uint32_t)0x000F8000)        /*!< SQ28[4:0] bits (25th conversion in regular sequence) */
N#define  ADC_SQR1_SQ28_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ28_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ28_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ28_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ28_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ27                       ((uint32_t)0x00007C00)        /*!< SQ27[4:0] bits (27th conversion in regular sequence) */
N#define  ADC_SQR1_SQ27_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ27_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ27_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ27_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ27_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ26                       ((uint32_t)0x000003E0)        /*!< SQ26[4:0] bits (26th conversion in regular sequence) */
N#define  ADC_SQR1_SQ26_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ26_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ26_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ26_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ26_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR1_SQ25                       ((uint32_t)0x0000001F)        /*!< SQ25[4:0] bits (25th conversion in regular sequence) */
N#define  ADC_SQR1_SQ25_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ25_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ25_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ25_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ25_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define  ADC_SQR2_SQ19                       ((uint32_t)0x0000001F)        /*!< SQ19[4:0] bits (19th conversion in regular sequence) */
N#define  ADC_SQR2_SQ19_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ19_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ19_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ19_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ19_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ20                       ((uint32_t)0x000003E0)        /*!< SQ20[4:0] bits (20th conversion in regular sequence) */
N#define  ADC_SQR2_SQ20_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ20_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ20_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ20_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ20_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ21                       ((uint32_t)0x00007C00)        /*!< SQ21[4:0] bits (21th conversion in regular sequence) */
N#define  ADC_SQR2_SQ21_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ21_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ21_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ21_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ21_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ22                       ((uint32_t)0x000F8000)        /*!< SQ22[4:0] bits (22th conversion in regular sequence) */
N#define  ADC_SQR2_SQ22_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ22_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ22_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ22_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ22_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ23                       ((uint32_t)0x01F00000)        /*!< SQ23[4:0] bits (23th conversion in regular sequence) */
N#define  ADC_SQR2_SQ23_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ23_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ23_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ23_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ23_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR2_SQ24                       ((uint32_t)0x3E000000)        /*!< SQ24[4:0] bits (24th conversion in regular sequence) */
N#define  ADC_SQR2_SQ24_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ24_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ24_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ24_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ24_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define  ADC_SQR3_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
N#define  ADC_SQR3_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
N#define  ADC_SQR3_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
N#define  ADC_SQR3_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
N#define  ADC_SQR3_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ17                       ((uint32_t)0x01F00000)        /*!< SQ17[4:0] bits (17th conversion in regular sequence) */
N#define  ADC_SQR3_SQ17_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ17_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ17_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ17_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ17_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR3_SQ18                       ((uint32_t)0x3E000000)        /*!< SQ18[4:0] bits (18th conversion in regular sequence) */
N#define  ADC_SQR3_SQ18_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ18_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ18_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ18_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ18_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR4 register  *******************/
N#define  ADC_SQR4_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
N#define  ADC_SQR4_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR4_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
N#define  ADC_SQR4_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR4_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
N#define  ADC_SQR4_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR4_SQ10                        ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
N#define  ADC_SQR4_SQ10_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ10_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ10_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ10_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ10_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR4_SQ11                        ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
N#define  ADC_SQR4_SQ11_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ11_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ11_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ11_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ11_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR4_SQ12                        ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
N#define  ADC_SQR4_SQ12_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR4_SQ12_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR4_SQ12_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR4_SQ12_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR4_SQ12_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR5 register  *******************/
N#define  ADC_SQR5_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
N#define  ADC_SQR5_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_SQR5_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define  ADC_SQR5_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_SQR5_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define  ADC_SQR5_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_SQR5_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
N#define  ADC_SQR5_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_SQR5_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
N#define  ADC_SQR5_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
N
N#define  ADC_SQR5_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
N#define  ADC_SQR5_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR5_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR5_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR5_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR5_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N
N#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
N#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define  ADC_JDR1_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define  ADC_JDR2_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define  ADC_JDR3_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define  ADC_JDR4_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
N
N/******************  Bit definition for ADC_SMPR0 register  *******************/
N#define  ADC_SMPR3_SMP30                     ((uint32_t)0x00000007)        /*!< SMP30[2:0] bits (Channel 30 Sample time selection) */
N#define  ADC_SMPR3_SMP30_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP30_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP30_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
N 
N#define  ADC_SMPR3_SMP31                     ((uint32_t)0x00000038)        /*!< SMP31[2:0] bits (Channel 31 Sample time selection) */
N#define  ADC_SMPR3_SMP31_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR3_SMP31_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR3_SMP31_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N/*******************  Bit definition for ADC_CSR register  ********************/
N#define  ADC_CSR_AWD1                        ((uint32_t)0x00000001)        /*!< ADC1 Analog watchdog flag */
N#define  ADC_CSR_EOC1                        ((uint32_t)0x00000002)        /*!< ADC1 End of conversion */
N#define  ADC_CSR_JEOC1                       ((uint32_t)0x00000004)        /*!< ADC1 Injected channel end of conversion */
N#define  ADC_CSR_JSTRT1                      ((uint32_t)0x00000008)        /*!< ADC1 Injected channel Start flag */
N#define  ADC_CSR_STRT1                       ((uint32_t)0x00000010)        /*!< ADC1 Regular channel Start flag */
N#define  ADC_CSR_OVR1                        ((uint32_t)0x00000020)        /*!< ADC1 overrun  flag */
N#define  ADC_CSR_ADONS1                      ((uint32_t)0x00000040)        /*!< ADON status of ADC1 */
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define  ADC_CCR_ADCPRE                      ((uint32_t)0x00030000)        /*!< ADC prescaler*/
N#define  ADC_CCR_ADCPRE_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  ADC_CCR_ADCPRE_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */ 
N#define  ADC_CCR_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       Advanced Encryption Standard (AES)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for AES_CR register  *********************/
N#define  AES_CR_EN                           ((uint32_t)0x00000001)        /*!< AES Enable */
N#define  AES_CR_DATATYPE                     ((uint32_t)0x00000006)        /*!< Data type selection */
N#define  AES_CR_DATATYPE_0                   ((uint32_t)0x00000002)        /*!< Bit 0 */
N#define  AES_CR_DATATYPE_1                   ((uint32_t)0x00000004)        /*!< Bit 1 */
N
N#define  AES_CR_MODE                         ((uint32_t)0x00000018)        /*!< AES Mode Of Operation */
N#define  AES_CR_MODE_0                       ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  AES_CR_MODE_1                       ((uint32_t)0x00000010)        /*!< Bit 1 */
N
N#define  AES_CR_CHMOD                        ((uint32_t)0x00000060)        /*!< AES Chaining Mode */
N#define  AES_CR_CHMOD_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  AES_CR_CHMOD_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N
N#define  AES_CR_CCFC                         ((uint32_t)0x00000080)        /*!< Computation Complete Flag Clear */
N#define  AES_CR_ERRC                         ((uint32_t)0x00000100)        /*!< Error Clear */
N#define  AES_CR_CCIE                         ((uint32_t)0x00000200)        /*!< Computation Complete Interrupt Enable */
N#define  AES_CR_ERRIE                        ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
N#define  AES_CR_DMAINEN                      ((uint32_t)0x00000800)        /*!< DMA ENable managing the data input phase */
N#define  AES_CR_DMAOUTEN                     ((uint32_t)0x00001000)        /*!< DMA Enable managing the data output phase */
N
N/*******************  Bit definition for AES_SR register  *********************/
N#define  AES_SR_CCF                          ((uint32_t)0x00000001)        /*!< Computation Complete Flag */
N#define  AES_SR_RDERR                        ((uint32_t)0x00000002)        /*!< Read Error Flag */
N#define  AES_SR_WRERR                        ((uint32_t)0x00000004)        /*!< Write Error Flag */
N
N/*******************  Bit definition for AES_DINR register  *******************/
N#define  AES_DINR                            ((uint32_t)0x0000FFFF)        /*!< AES Data Input Register */
N
N/*******************  Bit definition for AES_DOUTR register  ******************/
N#define  AES_DOUTR                           ((uint32_t)0x0000FFFF)        /*!< AES Data Output Register */
N
N/*******************  Bit definition for AES_KEYR0 register  ******************/
N#define  AES_KEYR0                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 0 */
N
N/*******************  Bit definition for AES_KEYR1 register  ******************/
N#define  AES_KEYR1                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 1 */
N
N/*******************  Bit definition for AES_KEYR2 register  ******************/
N#define  AES_KEYR2                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 2 */
N
N/*******************  Bit definition for AES_KEYR3 register  ******************/
N#define  AES_KEYR3                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 3 */
N
N/*******************  Bit definition for AES_IVR0 register  *******************/
N#define  AES_IVR0                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 0 */
N
N/*******************  Bit definition for AES_IVR1 register  *******************/
N#define  AES_IVR1                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 1 */
N
N/*******************  Bit definition for AES_IVR2 register  *******************/
N#define  AES_IVR2                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 2 */
N
N/*******************  Bit definition for AES_IVR3 register  *******************/
N#define  AES_IVR3                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 3 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for COMP_CSR register  ********************/
N#define  COMP_CSR_10KPU                      ((uint32_t)0x00000001)        /*!< 10K pull-up resistor */
N#define  COMP_CSR_400KPU                     ((uint32_t)0x00000002)        /*!< 400K pull-up resistor */
N#define  COMP_CSR_10KPD                      ((uint32_t)0x00000004)        /*!< 10K pull-down resistor */
N#define  COMP_CSR_400KPD                     ((uint32_t)0x00000008)        /*!< 400K pull-down resistor */
N
N#define  COMP_CSR_CMP1EN                     ((uint32_t)0x00000010)        /*!< Comparator 1 enable */
N#define  COMP_CSR_SW1                        ((uint32_t)0x00000020)        /*!< SW1 analog switch enable */
N#define  COMP_CSR_CMP1OUT                    ((uint32_t)0x00000080)        /*!< Comparator 1 output */
N
N#define  COMP_CSR_SPEED                      ((uint32_t)0x00001000)        /*!< Comparator 2 speed */
N#define  COMP_CSR_CMP2OUT                    ((uint32_t)0x00002000)        /*!< Comparator 2 ouput */
N
N#define  COMP_CSR_VREFOUTEN                  ((uint32_t)0x00010000)        /*!< Comparator Vref Enable */
N#define  COMP_CSR_WNDWE                      ((uint32_t)0x00020000)        /*!< Window mode enable */
N
N#define  COMP_CSR_INSEL                      ((uint32_t)0x001C0000)        /*!< INSEL[2:0] Inversion input Selection */
N#define  COMP_CSR_INSEL_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  COMP_CSR_INSEL_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  COMP_CSR_INSEL_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
N
N#define  COMP_CSR_OUTSEL                     ((uint32_t)0x00E00000)        /*!< OUTSEL[2:0] comparator 2 output redirection */
N#define  COMP_CSR_OUTSEL_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  COMP_CSR_OUTSEL_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  COMP_CSR_OUTSEL_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N#define  COMP_CSR_FCH3                       ((uint32_t)0x04000000)        /*!< Bit 26 */
N#define  COMP_CSR_FCH8                       ((uint32_t)0x08000000)        /*!< Bit 27 */
N#define  COMP_CSR_RCH13                      ((uint32_t)0x10000000)        /*!< Bit 28 */
N
N#define  COMP_CSR_CAIE                       ((uint32_t)0x20000000)        /*!< Bit 29 */
N#define  COMP_CSR_CAIF                       ((uint32_t)0x40000000)        /*!< Bit 30 */
N#define  COMP_CSR_TSUSP                      ((uint32_t)0x80000000)        /*!< Bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Operational Amplifier (OPAMP)                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for OPAMP_CSR register  ******************/
N#define OPAMP_CSR_OPA1PD                     ((uint32_t)0x00000001)        /*!< OPAMP1 disable */
N#define OPAMP_CSR_S3SEL1                     ((uint32_t)0x00000002)        /*!< Switch 3 for OPAMP1 Enable */
N#define OPAMP_CSR_S4SEL1                     ((uint32_t)0x00000004)        /*!< Switch 4 for OPAMP1 Enable */
N#define OPAMP_CSR_S5SEL1                     ((uint32_t)0x00000008)        /*!< Switch 5 for OPAMP1 Enable */
N#define OPAMP_CSR_S6SEL1                     ((uint32_t)0x00000010)        /*!< Switch 6 for OPAMP1 Enable */
N#define OPAMP_CSR_OPA1CAL_L                  ((uint32_t)0x00000020)        /*!< OPAMP1 Offset calibration for P differential pair */
N#define OPAMP_CSR_OPA1CAL_H                  ((uint32_t)0x00000040)        /*!< OPAMP1 Offset calibration for N differential pair */
N#define OPAMP_CSR_OPA1LPM                    ((uint32_t)0x00000080)        /*!< OPAMP1 Low power enable */
N#define OPAMP_CSR_OPA2PD                     ((uint32_t)0x00000100)        /*!< OPAMP2 disable */
N#define OPAMP_CSR_S3SEL2                     ((uint32_t)0x00000200)        /*!< Switch 3 for OPAMP2 Enable */
N#define OPAMP_CSR_S4SEL2                     ((uint32_t)0x00000400)        /*!< Switch 4 for OPAMP2 Enable */
N#define OPAMP_CSR_S5SEL2                     ((uint32_t)0x00000800)        /*!< Switch 5 for OPAMP2 Enable */
N#define OPAMP_CSR_S6SEL2                     ((uint32_t)0x00001000)        /*!< Switch 6 for OPAMP2 Enable */
N#define OPAMP_CSR_OPA2CAL_L                  ((uint32_t)0x00002000)        /*!< OPAMP2 Offset calibration for P differential pair */
N#define OPAMP_CSR_OPA2CAL_H                  ((uint32_t)0x00004000)        /*!< OPAMP2 Offset calibration for N differential pair */
N#define OPAMP_CSR_OPA2LPM                    ((uint32_t)0x00008000)        /*!< OPAMP2 Low power enable */
N#define OPAMP_CSR_OPA3PD                     ((uint32_t)0x00010000)        /*!< OPAMP3 disable */
N#define OPAMP_CSR_S3SEL3                     ((uint32_t)0x00020000)        /*!< Switch 3 for OPAMP3 Enable */
N#define OPAMP_CSR_S4SEL3                     ((uint32_t)0x00040000)        /*!< Switch 4 for OPAMP3 Enable */
N#define OPAMP_CSR_S5SEL3                     ((uint32_t)0x00080000)        /*!< Switch 5 for OPAMP3 Enable */
N#define OPAMP_CSR_S6SEL3                     ((uint32_t)0x00100000)        /*!< Switch 6 for OPAMP3 Enable */
N#define OPAMP_CSR_OPA3CAL_L                  ((uint32_t)0x00200000)        /*!< OPAMP3 Offset calibration for P differential pair */
N#define OPAMP_CSR_OPA3CAL_H                  ((uint32_t)0x00400000)        /*!< OPAMP3 Offset calibration for N differential pair */
N#define OPAMP_CSR_OPA3LPM                    ((uint32_t)0x00800000)        /*!< OPAMP3 Low power enable */
N#define OPAMP_CSR_ANAWSEL1                   ((uint32_t)0x01000000)        /*!< Switch ANA Enable for OPAMP1 */ 
N#define OPAMP_CSR_ANAWSEL2                   ((uint32_t)0x02000000)        /*!< Switch ANA Enable for OPAMP2 */
N#define OPAMP_CSR_ANAWSEL3                   ((uint32_t)0x04000000)        /*!< Switch ANA Enable for OPAMP3 */
N#define OPAMP_CSR_S7SEL2                     ((uint32_t)0x08000000)        /*!< Switch 7 for OPAMP2 Enable */
N#define OPAMP_CSR_AOP_RANGE                  ((uint32_t)0x10000000)        /*!< Power range selection */
N#define OPAMP_CSR_OPA1CALOUT                 ((uint32_t)0x20000000)        /*!< OPAMP1 calibration output */
N#define OPAMP_CSR_OPA2CALOUT                 ((uint32_t)0x40000000)        /*!< OPAMP2 calibration output */
N#define OPAMP_CSR_OPA3CALOUT                 ((uint32_t)0x80000000)        /*!< OPAMP3 calibration output */
N
N/*******************  Bit definition for OPAMP_OTR register  ******************/
N#define OPAMP_OTR_AO1_OPT_OFFSET_TRIM        ((uint32_t)0x000003FF)        /*!< Offset trim for OPAMP1 */
N#define OPAMP_OTR_AO2_OPT_OFFSET_TRIM        ((uint32_t)0x000FFC00)        /*!< Offset trim for OPAMP2 */
N#define OPAMP_OTR_AO3_OPT_OFFSET_TRIM        ((uint32_t)0x3FF00000)        /*!< Offset trim for OPAMP2 */
N#define OPAMP_OTR_OT_USER                    ((uint32_t)0x80000000)        /*!< Switch to OPAMP offset user trimmed values */
N
N/*******************  Bit definition for OPAMP_LPOTR register  ****************/
N#define OPAMP_LP_OTR_AO1_OPT_OFFSET_TRIM_LP  ((uint32_t)0x000003FF)        /*!< Offset trim in low power for OPAMP1 */
N#define OPAMP_LP_OTR_AO2_OPT_OFFSET_TRIM_LP  ((uint32_t)0x000FFC00)        /*!< Offset trim in low power for OPAMP2 */
N#define OPAMP_LP_OTR_AO3_OPT_OFFSET_TRIM_LP  ((uint32_t)0x3FF00000)        /*!< Offset trim in low power for OPAMP3 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       CRC calculation unit (CRC)                           */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF)        /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)               /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint32_t)0x00000001)        /*!< RESET bit */
N
N/******************************************************************************/
N/*                                                                            */
N/*                    Digital to Analog Converter (DAC)                       */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for DAC_CR register  ********************/
N#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!<DAC channel1 enable */
N#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!<DAC channel1 output buffer disable */
N#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!<DAC channel1 Trigger enable */
N
N#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!<Bit 0 */
N#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!<Bit 1 */
N#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!<Bit 2 */
N
N#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!<Bit 0 */
N#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!<Bit 1 */
N
N#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!<Bit 0 */
N#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!<Bit 1 */
N#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!<Bit 2 */
N#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!<Bit 3 */
N
N#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!<DAC channel1 DMA enable */
N#define  DAC_CR_DMAUDRIE1                    ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun interrupt enable */
N#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!<DAC channel2 enable */
N#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!<DAC channel2 output buffer disable */
N#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!<DAC channel2 Trigger enable */
N
N#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!<Bit 0 */
N#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!<Bit 1 */
N#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!<Bit 2 */
N
N#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!<Bit 0 */
N#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!<Bit 1 */
N
N#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!<Bit 0 */
N#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!<Bit 1 */
N#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!<Bit 2 */
N#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!<Bit 3 */
N
N#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!<DAC channel2 DMA enabled */
N#define  DAC_CR_DMAUDRIE2                    ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun interrupt enable */
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!<DAC channel1 software trigger */
N#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!<DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!<DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!<DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!<DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!<DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!<DAC channel1 12-bit Right aligned data */
N#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!<DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!<DAC channel1 12-bit Left aligned data */
N#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!<DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!<DAC channel1 8-bit Right aligned data */
N#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!<DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun flag */
N#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Debug MCU (DBGMCU)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
N
N#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
N#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
N#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
N#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
N#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
N#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
N#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
N#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
N#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
N#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
N#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
N
N#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
N#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
N
N#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP             ((uint32_t)0x00000001)   /*!< TIM2 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP             ((uint32_t)0x00000002)   /*!< TIM3 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP             ((uint32_t)0x00000004)   /*!< TIM4 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP             ((uint32_t)0x00000008)   /*!< TIM5 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP             ((uint32_t)0x00000010)   /*!< TIM6 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP             ((uint32_t)0x00000020)   /*!< TIM7 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP              ((uint32_t)0x00000400)   /*!< RTC Counter stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP             ((uint32_t)0x00000800)   /*!< Debug Window Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP             ((uint32_t)0x00001000)   /*!< Debug Independent Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)   /*!< SMBUS timeout mode stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)   /*!< SMBUS timeout mode stopped when Core is halted */
N
N/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
N
N#define  DBGMCU_APB2_FZ_DBG_TIM9_STOP             ((uint32_t)0x00000004)   /*!< TIM9 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM10_STOP            ((uint32_t)0x00000008)   /*!< TIM10 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM11_STOP            ((uint32_t)0x00000010)   /*!< TIM11 counter stopped when core is halted */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
N#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
N#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
N#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
N#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
N#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
N#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
N#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
N#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
N#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
N#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
N#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
N#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
N#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
N#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
N#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
N#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
N#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
N#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
N#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
N#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
N#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
N#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
N#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
N#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
N#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
N#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
N#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clearr */
N#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
N#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
N#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
N#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
N#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
N#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
N#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
N#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
N#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
N#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
N#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
N#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
N#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
N#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
N#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
N#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
N#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
N#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
N#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
N#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
N
N/*******************  Bit definition for DMA_CCR1 register  *******************/
N#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
N#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
N#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR2 register  *******************/
N#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< ransfer complete interrupt enable */
N#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR3 register  *******************/
N#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*!<******************  Bit definition for DMA_CCR4 register  *******************/
N#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/******************  Bit definition for DMA_CCR5 register  *******************/
N#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
N
N/*******************  Bit definition for DMA_CCR6 register  *******************/
N#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
N
N/*******************  Bit definition for DMA_CCR7 register  *******************/
N#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
N#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
N#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
N#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
N#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
N#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
N#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
N#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
N
N#define  DMA_CCR7_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
N#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
N
N#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
N#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
N
N#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
N#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
N
N/******************  Bit definition for DMA_CNDTR1 register  ******************/
N#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR2 register  ******************/
N#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR3 register  ******************/
N#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR4 register  ******************/
N#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR5 register  ******************/
N#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR6 register  ******************/
N#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CNDTR7 register  ******************/
N#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
N
N/******************  Bit definition for DMA_CPAR1 register  *******************/
N#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR2 register  *******************/
N#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR3 register  *******************/
N#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N
N/******************  Bit definition for DMA_CPAR4 register  *******************/
N#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR5 register  *******************/
N#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CPAR6 register  *******************/
N#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N
N/******************  Bit definition for DMA_CPAR7 register  *******************/
N#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
N
N/******************  Bit definition for DMA_CMAR1 register  *******************/
N#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR2 register  *******************/
N#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR3 register  *******************/
N#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N
N/******************  Bit definition for DMA_CMAR4 register  *******************/
N#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR5 register  *******************/
N#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR6 register  *******************/
N#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************  Bit definition for DMA_CMAR7 register  *******************/
N#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
N
N/******************************************************************************/
N/*                                                                            */
N/*                  External Interrupt/Event Controller (EXTI)                */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
N#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
N#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
N#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
N#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
N#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
N#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
N#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
N#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
N#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
N#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
N#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
N#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
N#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
N#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
N#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit 0 */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit 1 */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit 2 */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit 3 */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit 4 */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit 5 */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit 6 */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit 7 */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit 8 */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit 9 */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit 17 */
N#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit 18 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit 19 */
N#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit 20 */
N#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit 21 */
N#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit 22 */
N#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit 23 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                FLASH, DATA EEPROM and Option Bytes Registers               */
N/*                        (FLASH, DATA_EEPROM, OB)                            */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define  FLASH_ACR_LATENCY                   ((uint32_t)0x00000001)        /*!< Latency */
N#define  FLASH_ACR_PRFTEN                    ((uint32_t)0x00000002)        /*!< Prefetch Buffer Enable */
N#define  FLASH_ACR_ACC64                     ((uint32_t)0x00000004)        /*!< Access 64 bits */
N#define  FLASH_ACR_SLEEP_PD                  ((uint32_t)0x00000008)        /*!< Flash mode during sleep mode */
N#define  FLASH_ACR_RUN_PD                    ((uint32_t)0x00000010)        /*!< Flash mode during RUN mode */
N
N/*******************  Bit definition for FLASH_PECR register  ******************/
N#define FLASH_PECR_PELOCK                    ((uint32_t)0x00000001)        /*!< FLASH_PECR and Flash data Lock */
N#define FLASH_PECR_PRGLOCK                   ((uint32_t)0x00000002)        /*!< Program matrix Lock */
N#define FLASH_PECR_OPTLOCK                   ((uint32_t)0x00000004)        /*!< Option byte matrix Lock */
N#define FLASH_PECR_PROG                      ((uint32_t)0x00000008)        /*!< Program matrix selection */
N#define FLASH_PECR_DATA                      ((uint32_t)0x00000010)        /*!< Data matrix selection */
N#define FLASH_PECR_FTDW                      ((uint32_t)0x00000100)        /*!< Fixed Time Data write for Word/Half Word/Byte programming */
N#define FLASH_PECR_ERASE                     ((uint32_t)0x00000200)        /*!< Page erasing mode */
N#define FLASH_PECR_FPRG                      ((uint32_t)0x00000400)        /*!< Fast Page/Half Page programming mode */
N#define FLASH_PECR_PARALLBANK                ((uint32_t)0x00008000)        /*!< Parallel Bank mode */
N#define FLASH_PECR_EOPIE                     ((uint32_t)0x00010000)        /*!< End of programming interrupt */ 
N#define FLASH_PECR_ERRIE                     ((uint32_t)0x00020000)        /*!< Error interrupt */ 
N#define FLASH_PECR_OBL_LAUNCH                ((uint32_t)0x00040000)        /*!< Launch the option byte loading */ 
N
N/******************  Bit definition for FLASH_PDKEYR register  ******************/
N#define  FLASH_PDKEYR_PDKEYR                 ((uint32_t)0xFFFFFFFF)       /*!< FLASH_PEC and data matrix Key */
N
N/******************  Bit definition for FLASH_PEKEYR register  ******************/
N#define  FLASH_PEKEYR_PEKEYR                 ((uint32_t)0xFFFFFFFF)       /*!< FLASH_PEC and data matrix Key */
N
N/******************  Bit definition for FLASH_PRGKEYR register  ******************/
N#define  FLASH_PRGKEYR_PRGKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Program matrix Key */
N
N/******************  Bit definition for FLASH_OPTKEYR register  ******************/
N#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option bytes matrix Key */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
N#define  FLASH_SR_EOP                        ((uint32_t)0x00000002)        /*!< End Of Programming*/
N#define  FLASH_SR_ENHV                       ((uint32_t)0x00000004)        /*!< End of high voltage */
N#define  FLASH_SR_READY                      ((uint32_t)0x00000008)        /*!< Flash ready after low power mode */
N
N#define  FLASH_SR_WRPERR                     ((uint32_t)0x00000100)        /*!< Write protected error */
N#define  FLASH_SR_PGAERR                     ((uint32_t)0x00000200)        /*!< Programming Alignment Error */
N#define  FLASH_SR_SIZERR                     ((uint32_t)0x00000400)        /*!< Size error */
N#define  FLASH_SR_OPTVERR                    ((uint32_t)0x00000800)        /*!< Option validity error */
N#define  FLASH_SR_OPTVERRUSR                 ((uint32_t)0x00001000)        /*!< Option User validity error */
N#define  FLASH_SR_RDERR                      ((uint32_t)0x00002000)        /*!< Read protected error */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define  FLASH_OBR_RDPRT                     ((uint32_t)0x000000AA)        /*!< Read Protection */
N#define  FLASH_OBR_SPRMOD                    ((uint32_t)0x00000100)        /*!< Selection of protection mode of WPRi bits 
N                                                                                (available only in STM32L1xx Medium-density Plus devices) */
N#define  FLASH_OBR_BOR_LEV                   ((uint32_t)0x000F0000)        /*!< BOR_LEV[3:0] Brown Out Reset Threshold Level*/
N#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00100000)        /*!< IWDG_SW */
N#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00200000)        /*!< nRST_STOP */
N#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00400000)        /*!< nRST_STDBY */
N#define  FLASH_OBR_BFB2                      ((uint32_t)0x00800000)        /*!< BFB2(available only in STM32L1xx High-density devices) */
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define  FLASH_WRPR_WRP                      ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits */
N
N/******************  Bit definition for FLASH_WRPR1 register  *****************/
N#define  FLASH_WRPR1_WRP                     ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits (available only in STM32L1xx
N                                                                                Medium-density Plus and High-density devices) */
N
N/******************  Bit definition for FLASH_WRPR2 register  *****************/
N#define  FLASH_WRPR2_WRP                     ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits (available only in STM32L1xx
N                                                                                High-density devices) */
N/******************************************************************************/
N/*                                                                            */
N/*                       Flexible Static Memory Controller                    */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for FSMC_BCR1 register  *******************/
N#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR2 register  *******************/
N#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR3 register  *******************/
N#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
N#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BCR4 register  *******************/
N#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
N#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
N
N#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
N#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
N#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
N
N#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
N#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
N#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
N#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
N#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
N#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
N#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
N#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
N#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
N#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
N
N/******************  Bit definition for FSMC_BTR1 register  ******************/
N#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BTR2 register  *******************/
N#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/*******************  Bit definition for FSMC_BTR3 register  *******************/
N#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BTR4 register  *******************/
N#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
N#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR1 register  ******************/
N#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR2 register  ******************/
N#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
N#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR3 register  ******************/
N#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************  Bit definition for FSMC_BWTR4 register  ******************/
N#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
N#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
N#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
N#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
N#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
N#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
N#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      General Purpose IOs (GPIO)                            */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/  
N#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
N#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
N#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
N#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
N#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
N#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
N#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
N#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
N#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
N#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
N#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
N#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
N#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
N#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
N#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
N#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
N#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
N#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
N#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
N#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
N#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
N#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
N#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
N#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
N#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
N#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
N#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
N#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
N#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
N#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
N#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
N#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
N#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
N#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
N#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
N#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
N#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
N#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
N#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
N#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
N#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
N#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
N#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
N#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
N#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
N#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
N#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
N#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_OTYPER register  ****************/   
N#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
N#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
N#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
N#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
N#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
N#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
N#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
N#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
N#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
N#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
N#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
N#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
N#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
N#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
N#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
N#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
N
N/*******************  Bit definition for GPIO_OSPEEDR register  ***************/  
N#define GPIO_OSPEEDER_OSPEEDR0     ((uint32_t)0x00000003)
N#define GPIO_OSPEEDER_OSPEEDR0_0   ((uint32_t)0x00000001)
N#define GPIO_OSPEEDER_OSPEEDR0_1   ((uint32_t)0x00000002)
N#define GPIO_OSPEEDER_OSPEEDR1     ((uint32_t)0x0000000C)
N#define GPIO_OSPEEDER_OSPEEDR1_0   ((uint32_t)0x00000004)
N#define GPIO_OSPEEDER_OSPEEDR1_1   ((uint32_t)0x00000008)
N#define GPIO_OSPEEDER_OSPEEDR2     ((uint32_t)0x00000030)
N#define GPIO_OSPEEDER_OSPEEDR2_0   ((uint32_t)0x00000010)
N#define GPIO_OSPEEDER_OSPEEDR2_1   ((uint32_t)0x00000020)
N#define GPIO_OSPEEDER_OSPEEDR3     ((uint32_t)0x000000C0)
N#define GPIO_OSPEEDER_OSPEEDR3_0   ((uint32_t)0x00000040)
N#define GPIO_OSPEEDER_OSPEEDR3_1   ((uint32_t)0x00000080)
N#define GPIO_OSPEEDER_OSPEEDR4     ((uint32_t)0x00000300)
N#define GPIO_OSPEEDER_OSPEEDR4_0   ((uint32_t)0x00000100)
N#define GPIO_OSPEEDER_OSPEEDR4_1   ((uint32_t)0x00000200)
N#define GPIO_OSPEEDER_OSPEEDR5     ((uint32_t)0x00000C00)
N#define GPIO_OSPEEDER_OSPEEDR5_0   ((uint32_t)0x00000400)
N#define GPIO_OSPEEDER_OSPEEDR5_1   ((uint32_t)0x00000800)
N#define GPIO_OSPEEDER_OSPEEDR6     ((uint32_t)0x00003000)
N#define GPIO_OSPEEDER_OSPEEDR6_0   ((uint32_t)0x00001000)
N#define GPIO_OSPEEDER_OSPEEDR6_1   ((uint32_t)0x00002000)
N#define GPIO_OSPEEDER_OSPEEDR7     ((uint32_t)0x0000C000)
N#define GPIO_OSPEEDER_OSPEEDR7_0   ((uint32_t)0x00004000)
N#define GPIO_OSPEEDER_OSPEEDR7_1   ((uint32_t)0x00008000)
N#define GPIO_OSPEEDER_OSPEEDR8     ((uint32_t)0x00030000)
N#define GPIO_OSPEEDER_OSPEEDR8_0   ((uint32_t)0x00010000)
N#define GPIO_OSPEEDER_OSPEEDR8_1   ((uint32_t)0x00020000)
N#define GPIO_OSPEEDER_OSPEEDR9     ((uint32_t)0x000C0000)
N#define GPIO_OSPEEDER_OSPEEDR9_0   ((uint32_t)0x00040000)
N#define GPIO_OSPEEDER_OSPEEDR9_1   ((uint32_t)0x00080000)
N#define GPIO_OSPEEDER_OSPEEDR10    ((uint32_t)0x00300000)
N#define GPIO_OSPEEDER_OSPEEDR10_0  ((uint32_t)0x00100000)
N#define GPIO_OSPEEDER_OSPEEDR10_1  ((uint32_t)0x00200000)
N#define GPIO_OSPEEDER_OSPEEDR11    ((uint32_t)0x00C00000)
N#define GPIO_OSPEEDER_OSPEEDR11_0  ((uint32_t)0x00400000)
N#define GPIO_OSPEEDER_OSPEEDR11_1  ((uint32_t)0x00800000)
N#define GPIO_OSPEEDER_OSPEEDR12    ((uint32_t)0x03000000)
N#define GPIO_OSPEEDER_OSPEEDR12_0  ((uint32_t)0x01000000)
N#define GPIO_OSPEEDER_OSPEEDR12_1  ((uint32_t)0x02000000)
N#define GPIO_OSPEEDER_OSPEEDR13    ((uint32_t)0x0C000000)
N#define GPIO_OSPEEDER_OSPEEDR13_0  ((uint32_t)0x04000000)
N#define GPIO_OSPEEDER_OSPEEDR13_1  ((uint32_t)0x08000000)
N#define GPIO_OSPEEDER_OSPEEDR14    ((uint32_t)0x30000000)
N#define GPIO_OSPEEDER_OSPEEDR14_0  ((uint32_t)0x10000000)
N#define GPIO_OSPEEDER_OSPEEDR14_1  ((uint32_t)0x20000000)
N#define GPIO_OSPEEDER_OSPEEDR15    ((uint32_t)0xC0000000)
N#define GPIO_OSPEEDER_OSPEEDR15_0  ((uint32_t)0x40000000)
N#define GPIO_OSPEEDER_OSPEEDR15_1  ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_PUPDR register  *****************/  
N#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
N#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
N#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
N#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
N#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
N#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
N#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
N#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
N#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
N#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
N#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
N#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
N#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
N#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
N#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
N#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
N#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
N#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
N#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
N#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
N#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
N#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
N#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
N#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
N#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
N#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
N#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
N#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
N#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
N#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
N#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
N#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
N#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
N#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
N#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
N#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
N#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
N#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
N#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
N#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
N#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
N#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
N#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
N#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
N#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
N#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
N#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
N#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
N
N/******************  Bits definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_IDR_0                       ((uint32_t)0x00000001)
N#define GPIO_IDR_IDR_1                       ((uint32_t)0x00000002)
N#define GPIO_IDR_IDR_2                       ((uint32_t)0x00000004)
N#define GPIO_IDR_IDR_3                       ((uint32_t)0x00000008)
N#define GPIO_IDR_IDR_4                       ((uint32_t)0x00000010)
N#define GPIO_IDR_IDR_5                       ((uint32_t)0x00000020)
N#define GPIO_IDR_IDR_6                       ((uint32_t)0x00000040)
N#define GPIO_IDR_IDR_7                       ((uint32_t)0x00000080)
N#define GPIO_IDR_IDR_8                       ((uint32_t)0x00000100)
N#define GPIO_IDR_IDR_9                       ((uint32_t)0x00000200)
N#define GPIO_IDR_IDR_10                      ((uint32_t)0x00000400)
N#define GPIO_IDR_IDR_11                      ((uint32_t)0x00000800)
N#define GPIO_IDR_IDR_12                      ((uint32_t)0x00001000)
N#define GPIO_IDR_IDR_13                      ((uint32_t)0x00002000)
N#define GPIO_IDR_IDR_14                      ((uint32_t)0x00004000)
N#define GPIO_IDR_IDR_15                      ((uint32_t)0x00008000)
N/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_IDR_0                    GPIO_IDR_IDR_0
N#define GPIO_OTYPER_IDR_1                    GPIO_IDR_IDR_1
N#define GPIO_OTYPER_IDR_2                    GPIO_IDR_IDR_2
N#define GPIO_OTYPER_IDR_3                    GPIO_IDR_IDR_3
N#define GPIO_OTYPER_IDR_4                    GPIO_IDR_IDR_4
N#define GPIO_OTYPER_IDR_5                    GPIO_IDR_IDR_5
N#define GPIO_OTYPER_IDR_6                    GPIO_IDR_IDR_6
N#define GPIO_OTYPER_IDR_7                    GPIO_IDR_IDR_7
N#define GPIO_OTYPER_IDR_8                    GPIO_IDR_IDR_8
N#define GPIO_OTYPER_IDR_9                    GPIO_IDR_IDR_9
N#define GPIO_OTYPER_IDR_10                   GPIO_IDR_IDR_10
N#define GPIO_OTYPER_IDR_11                   GPIO_IDR_IDR_11
N#define GPIO_OTYPER_IDR_12                   GPIO_IDR_IDR_12
N#define GPIO_OTYPER_IDR_13                   GPIO_IDR_IDR_13
N#define GPIO_OTYPER_IDR_14                   GPIO_IDR_IDR_14
N#define GPIO_OTYPER_IDR_15                   GPIO_IDR_IDR_15
N
N/******************  Bits definition for GPIO_ODR register  *******************/
N#define GPIO_ODR_ODR_0                       ((uint32_t)0x00000001)
N#define GPIO_ODR_ODR_1                       ((uint32_t)0x00000002)
N#define GPIO_ODR_ODR_2                       ((uint32_t)0x00000004)
N#define GPIO_ODR_ODR_3                       ((uint32_t)0x00000008)
N#define GPIO_ODR_ODR_4                       ((uint32_t)0x00000010)
N#define GPIO_ODR_ODR_5                       ((uint32_t)0x00000020)
N#define GPIO_ODR_ODR_6                       ((uint32_t)0x00000040)
N#define GPIO_ODR_ODR_7                       ((uint32_t)0x00000080)
N#define GPIO_ODR_ODR_8                       ((uint32_t)0x00000100)
N#define GPIO_ODR_ODR_9                       ((uint32_t)0x00000200)
N#define GPIO_ODR_ODR_10                      ((uint32_t)0x00000400)
N#define GPIO_ODR_ODR_11                      ((uint32_t)0x00000800)
N#define GPIO_ODR_ODR_12                      ((uint32_t)0x00001000)
N#define GPIO_ODR_ODR_13                      ((uint32_t)0x00002000)
N#define GPIO_ODR_ODR_14                      ((uint32_t)0x00004000)
N#define GPIO_ODR_ODR_15                      ((uint32_t)0x00008000)
N/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
N#define GPIO_OTYPER_ODR_0                    GPIO_ODR_ODR_0
N#define GPIO_OTYPER_ODR_1                    GPIO_ODR_ODR_1
N#define GPIO_OTYPER_ODR_2                    GPIO_ODR_ODR_2
N#define GPIO_OTYPER_ODR_3                    GPIO_ODR_ODR_3
N#define GPIO_OTYPER_ODR_4                    GPIO_ODR_ODR_4
N#define GPIO_OTYPER_ODR_5                    GPIO_ODR_ODR_5
N#define GPIO_OTYPER_ODR_6                    GPIO_ODR_ODR_6
N#define GPIO_OTYPER_ODR_7                    GPIO_ODR_ODR_7
N#define GPIO_OTYPER_ODR_8                    GPIO_ODR_ODR_8
N#define GPIO_OTYPER_ODR_9                    GPIO_ODR_ODR_9
N#define GPIO_OTYPER_ODR_10                   GPIO_ODR_ODR_10
N#define GPIO_OTYPER_ODR_11                   GPIO_ODR_ODR_11
N#define GPIO_OTYPER_ODR_12                   GPIO_ODR_ODR_12
N#define GPIO_OTYPER_ODR_13                   GPIO_ODR_ODR_13
N#define GPIO_OTYPER_ODR_14                   GPIO_ODR_ODR_14
N#define GPIO_OTYPER_ODR_15                   GPIO_ODR_ODR_15
N
N/*******************  Bit definition for GPIO_BSRR register  ******************/  
N#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
N#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
N#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
N#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
N#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
N#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
N#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
N#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
N#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
N#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
N#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
N#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
N#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
N#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
N#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
N#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
N#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
N#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
N#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
N#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
N#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
N#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
N#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
N#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
N#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
N#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
N#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
N#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
N#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
N#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
N#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
N#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_LCKR register  ******************/
N#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
N#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
N#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
N#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
N#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
N#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
N#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
N#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
N#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
N#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
N#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
N#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
N#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
N#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
N#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
N#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
N#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
N
N/*******************  Bit definition for GPIO_AFRL register  ******************/
N#define GPIO_AFRL_AFRL0            ((uint32_t)0x0000000F)
N#define GPIO_AFRL_AFRL1            ((uint32_t)0x000000F0)
N#define GPIO_AFRL_AFRL2            ((uint32_t)0x00000F00)
N#define GPIO_AFRL_AFRL3            ((uint32_t)0x0000F000)
N#define GPIO_AFRL_AFRL4            ((uint32_t)0x000F0000)
N#define GPIO_AFRL_AFRL5            ((uint32_t)0x00F00000)
N#define GPIO_AFRL_AFRL6            ((uint32_t)0x0F000000)
N#define GPIO_AFRL_AFRL7            ((uint32_t)0xF0000000)
N
N/*******************  Bit definition for GPIO_AFRH register  ******************/
N#define GPIO_AFRH_AFRH8            ((uint32_t)0x0000000F)
N#define GPIO_AFRH_AFRH9            ((uint32_t)0x000000F0)
N#define GPIO_AFRH_AFRH10           ((uint32_t)0x00000F00)
N#define GPIO_AFRH_AFRH11           ((uint32_t)0x0000F000)
N#define GPIO_AFRH_AFRH12           ((uint32_t)0x000F0000)
N#define GPIO_AFRH_AFRH13           ((uint32_t)0x00F00000)
N#define GPIO_AFRH_AFRH14           ((uint32_t)0x0F000000)
N#define GPIO_AFRH_AFRH15           ((uint32_t)0xF0000000)
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Inter-integrated Circuit Interface (I2C)                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for I2C_CR1 register  ********************/
N#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
N#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
N#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
N#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
N#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
N#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
N#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
N#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
N#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
N#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
N#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
N#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
N#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
N#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
N
N/*******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
N#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
N
N#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
N#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
N#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
N#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
N#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
N
N/*******************  Bit definition for I2C_OAR1 register  *******************/
N#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
N#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
N
N#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
N#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
N#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
N#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
N
N#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
N
N/*******************  Bit definition for I2C_OAR2 register  *******************/
N#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
N#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
N
N/********************  Bit definition for I2C_DR register  ********************/
N#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
N
N/*******************  Bit definition for I2C_SR1 register  ********************/
N#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
N#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
N#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
N#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
N#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
N#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
N#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
N#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
N#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
N#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
N#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
N#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
N#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
N#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
N
N/*******************  Bit definition for I2C_SR2 register  ********************/
N#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
N#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
N#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
N#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
N#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
N#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
N#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
N#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
N
N/*******************  Bit definition for I2C_CCR register  ********************/
N#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
N#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
N#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
N
N/******************  Bit definition for I2C_TRISE register  *******************/
N#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Independent WATCHDOG (IWDG)                         */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          LCD Controller (LCD)                              */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for LCD_CR register  *********************/
N#define LCD_CR_LCDEN               ((uint32_t)0x00000001)     /*!< LCD Enable Bit */
N#define LCD_CR_VSEL                ((uint32_t)0x00000002)     /*!< Voltage source selector Bit */
N
N#define LCD_CR_DUTY                ((uint32_t)0x0000001C)     /*!< DUTY[2:0] bits (Duty selector) */
N#define LCD_CR_DUTY_0              ((uint32_t)0x00000004)     /*!< Duty selector Bit 0 */
N#define LCD_CR_DUTY_1              ((uint32_t)0x00000008)     /*!< Duty selector Bit 1 */
N#define LCD_CR_DUTY_2              ((uint32_t)0x00000010)     /*!< Duty selector Bit 2 */
N
N#define LCD_CR_BIAS                ((uint32_t)0x00000060)     /*!< BIAS[1:0] bits (Bias selector) */
N#define LCD_CR_BIAS_0              ((uint32_t)0x00000020)     /*!< Bias selector Bit 0 */
N#define LCD_CR_BIAS_1              ((uint32_t)0x00000040)     /*!< Bias selector Bit 1 */
N
N#define LCD_CR_MUX_SEG             ((uint32_t)0x00000080)     /*!< Mux Segment Enable Bit */
N
N/*******************  Bit definition for LCD_FCR register  ********************/
N#define LCD_FCR_HD                 ((uint32_t)0x00000001)     /*!< High Drive Enable Bit */
N#define LCD_FCR_SOFIE              ((uint32_t)0x00000002)     /*!< Start of Frame Interrupt Enable Bit */
N#define LCD_FCR_UDDIE              ((uint32_t)0x00000008)     /*!< Update Display Done Interrupt Enable Bit */
N
N#define LCD_FCR_PON                ((uint32_t)0x00000070)     /*!< PON[2:0] bits (Puls ON Duration) */
N#define LCD_FCR_PON_0              ((uint32_t)0x00000010)     /*!< Bit 0 */
N#define LCD_FCR_PON_1              ((uint32_t)0x00000020)     /*!< Bit 1 */
N#define LCD_FCR_PON_2              ((uint32_t)0x00000040)     /*!< Bit 2 */
N
N#define LCD_FCR_DEAD               ((uint32_t)0x00000380)     /*!< DEAD[2:0] bits (DEAD Time) */
N#define LCD_FCR_DEAD_0             ((uint32_t)0x00000080)     /*!< Bit 0 */
N#define LCD_FCR_DEAD_1             ((uint32_t)0x00000100)     /*!< Bit 1 */
N#define LCD_FCR_DEAD_2             ((uint32_t)0x00000200)     /*!< Bit 2 */
N
N#define LCD_FCR_CC                 ((uint32_t)0x00001C00)     /*!< CC[2:0] bits (Contrast Control) */
N#define LCD_FCR_CC_0               ((uint32_t)0x00000400)     /*!< Bit 0 */
N#define LCD_FCR_CC_1               ((uint32_t)0x00000800)     /*!< Bit 1 */
N#define LCD_FCR_CC_2               ((uint32_t)0x00001000)     /*!< Bit 2 */
N
N#define LCD_FCR_BLINKF             ((uint32_t)0x0000E000)     /*!< BLINKF[2:0] bits (Blink Frequency) */
N#define LCD_FCR_BLINKF_0           ((uint32_t)0x00002000)     /*!< Bit 0 */
N#define LCD_FCR_BLINKF_1           ((uint32_t)0x00004000)     /*!< Bit 1 */
N#define LCD_FCR_BLINKF_2           ((uint32_t)0x00008000)     /*!< Bit 2 */
N
N#define LCD_FCR_BLINK              ((uint32_t)0x00030000)     /*!< BLINK[1:0] bits (Blink Enable) */
N#define LCD_FCR_BLINK_0            ((uint32_t)0x00010000)     /*!< Bit 0 */
N#define LCD_FCR_BLINK_1            ((uint32_t)0x00020000)     /*!< Bit 1 */
N
N#define LCD_FCR_DIV                ((uint32_t)0x003C0000)     /*!< DIV[3:0] bits (Divider) */
N#define LCD_FCR_PS                 ((uint32_t)0x03C00000)     /*!< PS[3:0] bits (Prescaler) */
N
N/*******************  Bit definition for LCD_SR register  *********************/
N#define LCD_SR_ENS                 ((uint32_t)0x00000001)     /*!< LCD Enabled Bit */
N#define LCD_SR_SOF                 ((uint32_t)0x00000002)     /*!< Start Of Frame Flag Bit */
N#define LCD_SR_UDR                 ((uint32_t)0x00000004)     /*!< Update Display Request Bit */
N#define LCD_SR_UDD                 ((uint32_t)0x00000008)     /*!< Update Display Done Flag Bit */
N#define LCD_SR_RDY                 ((uint32_t)0x00000010)     /*!< Ready Flag Bit */
N#define LCD_SR_FCRSR               ((uint32_t)0x00000020)     /*!< LCD FCR Register Synchronization Flag Bit */
N
N/*******************  Bit definition for LCD_CLR register  ********************/
N#define LCD_CLR_SOFC               ((uint32_t)0x00000002)     /*!< Start Of Frame Flag Clear Bit */
N#define LCD_CLR_UDDC               ((uint32_t)0x00000008)     /*!< Update Display Done Flag Clear Bit */
N
N/*******************  Bit definition for LCD_RAM register  ********************/
N#define LCD_RAM_SEGMENT_DATA       ((uint32_t)0xFFFFFFFF)     /*!< Segment Data Bits */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Power Control (PWR)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPSDSR                       ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep/low power run */
N#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
N#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
N#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
N#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
N
N#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
N
N/*!< PVD level configuration */
N#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
N#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
N#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
N#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
N#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
N#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
N#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
N#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
N
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
N#define  PWR_CR_ULP                          ((uint16_t)0x0200)     /*!< Ultra Low Power mode */
N#define  PWR_CR_FWU                          ((uint16_t)0x0400)     /*!< Fast wakeup */
N
N#define  PWR_CR_VOS                          ((uint16_t)0x1800)     /*!< VOS[1:0] bits (Voltage scaling range selection) */
N#define  PWR_CR_VOS_0                        ((uint16_t)0x0800)     /*!< Bit 0 */
N#define  PWR_CR_VOS_1                        ((uint16_t)0x1000)     /*!< Bit 1 */
N#define  PWR_CR_LPRUN                        ((uint16_t)0x4000)     /*!< Low power run mode */
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
N#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
N#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
N#define  PWR_CSR_VREFINTRDYF                 ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready flag */
N#define  PWR_CSR_VOSF                        ((uint16_t)0x0010)     /*!< Voltage Scaling select flag */
N#define  PWR_CSR_REGLPF                      ((uint16_t)0x0020)     /*!< Regulator LP flag */
N
N#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
N#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
N#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Reset and Clock Control (RCC)                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
N
N#define  RCC_CR_MSION                        ((uint32_t)0x00000100)        /*!< Internal Multi Speed clock enable */
N#define  RCC_CR_MSIRDY                       ((uint32_t)0x00000200)        /*!< Internal Multi Speed clock ready flag */
N
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
N
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
N#define  RCC_CR_CSSON                        ((uint32_t)0x10000000)        /*!< Clock Security System enable */
N
N#define  RCC_CR_RTCPRE                       ((uint32_t)0x60000000)        /*!< RTC/LCD Prescaler */
N#define  RCC_CR_RTCPRE_0                     ((uint32_t)0x20000000)        /*!< Bit0 */
N#define  RCC_CR_RTCPRE_1                     ((uint32_t)0x40000000)        /*!< Bit1 */
N
N/********************  Bit definition for RCC_ICSCR register  *****************/
N#define  RCC_ICSCR_HSICAL                    ((uint32_t)0x000000FF)        /*!< Internal High Speed clock Calibration */
N#define  RCC_ICSCR_HSITRIM                   ((uint32_t)0x00001F00)        /*!< Internal High Speed clock trimming */
N
N#define  RCC_ICSCR_MSIRANGE                  ((uint32_t)0x0000E000)        /*!< Internal Multi Speed clock Range */
N#define  RCC_ICSCR_MSIRANGE_0                ((uint32_t)0x00000000)        /*!< Internal Multi Speed clock Range 65.536 KHz */
N#define  RCC_ICSCR_MSIRANGE_1                ((uint32_t)0x00002000)        /*!< Internal Multi Speed clock Range 131.072 KHz */
N#define  RCC_ICSCR_MSIRANGE_2                ((uint32_t)0x00004000)        /*!< Internal Multi Speed clock Range 262.144 KHz */
N#define  RCC_ICSCR_MSIRANGE_3                ((uint32_t)0x00006000)        /*!< Internal Multi Speed clock Range 524.288 KHz */
N#define  RCC_ICSCR_MSIRANGE_4                ((uint32_t)0x00008000)        /*!< Internal Multi Speed clock Range 1.048 MHz */
N#define  RCC_ICSCR_MSIRANGE_5                ((uint32_t)0x0000A000)        /*!< Internal Multi Speed clock Range 2.097 MHz */
N#define  RCC_ICSCR_MSIRANGE_6                ((uint32_t)0x0000C000)        /*!< Internal Multi Speed clock Range 4.194 MHz */
N#define  RCC_ICSCR_MSICAL                    ((uint32_t)0x00FF0000)        /*!< Internal Multi Speed clock Calibration */
N#define  RCC_ICSCR_MSITRIM                   ((uint32_t)0xFF000000)        /*!< Internal Multi Speed clock trimming */
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N/*!< SW configuration */
N#define  RCC_CFGR_SW_MSI                     ((uint32_t)0x00000000)        /*!< MSI selected as system clock */
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000001)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000002)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000003)        /*!< PLL selected as system clock */
N
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N/*!< SWS configuration */
N#define  RCC_CFGR_SWS_MSI                    ((uint32_t)0x00000000)        /*!< MSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000004)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000008)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x0000000C)        /*!< PLL used as system clock */
N
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N/*!< HPRE configuration */
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
N
N/*!< PPRE1 configuration */
N#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
N
N#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
N
N/*!< PPRE2 configuration */
N#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
N
N/*!< PLL entry clock source*/
N#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
N
N#define  RCC_CFGR_PLLSRC_HSI                 ((uint32_t)0x00000000)        /*!< HSI as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_HSE                 ((uint32_t)0x00010000)        /*!< HSE as PLL entry clock source */
N
N
N#define  RCC_CFGR_PLLMUL                     ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMUL_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMUL_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMUL_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMUL_3                   ((uint32_t)0x00200000)        /*!< Bit 3 */
N
N/*!< PLLMUL configuration */
N#define  RCC_CFGR_PLLMUL3                    ((uint32_t)0x00000000)        /*!< PLL input clock * 3 */
N#define  RCC_CFGR_PLLMUL4                    ((uint32_t)0x00040000)        /*!< PLL input clock * 4 */
N#define  RCC_CFGR_PLLMUL6                    ((uint32_t)0x00080000)        /*!< PLL input clock * 6 */
N#define  RCC_CFGR_PLLMUL8                    ((uint32_t)0x000C0000)        /*!< PLL input clock * 8 */
N#define  RCC_CFGR_PLLMUL12                   ((uint32_t)0x00100000)        /*!< PLL input clock * 12 */
N#define  RCC_CFGR_PLLMUL16                   ((uint32_t)0x00140000)        /*!< PLL input clock * 16 */
N#define  RCC_CFGR_PLLMUL24                   ((uint32_t)0x00180000)        /*!< PLL input clock * 24 */
N#define  RCC_CFGR_PLLMUL32                   ((uint32_t)0x001C0000)        /*!< PLL input clock * 32 */
N#define  RCC_CFGR_PLLMUL48                   ((uint32_t)0x00200000)        /*!< PLL input clock * 48 */
N
N/*!< PLLDIV configuration */
N#define  RCC_CFGR_PLLDIV                     ((uint32_t)0x00C00000)        /*!< PLLDIV[1:0] bits (PLL Output Division) */
N#define  RCC_CFGR_PLLDIV_0                   ((uint32_t)0x00400000)        /*!< Bit0 */
N#define  RCC_CFGR_PLLDIV_1                   ((uint32_t)0x00800000)        /*!< Bit1 */
N
N
N/*!< PLLDIV configuration */
N#define  RCC_CFGR_PLLDIV1                    ((uint32_t)0x00000000)        /*!< PLL clock output = CKVCO / 1 */
N#define  RCC_CFGR_PLLDIV2                    ((uint32_t)0x00400000)        /*!< PLL clock output = CKVCO / 2 */
N#define  RCC_CFGR_PLLDIV3                    ((uint32_t)0x00800000)        /*!< PLL clock output = CKVCO / 3 */
N#define  RCC_CFGR_PLLDIV4                    ((uint32_t)0x00C00000)        /*!< PLL clock output = CKVCO / 4 */
N
N
N#define  RCC_CFGR_MCOSEL                     ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
N#define  RCC_CFGR_MCOSEL_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  RCC_CFGR_MCOSEL_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  RCC_CFGR_MCOSEL_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N/*!< MCO configuration */
N#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x01000000)        /*!< System clock selected */
N#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x02000000)        /*!< Internal 16 MHz RC oscillator clock selected */
N#define  RCC_CFGR_MCO_MSI                    ((uint32_t)0x03000000)        /*!< Internal Medium Speed RC oscillator clock selected */
N#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x04000000)        /*!< External 1-25 MHz oscillator clock selected */
N#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x05000000)        /*!< PLL clock divided */
N#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x06000000)        /*!< LSI selected */
N#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x07000000)        /*!< LSE selected */
N
N#define  RCC_CFGR_MCOPRE                     ((uint32_t)0x70000000)        /*!< MCOPRE[2:0] bits (Microcontroller Clock Output Prescaler) */
N#define  RCC_CFGR_MCOPRE_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
N#define  RCC_CFGR_MCOPRE_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
N#define  RCC_CFGR_MCOPRE_2                   ((uint32_t)0x40000000)        /*!< Bit 2 */
N
N/*!< MCO Prescaler configuration */
N#define  RCC_CFGR_MCO_DIV1                   ((uint32_t)0x00000000)        /*!< MCO Clock divided by 1 */
N#define  RCC_CFGR_MCO_DIV2                   ((uint32_t)0x10000000)        /*!< MCO Clock divided by 2 */
N#define  RCC_CFGR_MCO_DIV4                   ((uint32_t)0x20000000)        /*!< MCO Clock divided by 4 */
N#define  RCC_CFGR_MCO_DIV8                   ((uint32_t)0x30000000)        /*!< MCO Clock divided by 8 */
N#define  RCC_CFGR_MCO_DIV16                  ((uint32_t)0x40000000)        /*!< MCO Clock divided by 16 */
N
N/*!<******************  Bit definition for RCC_CIR register  ********************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
N#define  RCC_CIR_MSIRDYF                     ((uint32_t)0x00000020)        /*!< MSI Ready Interrupt flag */
N#define  RCC_CIR_LSECSS                      ((uint32_t)0x00000040)        /*!< LSE CSS Interrupt flag */
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
N
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
N#define  RCC_CIR_MSIRDYIE                    ((uint32_t)0x00002000)        /*!< MSI Ready Interrupt Enable */
N#define  RCC_CIR_LSECSSIE                    ((uint32_t)0x00004000)        /*!< LSE CSS Interrupt Enable */
N
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
N#define  RCC_CIR_MSIRDYC                     ((uint32_t)0x00200000)        /*!< MSI Ready Interrupt Clear */
N#define  RCC_CIR_LSECSSC                     ((uint32_t)0x00400000)        /*!< LSE CSS Interrupt Clear */
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
N
N
N/*****************  Bit definition for RCC_AHBRSTR register  ******************/
N#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00000001)        /*!< GPIO port A reset */
N#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00000002)        /*!< GPIO port B reset */
N#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00000004)        /*!< GPIO port C reset */
N#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00000008)        /*!< GPIO port D reset */
N#define  RCC_AHBRSTR_GPIOERST                ((uint32_t)0x00000010)        /*!< GPIO port E reset */
N#define  RCC_AHBRSTR_GPIOHRST                ((uint32_t)0x00000020)        /*!< GPIO port H reset */
N#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00000040)        /*!< GPIO port F reset */
N#define  RCC_AHBRSTR_GPIOGRST                ((uint32_t)0x00000080)        /*!< GPIO port G reset */
N#define  RCC_AHBRSTR_CRCRST                  ((uint32_t)0x00001000)        /*!< CRC reset */
N#define  RCC_AHBRSTR_FLITFRST                ((uint32_t)0x00008000)        /*!< FLITF reset */
N#define  RCC_AHBRSTR_DMA1RST                 ((uint32_t)0x01000000)        /*!< DMA1 reset */
N#define  RCC_AHBRSTR_DMA2RST                 ((uint32_t)0x02000000)        /*!< DMA2 reset */
N#define  RCC_AHBRSTR_AESRST                  ((uint32_t)0x08000000)        /*!< AES reset */
N#define  RCC_AHBRSTR_FSMCRST                 ((uint32_t)0x40000000)        /*!< FSMC reset */
N 
N/*****************  Bit definition for RCC_APB2RSTR register  *****************/
N#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< System Configuration SYSCFG reset */
N#define  RCC_APB2RSTR_TIM9RST                ((uint32_t)0x00000004)        /*!< TIM9 reset */
N#define  RCC_APB2RSTR_TIM10RST               ((uint32_t)0x00000008)        /*!< TIM10 reset */
N#define  RCC_APB2RSTR_TIM11RST               ((uint32_t)0x00000010)        /*!< TIM11 reset */
N#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC1 reset */
N#define  RCC_APB2RSTR_SDIORST                ((uint32_t)0x00000800)        /*!< SDIO reset */
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 reset */
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
N
N/*****************  Bit definition for RCC_APB1RSTR register  *****************/
N#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
N#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)        /*!< Timer 4 reset */
N#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
N#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
N#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
N#define  RCC_APB1RSTR_LCDRST                 ((uint32_t)0x00000200)        /*!< LCD reset */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
N#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI 2 reset */
N#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
N#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 reset */
N#define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
N#define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
N#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 reset */
N#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB reset */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
N#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
N#define  RCC_APB1RSTR_COMPRST                ((uint32_t)0x80000000)        /*!< Comparator interface reset */
N
N/******************  Bit definition for RCC_AHBENR register  ******************/
N#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00000001)        /*!< GPIO port A clock enable */
N#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00000002)        /*!< GPIO port B clock enable */
N#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00000004)        /*!< GPIO port C clock enable */
N#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00000008)        /*!< GPIO port D clock enable */
N#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00000010)        /*!< GPIO port E clock enable */
N#define  RCC_AHBENR_GPIOHEN                  ((uint32_t)0x00000020)        /*!< GPIO port H clock enable */
N#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00000040)        /*!< GPIO port F clock enable */
N#define  RCC_AHBENR_GPIOGEN                  ((uint32_t)0x00000080)        /*!< GPIO port G clock enable */
N#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00001000)        /*!< CRC clock enable */
N#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00008000)        /*!< FLITF clock enable (has effect only when
N                                                                                the Flash memory is in power down mode) */
N#define  RCC_AHBENR_DMA1EN                   ((uint32_t)0x01000000)        /*!< DMA1 clock enable */
N#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x02000000)        /*!< DMA2 clock enable */
N#define  RCC_AHBENR_AESEN                    ((uint32_t)0x08000000)        /*!< AES clock enable */
N#define  RCC_AHBENR_FSMCEN                   ((uint32_t)0x40000000)        /*!< FSMC clock enable */
N
N
N/******************  Bit definition for RCC_APB2ENR register  *****************/
N#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00000001)         /*!< System Configuration SYSCFG clock enable */
N#define  RCC_APB2ENR_TIM9EN                  ((uint32_t)0x00000004)         /*!< TIM9 interface clock enable */
N#define  RCC_APB2ENR_TIM10EN                 ((uint32_t)0x00000008)         /*!< TIM10 interface clock enable */
N#define  RCC_APB2ENR_TIM11EN                 ((uint32_t)0x00000010)         /*!< TIM11 Timer clock enable */
N#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC1 clock enable */
N#define  RCC_APB2ENR_SDIOEN                  ((uint32_t)0x00000800)         /*!< SDIO clock enable */
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI1 clock enable */
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
N
N
N/*****************  Bit definition for RCC_APB1ENR register  ******************/
N#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
N#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
N#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
N#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
N#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
N#define  RCC_APB1ENR_LCDEN                   ((uint32_t)0x00000200)        /*!< LCD clock enable */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
N#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
N#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
N#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
N#define  RCC_APB1ENR_UART4EN                 ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
N#define  RCC_APB1ENR_UART5EN                 ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
N#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
N#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
N#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
N#define  RCC_APB1ENR_COMPEN                  ((uint32_t)0x80000000)        /*!< Comparator interface clock enable */
N
N/******************  Bit definition for RCC_AHBLPENR register  ****************/
N#define  RCC_AHBLPENR_GPIOALPEN              ((uint32_t)0x00000001)        /*!< GPIO port A clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOBLPEN              ((uint32_t)0x00000002)        /*!< GPIO port B clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOCLPEN              ((uint32_t)0x00000004)        /*!< GPIO port C clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIODLPEN              ((uint32_t)0x00000008)        /*!< GPIO port D clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOELPEN              ((uint32_t)0x00000010)        /*!< GPIO port E clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOHLPEN              ((uint32_t)0x00000020)        /*!< GPIO port H clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOFLPEN              ((uint32_t)0x00000040)        /*!< GPIO port F clock enabled in sleep mode */
N#define  RCC_AHBLPENR_GPIOGLPEN              ((uint32_t)0x00000080)        /*!< GPIO port G clock enabled in sleep mode */
N#define  RCC_AHBLPENR_CRCLPEN                ((uint32_t)0x00001000)        /*!< CRC clock enabled in sleep mode */
N#define  RCC_AHBLPENR_FLITFLPEN              ((uint32_t)0x00008000)        /*!< Flash Interface clock enabled in sleep mode
N                                                                                (has effect only when the Flash memory is
N                                                                                 in power down mode) */
N#define  RCC_AHBLPENR_SRAMLPEN               ((uint32_t)0x00010000)        /*!< SRAM clock enabled in sleep mode */
N#define  RCC_AHBLPENR_DMA1LPEN               ((uint32_t)0x01000000)        /*!< DMA1 clock enabled in sleep mode */
N#define  RCC_AHBLPENR_DMA2LPEN               ((uint32_t)0x02000000)        /*!< DMA2 clock enabled in sleep mode */
N#define  RCC_AHBLPENR_AESLPEN                ((uint32_t)0x08000000)        /*!< AES clock enabled in sleep mode */
N#define  RCC_AHBLPENR_FSMCLPEN               ((uint32_t)0x40000000)        /*!< FSMC clock enabled in sleep mode */
N
N/******************  Bit definition for RCC_APB2LPENR register  ***************/
N#define  RCC_APB2LPENR_SYSCFGLPEN            ((uint32_t)0x00000001)         /*!< System Configuration SYSCFG clock enabled in sleep mode */
N#define  RCC_APB2LPENR_TIM9LPEN              ((uint32_t)0x00000004)         /*!< TIM9 interface clock enabled in sleep mode */
N#define  RCC_APB2LPENR_TIM10LPEN             ((uint32_t)0x00000008)         /*!< TIM10 interface clock enabled in sleep mode */
N#define  RCC_APB2LPENR_TIM11LPEN             ((uint32_t)0x00000010)         /*!< TIM11 Timer clock enabled in sleep mode */
N#define  RCC_APB2LPENR_ADC1LPEN              ((uint32_t)0x00000200)         /*!< ADC1 clock enabled in sleep mode */
N#define  RCC_APB2LPENR_SDIOLPEN              ((uint32_t)0x00000800)         /*!< SDIO clock enabled in sleep mode */
N#define  RCC_APB2LPENR_SPI1LPEN              ((uint32_t)0x00001000)         /*!< SPI1 clock enabled in sleep mode */
N#define  RCC_APB2LPENR_USART1LPEN            ((uint32_t)0x00004000)         /*!< USART1 clock enabled in sleep mode */
N
N/*****************  Bit definition for RCC_APB1LPENR register  ****************/
N#define  RCC_APB1LPENR_TIM2LPEN              ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_TIM3LPEN              ((uint32_t)0x00000002)        /*!< Timer 3 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_TIM4LPEN              ((uint32_t)0x00000004)        /*!< Timer 4 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_TIM5LPEN              ((uint32_t)0x00000008)        /*!< Timer 5 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_TIM6LPEN              ((uint32_t)0x00000010)        /*!< Timer 6 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_TIM7LPEN              ((uint32_t)0x00000020)        /*!< Timer 7 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_LCDLPEN               ((uint32_t)0x00000200)        /*!< LCD clock enabled in sleep mode */
N#define  RCC_APB1LPENR_WWDGLPEN              ((uint32_t)0x00000800)        /*!< Window Watchdog clock enabled in sleep mode */
N#define  RCC_APB1LPENR_SPI2LPEN              ((uint32_t)0x00004000)        /*!< SPI 2 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_SPI3LPEN              ((uint32_t)0x00008000)        /*!< SPI 3 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_USART2LPEN            ((uint32_t)0x00020000)        /*!< USART 2 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_USART3LPEN            ((uint32_t)0x00040000)        /*!< USART 3 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_UART4LPEN             ((uint32_t)0x00080000)        /*!< UART 4 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_UART5LPEN             ((uint32_t)0x00100000)        /*!< UART 5 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_I2C1LPEN              ((uint32_t)0x00200000)        /*!< I2C 1 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_I2C2LPEN              ((uint32_t)0x00400000)        /*!< I2C 2 clock enabled in sleep mode */
N#define  RCC_APB1LPENR_USBLPEN               ((uint32_t)0x00800000)        /*!< USB clock enabled in sleep mode */
N#define  RCC_APB1LPENR_PWRLPEN               ((uint32_t)0x10000000)        /*!< Power interface clock enabled in sleep mode */
N#define  RCC_APB1LPENR_DACLPEN               ((uint32_t)0x20000000)        /*!< DAC interface clock enabled in sleep mode */
N#define  RCC_APB1LPENR_COMPLPEN              ((uint32_t)0x80000000)        /*!< Comparator interface clock enabled in sleep mode*/
N
N/*******************  Bit definition for RCC_CSR register  ********************/
N#define  RCC_CSR_LSION                      ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
N#define  RCC_CSR_LSIRDY                     ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
N
N#define  RCC_CSR_LSEON                      ((uint32_t)0x00000100)        /*!< External Low Speed oscillator enable */
N#define  RCC_CSR_LSERDY                     ((uint32_t)0x00000200)        /*!< External Low Speed oscillator Ready */
N#define  RCC_CSR_LSEBYP                     ((uint32_t)0x00000400)        /*!< External Low Speed oscillator Bypass */
N#define  RCC_CSR_LSECSSON                   ((uint32_t)0x00000800)        /*!< External Low Speed oscillator CSS Enable */
N#define  RCC_CSR_LSECSSD                    ((uint32_t)0x00001000)        /*!< External Low Speed oscillator CSS Detected */
N
N#define  RCC_CSR_RTCSEL                     ((uint32_t)0x00030000)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define  RCC_CSR_RTCSEL_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  RCC_CSR_RTCSEL_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
N
N/*!< RTC congiguration */
N#define  RCC_CSR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_CSR_RTCSEL_LSE                 ((uint32_t)0x00010000)        /*!< LSE oscillator clock used as RTC clock */
N#define  RCC_CSR_RTCSEL_LSI                 ((uint32_t)0x00020000)        /*!< LSI oscillator clock used as RTC clock */
N#define  RCC_CSR_RTCSEL_HSE                 ((uint32_t)0x00030000)        /*!< HSE oscillator clock divided by 2, 4, 8 or 16 by RTCPRE used as RTC clock */
N
N#define  RCC_CSR_RTCEN                      ((uint32_t)0x00400000)        /*!< RTC clock enable */
N#define  RCC_CSR_RTCRST                     ((uint32_t)0x00800000)        /*!< RTC reset  */
N 
N#define  RCC_CSR_RMVF                       ((uint32_t)0x01000000)        /*!< Remove reset flag */
N#define  RCC_CSR_OBLRSTF                    ((uint32_t)0x02000000)        /*!< Option Bytes Loader reset flag */
N#define  RCC_CSR_PINRSTF                    ((uint32_t)0x04000000)        /*!< PIN reset flag */
N#define  RCC_CSR_PORRSTF                    ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
N#define  RCC_CSR_SFTRSTF                    ((uint32_t)0x10000000)        /*!< Software Reset flag */
N#define  RCC_CSR_IWDGRSTF                   ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
N#define  RCC_CSR_WWDGRSTF                   ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
N#define  RCC_CSR_LPWRRSTF                   ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM                            ((uint32_t)0x00400000)
N#define RTC_TR_HT                            ((uint32_t)0x00300000)
N#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
N#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
N#define RTC_TR_HU                            ((uint32_t)0x000F0000)
N#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
N#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
N#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
N#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
N#define RTC_TR_MNT                           ((uint32_t)0x00007000)
N#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
N#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
N#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
N#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
N#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
N#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
N#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
N#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
N#define RTC_TR_ST                            ((uint32_t)0x00000070)
N#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
N#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
N#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
N#define RTC_TR_SU                            ((uint32_t)0x0000000F)
N#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
N#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
N#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
N#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT                            ((uint32_t)0x00F00000)
N#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
N#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
N#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
N#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
N#define RTC_DR_YU                            ((uint32_t)0x000F0000)
N#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
N#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
N#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
N#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
N#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
N#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
N#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
N#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
N#define RTC_DR_MT                            ((uint32_t)0x00001000)
N#define RTC_DR_MU                            ((uint32_t)0x00000F00)
N#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
N#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
N#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
N#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
N#define RTC_DR_DT                            ((uint32_t)0x00000030)
N#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
N#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
N#define RTC_DR_DU                            ((uint32_t)0x0000000F)
N#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
N#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
N#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
N#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_COE                           ((uint32_t)0x00800000)
N#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
N#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
N#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
N#define RTC_CR_POL                           ((uint32_t)0x00100000)
N#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
N#define RTC_CR_BCK                           ((uint32_t)0x00040000)
N#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
N#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
N#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
N#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
N#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
N#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
N#define RTC_CR_TSE                           ((uint32_t)0x00000800)
N#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
N#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
N#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
N#define RTC_CR_DCE                           ((uint32_t)0x00000080)
N#define RTC_CR_FMT                           ((uint32_t)0x00000040)
N#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
N#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
N#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
N#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
N#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
N#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
N#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
N#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)
N#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
N#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
N#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
N#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
N#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
N#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
N#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
N#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
N#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
N#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
N#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
N#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
N#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
N#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
N#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
N#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CALIBR register  ***************/
N#define RTC_CALIBR_DCS                       ((uint32_t)0x00000080)
N#define RTC_CALIBR_DC                        ((uint32_t)0x0000001F)
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
N#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
N#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
N#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
N#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
N#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
N#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
N#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
N#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
N#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
N#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
N#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
N#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
N#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
N#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
N#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
N#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
N#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
N#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
N#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
N#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
N#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
N#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
N#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
N#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
N#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
N#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
N#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
N#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
N#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
N#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
N#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
N#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
N#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
N#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
N#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
N#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
N#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
N#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
N#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
N#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
N#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
N#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
N#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
N#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
N#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
N#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
N#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
N#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
N#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
N#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
N#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
N#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
N#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
N#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
N#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
N#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
N#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
N#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
N#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
N#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
N#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
N#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
N#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
N#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
N#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
N#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
N#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
N#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
N#define RTC_TAFCR_TAMP3TRG                   ((uint32_t)0x00000040)
N#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)
N#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
N#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)
N#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
N#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
N#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP20R register  ***************/
N#define RTC_BKP20R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP21R register  ***************/
N#define RTC_BKP21R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP22R register  ***************/
N#define RTC_BKP22R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP23R register  ***************/
N#define RTC_BKP23R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP24R register  ***************/
N#define RTC_BKP24R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP25R register  ***************/
N#define RTC_BKP25R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP26R register  ***************/
N#define RTC_BKP26R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP27R register  ***************/
N#define RTC_BKP27R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP28R register  ***************/
N#define RTC_BKP28R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP29R register  ***************/
N#define RTC_BKP29R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP30R register  ***************/
N#define RTC_BKP30R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP31R register  ***************/
N#define RTC_BKP31R                           ((uint32_t)0xFFFFFFFF)
N
N/******************************************************************************/
N/*                                                                            */
N/*                          SD host Interface                                 */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for SDIO_POWER register  ******************/
N#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
N#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
N#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
N
N/******************  Bit definition for SDIO_CLKCR register  ******************/
N#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
N#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
N#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
N#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
N
N#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
N#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
N#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
N
N#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
N#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
N
N/*******************  Bit definition for SDIO_ARG register  *******************/
N#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
N
N/*******************  Bit definition for SDIO_CMD register  *******************/
N#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
N
N#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
N#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
N#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
N
N#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
N#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
N#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
N#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
N#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
N#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
N#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
N
N/*****************  Bit definition for SDIO_RESPCMD register  *****************/
N#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
N
N/******************  Bit definition for SDIO_RESP0 register  ******************/
N#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP1 register  ******************/
N#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP2 register  ******************/
N#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP3 register  ******************/
N#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_RESP4 register  ******************/
N#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
N
N/******************  Bit definition for SDIO_DTIMER register  *****************/
N#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
N
N/******************  Bit definition for SDIO_DLEN register  *******************/
N#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
N
N/******************  Bit definition for SDIO_DCTRL register  ******************/
N#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
N#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
N#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
N#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
N
N#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
N#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
N#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
N#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
N#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
N
N#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
N#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
N#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
N#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
N
N/******************  Bit definition for SDIO_DCOUNT register  *****************/
N#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
N
N/******************  Bit definition for SDIO_STA register  ********************/
N#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
N#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
N#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
N#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
N#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
N#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
N#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
N#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
N#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
N#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
N#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
N#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
N#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
N#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
N#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
N#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
N#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
N#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
N#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
N#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
N#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
N#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
N#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
N#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
N
N/*******************  Bit definition for SDIO_ICR register  *******************/
N#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
N#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
N#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
N#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
N#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
N#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
N#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
N#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
N#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
N#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
N#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
N#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
N#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
N
N/******************  Bit definition for SDIO_MASK register  *******************/
N#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
N#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
N#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
N#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
N#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
N#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
N#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
N#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
N#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
N#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
N#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
N#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
N#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
N#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
N#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
N#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
N#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
N#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
N#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
N#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
N#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
N#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
N#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
N#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
N
N/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
N#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
N
N/******************  Bit definition for SDIO_FIFO register  *******************/
N#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                     Serial Peripheral Interface (SPI)                      */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
N
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
N
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
N#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
N#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
N#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
N#define  SPI_CR2_FRF                         ((uint8_t)0x08)               /*!< Frame format */
N#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
N#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
N#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
N#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
N#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
N#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
N#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
N#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
N
N#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
N#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
N
N#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
N
N#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
N#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
N#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
N#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       System Configuration (SYSCFG)                        */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for SYSCFG_MEMRMP register  ****************/
N#define SYSCFG_MEMRMP_MEM_MODE          ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_MEMRMP_MEM_MODE_0        ((uint32_t)0x00000001) /*!< Bit 0 */
N#define SYSCFG_MEMRMP_MEM_MODE_1        ((uint32_t)0x00000002) /*!< Bit 1 */
N#define SYSCFG_MEMRMP_BOOT_MODE         ((uint32_t)0x00000300) /*!< Boot mode Config */
N#define SYSCFG_MEMRMP_BOOT_MODE_0       ((uint32_t)0x00000100) /*!< Bit 0 */
N#define SYSCFG_MEMRMP_BOOT_MODE_1       ((uint32_t)0x00000200) /*!< Bit 1 */
N
N/*****************  Bit definition for SYSCFG_PMC register  *******************/
N#define SYSCFG_PMC_USB_PU               ((uint32_t)0x00000001) /*!< SYSCFG PMC */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
N
N/** 
N  * @brief  EXTI0 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PH         ((uint16_t)0x0005) /*!< PH[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0006) /*!< PF[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PG         ((uint16_t)0x0007) /*!< PG[0] pin */
N
N/** 
N  * @brief  EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PH         ((uint16_t)0x0050) /*!< PH[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0060) /*!< PF[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PG         ((uint16_t)0x0070) /*!< PG[1] pin */
N
N/** 
N  * @brief  EXTI2 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PH         ((uint16_t)0x0500) /*!< PH[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0600) /*!< PF[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PG         ((uint16_t)0x0700) /*!< PG[2] pin */
N
N/** 
N  * @brief  EXTI3 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x3000) /*!< PF[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PG         ((uint16_t)0x4000) /*!< PG[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
N#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
N
N/** 
N  * @brief  EXTI4 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0006) /*!< PF[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PG         ((uint16_t)0x0007) /*!< PG[4] pin */
N
N/** 
N  * @brief  EXTI5 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0060) /*!< PF[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PG         ((uint16_t)0x0070) /*!< PG[5] pin */
N
N/** 
N  * @brief  EXTI6 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0600) /*!< PF[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PG         ((uint16_t)0x0700) /*!< PG[6] pin */
N
N/** 
N  * @brief  EXTI7 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x6000) /*!< PF[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PG         ((uint16_t)0x7000) /*!< PG[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
N#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
N
N/** 
N  * @brief  EXTI8 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PF         ((uint16_t)0x0006) /*!< PF[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PG         ((uint16_t)0x0007) /*!< PG[8] pin */
N
N/** 
N  * @brief  EXTI9 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0060) /*!< PF[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PG         ((uint16_t)0x0070) /*!< PG[9] pin */
N
N/** 
N  * @brief  EXTI10 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0600) /*!< PF[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PG        ((uint16_t)0x0700) /*!< PG[10] pin */
N
N/** 
N  * @brief  EXTI11 configuration  
N  */ 
N#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!< PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PF        ((uint16_t)0x6000) /*!< PF[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PG        ((uint16_t)0x7000) /*!< PG[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
N#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
N
N/** 
N  * @brief  EXTI12 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!< PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PF        ((uint16_t)0x0006) /*!< PF[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PG        ((uint16_t)0x0007) /*!< PG[12] pin */
N
N/** 
N  * @brief  EXTI13 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!< PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PF        ((uint16_t)0x0060) /*!< PF[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PG        ((uint16_t)0x0070) /*!< PG[13] pin */
N
N/** 
N  * @brief  EXTI14 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PF        ((uint16_t)0x0600) /*!< PF[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PG        ((uint16_t)0x0700) /*!< PG[14] pin */
N
N/** 
N  * @brief  EXTI15 configuration  
N  */ 
N#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PF        ((uint16_t)0x6000) /*!< PF[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PG        ((uint16_t)0x7000) /*!< PG[15] pin */
N 
N/******************************************************************************/
N/*                                                                            */
N/*                       Routing Interface (RI)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for RI_ICR register  ********************/
N#define  RI_ICR_IC1Z                    ((uint32_t)0x0000000F) /*!< IC1Z[3:0] bits (Input Capture 1 select bits) */
N#define  RI_ICR_IC1Z_0                  ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_ICR_IC1Z_1                  ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_ICR_IC1Z_2                  ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_ICR_IC1Z_3                  ((uint32_t)0x00000008) /*!< Bit 3 */
N
N#define  RI_ICR_IC2Z                    ((uint32_t)0x000000F0) /*!< IC2Z[3:0] bits (Input Capture 2 select bits) */
N#define  RI_ICR_IC2Z_0                  ((uint32_t)0x00000010) /*!< Bit 0 */
N#define  RI_ICR_IC2Z_1                  ((uint32_t)0x00000020) /*!< Bit 1 */
N#define  RI_ICR_IC2Z_2                  ((uint32_t)0x00000040) /*!< Bit 2 */
N#define  RI_ICR_IC2Z_3                  ((uint32_t)0x00000080) /*!< Bit 3 */
N
N#define  RI_ICR_IC3Z                    ((uint32_t)0x00000F00) /*!< IC3Z[3:0] bits (Input Capture 3 select bits) */
N#define  RI_ICR_IC3Z_0                  ((uint32_t)0x00000100) /*!< Bit 0 */
N#define  RI_ICR_IC3Z_1                  ((uint32_t)0x00000200) /*!< Bit 1 */
N#define  RI_ICR_IC3Z_2                  ((uint32_t)0x00000400) /*!< Bit 2 */
N#define  RI_ICR_IC3Z_3                  ((uint32_t)0x00000800) /*!< Bit 3 */
N
N#define  RI_ICR_IC4Z                    ((uint32_t)0x0000F000) /*!< IC4Z[3:0] bits (Input Capture 4 select bits) */
N#define  RI_ICR_IC4Z_0                  ((uint32_t)0x00001000) /*!< Bit 0 */
N#define  RI_ICR_IC4Z_1                  ((uint32_t)0x00002000) /*!< Bit 1 */
N#define  RI_ICR_IC4Z_2                  ((uint32_t)0x00004000) /*!< Bit 2 */
N#define  RI_ICR_IC4Z_3                  ((uint32_t)0x00008000) /*!< Bit 3 */
N
N#define  RI_ICR_TIM                     ((uint32_t)0x00030000) /*!< TIM[3:0] bits (Timers select bits) */
N#define  RI_ICR_TIM_0                   ((uint32_t)0x00010000) /*!< Bit 0 */
N#define  RI_ICR_TIM_1                   ((uint32_t)0x00020000) /*!< Bit 1 */
N
N#define  RI_ICR_IC1                     ((uint32_t)0x00040000) /*!< Input capture 1 */
N#define  RI_ICR_IC2                     ((uint32_t)0x00080000) /*!< Input capture 2 */
N#define  RI_ICR_IC3                     ((uint32_t)0x00100000) /*!< Input capture 3 */
N#define  RI_ICR_IC4                     ((uint32_t)0x00200000) /*!< Input capture 4 */
N
N/********************  Bit definition for RI_ASCR1 register  ********************/
N#define  RI_ASCR1_CH                    ((uint32_t)0x03FCFFFF) /*!< AS_CH[25:18] & AS_CH[15:0] bits ( Analog switches selection bits) */
N#define  RI_ASCR1_CH_0                  ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_ASCR1_CH_1                  ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_ASCR1_CH_2                  ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_ASCR1_CH_3                  ((uint32_t)0x00000008) /*!< Bit 3 */
N#define  RI_ASCR1_CH_4                  ((uint32_t)0x00000010) /*!< Bit 4 */
N#define  RI_ASCR1_CH_5                  ((uint32_t)0x00000020) /*!< Bit 5 */
N#define  RI_ASCR1_CH_6                  ((uint32_t)0x00000040) /*!< Bit 6 */
N#define  RI_ASCR1_CH_7                  ((uint32_t)0x00000080) /*!< Bit 7 */
N#define  RI_ASCR1_CH_8                  ((uint32_t)0x00000100) /*!< Bit 8 */
N#define  RI_ASCR1_CH_9                  ((uint32_t)0x00000200) /*!< Bit 9 */
N#define  RI_ASCR1_CH_10                 ((uint32_t)0x00000400) /*!< Bit 10 */
N#define  RI_ASCR1_CH_11                 ((uint32_t)0x00000800) /*!< Bit 11 */
N#define  RI_ASCR1_CH_12                 ((uint32_t)0x00001000) /*!< Bit 12 */
N#define  RI_ASCR1_CH_13                 ((uint32_t)0x00002000) /*!< Bit 13 */
N#define  RI_ASCR1_CH_14                 ((uint32_t)0x00004000) /*!< Bit 14 */
N#define  RI_ASCR1_CH_15                 ((uint32_t)0x00008000) /*!< Bit 15 */
N#define  RI_ASCR1_CH_31                 ((uint32_t)0x00010000) /*!< Bit 16 */
N#define  RI_ASCR1_CH_18                 ((uint32_t)0x00040000) /*!< Bit 18 */
N#define  RI_ASCR1_CH_19                 ((uint32_t)0x00080000) /*!< Bit 19 */
N#define  RI_ASCR1_CH_20                 ((uint32_t)0x00100000) /*!< Bit 20 */
N#define  RI_ASCR1_CH_21                 ((uint32_t)0x00200000) /*!< Bit 21 */
N#define  RI_ASCR1_CH_22                 ((uint32_t)0x00400000) /*!< Bit 22 */
N#define  RI_ASCR1_CH_23                 ((uint32_t)0x00800000) /*!< Bit 23 */
N#define  RI_ASCR1_CH_24                 ((uint32_t)0x01000000) /*!< Bit 24 */
N#define  RI_ASCR1_CH_25                 ((uint32_t)0x02000000) /*!< Bit 25 */
N#define  RI_ASCR1_VCOMP                 ((uint32_t)0x04000000) /*!< ADC analog switch selection for internal node to COMP1 */
N#define  RI_ASCR1_CH_27                 ((uint32_t)0x00400000) /*!< Bit 27 */
N#define  RI_ASCR1_CH_28                 ((uint32_t)0x00800000) /*!< Bit 28 */
N#define  RI_ASCR1_CH_29                 ((uint32_t)0x01000000) /*!< Bit 29 */
N#define  RI_ASCR1_CH_30                 ((uint32_t)0x02000000) /*!< Bit 30 */
N#define  RI_ASCR1_SCM                   ((uint32_t)0x80000000) /*!< I/O Switch control mode */
N
N/********************  Bit definition for RI_ASCR2 register  ********************/
N#define  RI_ASCR2_GR10_1                ((uint32_t)0x00000001) /*!< GR10-1 selection bit */
N#define  RI_ASCR2_GR10_2                ((uint32_t)0x00000002) /*!< GR10-2 selection bit */
N#define  RI_ASCR2_GR10_3                ((uint32_t)0x00000004) /*!< GR10-3 selection bit */
N#define  RI_ASCR2_GR10_4                ((uint32_t)0x00000008) /*!< GR10-4 selection bit */
N#define  RI_ASCR2_GR6_1                 ((uint32_t)0x00000010) /*!< GR6-1 selection bit */
N#define  RI_ASCR2_GR6_2                 ((uint32_t)0x00000020) /*!< GR6-2 selection bit */
N#define  RI_ASCR2_GR5_1                 ((uint32_t)0x00000040) /*!< GR5-1 selection bit */
N#define  RI_ASCR2_GR5_2                 ((uint32_t)0x00000080) /*!< GR5-2 selection bit */
N#define  RI_ASCR2_GR5_3                 ((uint32_t)0x00000100) /*!< GR5-3 selection bit */
N#define  RI_ASCR2_GR4_1                 ((uint32_t)0x00000200) /*!< GR4-1 selection bit */
N#define  RI_ASCR2_GR4_2                 ((uint32_t)0x00000400) /*!< GR4-2 selection bit */
N#define  RI_ASCR2_GR4_3                 ((uint32_t)0x00000800) /*!< GR4-3 selection bit */
N#define  RI_ASCR2_GR4_4                 ((uint32_t)0x00008000) /*!< GR4-4 selection bit */
N#define  RI_ASCR2_CH0b                  ((uint32_t)0x00010000) /*!< CH0b selection bit */
N#define  RI_ASCR2_CH1b                  ((uint32_t)0x00020000) /*!< CH1b selection bit */
N#define  RI_ASCR2_CH2b                  ((uint32_t)0x00040000) /*!< CH2b selection bit */
N#define  RI_ASCR2_CH3b                  ((uint32_t)0x00080000) /*!< CH3b selection bit */
N#define  RI_ASCR2_CH6b                  ((uint32_t)0x00100000) /*!< CH6b selection bit */
N#define  RI_ASCR2_CH7b                  ((uint32_t)0x00200000) /*!< CH7b selection bit */
N#define  RI_ASCR2_CH8b                  ((uint32_t)0x00400000) /*!< CH8b selection bit */
N#define  RI_ASCR2_CH9b                  ((uint32_t)0x00800000) /*!< CH9b selection bit */
N#define  RI_ASCR2_CH10b                 ((uint32_t)0x01000000) /*!< CH10b selection bit */
N#define  RI_ASCR2_CH11b                 ((uint32_t)0x02000000) /*!< CH11b selection bit */
N#define  RI_ASCR2_CH12b                 ((uint32_t)0x04000000) /*!< CH12b selection bit */
N#define  RI_ASCR2_GR6_3                 ((uint32_t)0x08000000) /*!< GR6-3 selection bit */
N#define  RI_ASCR2_GR6_4                 ((uint32_t)0x10000000) /*!< GR6-4 selection bit */
N#define  RI_ASCR2_GR5_4                 ((uint32_t)0x20000000) /*!< GR5-4 selection bit */
N
N/********************  Bit definition for RI_HYSCR1 register  ********************/
N#define  RI_HYSCR1_PA                   ((uint32_t)0x0000FFFF) /*!< PA[15:0] Port A Hysteresis selection */
N#define  RI_HYSCR1_PA_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_HYSCR1_PA_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_HYSCR1_PA_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_HYSCR1_PA_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
N#define  RI_HYSCR1_PA_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
N#define  RI_HYSCR1_PA_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
N#define  RI_HYSCR1_PA_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
N#define  RI_HYSCR1_PA_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
N#define  RI_HYSCR1_PA_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
N#define  RI_HYSCR1_PA_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
N#define  RI_HYSCR1_PA_10                ((uint32_t)0x00000400) /*!< Bit 10 */
N#define  RI_HYSCR1_PA_11                ((uint32_t)0x00000800) /*!< Bit 11 */
N#define  RI_HYSCR1_PA_12                ((uint32_t)0x00001000) /*!< Bit 12 */
N#define  RI_HYSCR1_PA_13                ((uint32_t)0x00002000) /*!< Bit 13 */
N#define  RI_HYSCR1_PA_14                ((uint32_t)0x00004000) /*!< Bit 14 */
N#define  RI_HYSCR1_PA_15                ((uint32_t)0x00008000) /*!< Bit 15 */
N
N#define  RI_HYSCR1_PB                   ((uint32_t)0xFFFF0000) /*!< PB[15:0] Port B Hysteresis selection */
N#define  RI_HYSCR1_PB_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
N#define  RI_HYSCR1_PB_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
N#define  RI_HYSCR1_PB_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
N#define  RI_HYSCR1_PB_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
N#define  RI_HYSCR1_PB_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
N#define  RI_HYSCR1_PB_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
N#define  RI_HYSCR1_PB_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
N#define  RI_HYSCR1_PB_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
N#define  RI_HYSCR1_PB_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
N#define  RI_HYSCR1_PB_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
N#define  RI_HYSCR1_PB_10                ((uint32_t)0x04000000) /*!< Bit 10 */
N#define  RI_HYSCR1_PB_11                ((uint32_t)0x08000000) /*!< Bit 11 */
N#define  RI_HYSCR1_PB_12                ((uint32_t)0x10000000) /*!< Bit 12 */
N#define  RI_HYSCR1_PB_13                ((uint32_t)0x20000000) /*!< Bit 13 */
N#define  RI_HYSCR1_PB_14                ((uint32_t)0x40000000) /*!< Bit 14 */
N#define  RI_HYSCR1_PB_15                ((uint32_t)0x80000000) /*!< Bit 15 */
N
N/********************  Bit definition for RI_HYSCR2 register  ********************/
N#define  RI_HYSCR2_PC                   ((uint32_t)0x0000FFFF) /*!< PC[15:0] Port C Hysteresis selection */
N#define  RI_HYSCR2_PC_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_HYSCR2_PC_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_HYSCR2_PC_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_HYSCR2_PC_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
N#define  RI_HYSCR2_PC_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
N#define  RI_HYSCR2_PC_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
N#define  RI_HYSCR2_PC_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
N#define  RI_HYSCR2_PC_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
N#define  RI_HYSCR2_PC_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
N#define  RI_HYSCR2_PC_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
N#define  RI_HYSCR2_PC_10                ((uint32_t)0x00000400) /*!< Bit 10 */
N#define  RI_HYSCR2_PC_11                ((uint32_t)0x00000800) /*!< Bit 11 */
N#define  RI_HYSCR2_PC_12                ((uint32_t)0x00001000) /*!< Bit 12 */
N#define  RI_HYSCR2_PC_13                ((uint32_t)0x00002000) /*!< Bit 13 */
N#define  RI_HYSCR2_PC_14                ((uint32_t)0x00004000) /*!< Bit 14 */
N#define  RI_HYSCR2_PC_15                ((uint32_t)0x00008000) /*!< Bit 15 */
N
N#define  RI_HYSCR2_PD                   ((uint32_t)0xFFFF0000) /*!< PD[15:0] Port D Hysteresis selection */
N#define  RI_HYSCR2_PD_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
N#define  RI_HYSCR2_PD_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
N#define  RI_HYSCR2_PD_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
N#define  RI_HYSCR2_PD_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
N#define  RI_HYSCR2_PD_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
N#define  RI_HYSCR2_PD_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
N#define  RI_HYSCR2_PD_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
N#define  RI_HYSCR2_PD_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
N#define  RI_HYSCR2_PD_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
N#define  RI_HYSCR2_PD_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
N#define  RI_HYSCR2_PD_10                ((uint32_t)0x04000000) /*!< Bit 10 */
N#define  RI_HYSCR2_PD_11                ((uint32_t)0x08000000) /*!< Bit 11 */
N#define  RI_HYSCR2_PD_12                ((uint32_t)0x10000000) /*!< Bit 12 */
N#define  RI_HYSCR2_PD_13                ((uint32_t)0x20000000) /*!< Bit 13 */
N#define  RI_HYSCR2_PD_14                ((uint32_t)0x40000000) /*!< Bit 14 */
N#define  RI_HYSCR2_PD_15                ((uint32_t)0x80000000) /*!< Bit 15 */
N
N/********************  Bit definition for RI_HYSCR3 register  ********************/
N#define  RI_HYSCR2_PE                   ((uint32_t)0x0000FFFF) /*!< PE[15:0] Port E Hysteresis selection */
N#define  RI_HYSCR2_PE_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_HYSCR2_PE_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_HYSCR2_PE_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_HYSCR2_PE_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
N#define  RI_HYSCR2_PE_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
N#define  RI_HYSCR2_PE_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
N#define  RI_HYSCR2_PE_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
N#define  RI_HYSCR2_PE_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
N#define  RI_HYSCR2_PE_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
N#define  RI_HYSCR2_PE_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
N#define  RI_HYSCR2_PE_10                ((uint32_t)0x00000400) /*!< Bit 10 */
N#define  RI_HYSCR2_PE_11                ((uint32_t)0x00000800) /*!< Bit 11 */
N#define  RI_HYSCR2_PE_12                ((uint32_t)0x00001000) /*!< Bit 12 */
N#define  RI_HYSCR2_PE_13                ((uint32_t)0x00002000) /*!< Bit 13 */
N#define  RI_HYSCR2_PE_14                ((uint32_t)0x00004000) /*!< Bit 14 */
N#define  RI_HYSCR2_PE_15                ((uint32_t)0x00008000) /*!< Bit 15 */
N
N#define  RI_HYSCR3_PF                   ((uint32_t)0xFFFF0000) /*!< PF[15:0] Port F Hysteresis selection */
N#define  RI_HYSCR3_PF_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
N#define  RI_HYSCR3_PF_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
N#define  RI_HYSCR3_PF_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
N#define  RI_HYSCR3_PF_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
N#define  RI_HYSCR3_PF_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
N#define  RI_HYSCR3_PF_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
N#define  RI_HYSCR3_PF_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
N#define  RI_HYSCR3_PF_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
N#define  RI_HYSCR3_PF_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
N#define  RI_HYSCR3_PF_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
N#define  RI_HYSCR3_PF_10                ((uint32_t)0x04000000) /*!< Bit 10 */
N#define  RI_HYSCR3_PF_11                ((uint32_t)0x08000000) /*!< Bit 11 */
N#define  RI_HYSCR3_PF_12                ((uint32_t)0x10000000) /*!< Bit 12 */
N#define  RI_HYSCR3_PF_13                ((uint32_t)0x20000000) /*!< Bit 13 */
N#define  RI_HYSCR3_PF_14                ((uint32_t)0x40000000) /*!< Bit 14 */
N#define  RI_HYSCR3_PF_15                ((uint32_t)0x80000000) /*!< Bit 15 */
N
N/********************  Bit definition for RI_HYSCR4 register  ********************/
N#define  RI_HYSCR4_PG                   ((uint32_t)0x0000FFFF) /*!< PG[15:0] Port G Hysteresis selection */
N#define  RI_HYSCR4_PG_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
N#define  RI_HYSCR4_PG_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
N#define  RI_HYSCR4_PG_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
N#define  RI_HYSCR4_PG_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
N#define  RI_HYSCR4_PG_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
N#define  RI_HYSCR4_PG_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
N#define  RI_HYSCR4_PG_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
N#define  RI_HYSCR4_PG_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
N#define  RI_HYSCR4_PG_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
N#define  RI_HYSCR4_PG_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
N#define  RI_HYSCR4_PG_10                ((uint32_t)0x00000400) /*!< Bit 10 */
N#define  RI_HYSCR4_PG_11                ((uint32_t)0x00000800) /*!< Bit 11 */
N#define  RI_HYSCR4_PG_12                ((uint32_t)0x00001000) /*!< Bit 12 */
N#define  RI_HYSCR4_PG_13                ((uint32_t)0x00002000) /*!< Bit 13 */
N#define  RI_HYSCR4_PG_14                ((uint32_t)0x00004000) /*!< Bit 14 */
N#define  RI_HYSCR4_PG_15                ((uint32_t)0x00008000) /*!< Bit 15 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                               Timers (TIM)                                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N
N#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!<OCCS bits (OCref Clear Selection) */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
N                   
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
N#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
N           
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define  TIM_OR_TI1RMP                       ((uint16_t)0x0003)            /*!<Option register for TI1 Remapping */
N#define  TIM_OR_TI1RMP_0                     ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_OR_TI1RMP_1                     ((uint16_t)0x0002)            /*!<Bit 1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for USART_SR register  *******************/
N#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
N#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
N#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
N#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
N#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
N#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
N#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
N#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
N#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
N#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
N
N/*******************  Bit definition for USART_DR register  *******************/
N#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
N#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
N#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
N#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
N#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
N#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
N#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
N#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
N#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
N#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
N#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
N#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
N#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< Oversampling by 8-bit mode */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
N#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
N#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
N#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
N#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
N#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
N
N#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
N
N#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
N#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
N#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
N#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
N#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
N#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
N#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
N#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
N#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
N#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
N#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
N#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One sample bit method enable */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
N#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
N
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                     Universal Serial Bus (USB)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*!<Endpoint-specific registers */
N/*******************  Bit definition for USB_EP0R register  *******************/
N#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP1R register  *******************/
N#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP2R register  *******************/
N#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP3R register  *******************/
N#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP4R register  *******************/
N#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP5R register  *******************/
N#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP6R register  *******************/
N#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*******************  Bit definition for USB_EP7R register  *******************/
N#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
N
N#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
N#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
N
N#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
N#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
N#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
N
N#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
N#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
N#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
N
N#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
N
N#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
N#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
N#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
N
N/*!<Common registers */
N/*******************  Bit definition for USB_CNTR register  *******************/
N#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!<Force USB Reset */
N#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!<Power down */
N#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!<Low-power mode */
N#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!<Force suspend */
N#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!<Resume request */
N#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!<Expected Start Of Frame Interrupt Mask */
N#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!<Start Of Frame Interrupt Mask */
N#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!<RESET Interrupt Mask */
N#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!<Suspend mode Interrupt Mask */
N#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!<Wakeup Interrupt Mask */
N#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!<Error Interrupt Mask */
N#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!<Packet Memory Area Over / Underrun Interrupt Mask */
N#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!<Correct Transfer Interrupt Mask */
N
N/*******************  Bit definition for USB_ISTR register  *******************/
N#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!<Endpoint Identifier */
N#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!<Direction of transaction */
N#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!<Expected Start Of Frame */
N#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!<Start Of Frame */
N#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!<USB RESET request */
N#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!<Suspend mode request */
N#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!<Wake up */
N#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!<Error */
N#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!<Packet Memory Area Over / Underrun */
N#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!<Correct Transfer */
N
N/*******************  Bit definition for USB_FNR register  ********************/
N#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!<Frame Number */
N#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!<Lost SOF */
N#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!<Locked */
N#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!<Receive Data - Line Status */
N#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!<Receive Data + Line Status */
N
N/******************  Bit definition for USB_DADDR register  *******************/
N#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!<ADD[6:0] bits (Device Address) */
N#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!<Bit 0 */
N#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!<Bit 1 */
N#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!<Bit 2 */
N#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!<Bit 3 */
N#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!<Bit 4 */
N#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!<Bit 5 */
N#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!<Bit 6 */
N
N#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!<Enable Function */
N
N/******************  Bit definition for USB_BTABLE register  ******************/    
N#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!<Buffer Table */
N
N/*!< Buffer descriptor table */
N/*****************  Bit definition for USB_ADDR0_TX register  *****************/
N#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
N
N/*****************  Bit definition for USB_ADDR1_TX register  *****************/
N#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
N
N/*****************  Bit definition for USB_ADDR2_TX register  *****************/
N#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
N
N/*****************  Bit definition for USB_ADDR3_TX register  *****************/
N#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
N
N/*****************  Bit definition for USB_ADDR4_TX register  *****************/
N#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
N
N/*****************  Bit definition for USB_ADDR5_TX register  *****************/
N#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
N
N/*****************  Bit definition for USB_ADDR6_TX register  *****************/
N#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
N
N/*****************  Bit definition for USB_ADDR7_TX register  *****************/
N#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_COUNT0_TX register  ****************/
N#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
N
N/*****************  Bit definition for USB_COUNT1_TX register  ****************/
N#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
N
N/*****************  Bit definition for USB_COUNT2_TX register  ****************/
N#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
N
N/*****************  Bit definition for USB_COUNT3_TX register  ****************/
N#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
N
N/*****************  Bit definition for USB_COUNT4_TX register  ****************/
N#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
N
N/*****************  Bit definition for USB_COUNT5_TX register  ****************/
N#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
N
N/*****************  Bit definition for USB_COUNT6_TX register  ****************/
N#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
N
N/*****************  Bit definition for USB_COUNT7_TX register  ****************/
N#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
N#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
N
N/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
N#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
N
N/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
N#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
N
N/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
N#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
N
N/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
N#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
N
N/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
N#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
N
N/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
N#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
N
N/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
N#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
N
N/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
N#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
N
N/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
N#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
N
N/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
N#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
N
N/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
N#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
N
N/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
N#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
N
N/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
N#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
N
N/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
N#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
N
N/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
N#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_ADDR0_RX register  *****************/
N#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
N
N/*****************  Bit definition for USB_ADDR1_RX register  *****************/
N#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
N
N/*****************  Bit definition for USB_ADDR2_RX register  *****************/
N#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
N
N/*****************  Bit definition for USB_ADDR3_RX register  *****************/
N#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
N
N/*****************  Bit definition for USB_ADDR4_RX register  *****************/
N#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
N
N/*****************  Bit definition for USB_ADDR5_RX register  *****************/
N#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
N
N/*****************  Bit definition for USB_ADDR6_RX register  *****************/
N#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
N
N/*****************  Bit definition for USB_ADDR7_RX register  *****************/
N#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
N
N/*----------------------------------------------------------------------------*/
N
N/*****************  Bit definition for USB_COUNT0_RX register  ****************/
N#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT1_RX register  ****************/
N#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT2_RX register  ****************/
N#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT3_RX register  ****************/
N#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT4_RX register  ****************/
N#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT5_RX register  ****************/
N#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT6_RX register  ****************/
N#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*****************  Bit definition for USB_COUNT7_RX register  ****************/
N#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
N
N#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
N#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
N#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
N#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
N#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
N#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
N
N/*----------------------------------------------------------------------------*/
N
N/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
N#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
N#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
N#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
N#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
N#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
N#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
N#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
N#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
N#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
N#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
N#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
N#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
N#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
N#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
N#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
N
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
N
N/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
N#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
N
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
N#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
N
N#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Window WATCHDOG (WWDG)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
N#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
N#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
N#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
N#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
N#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
N#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
N#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        SystemTick (SysTick)                                */
N/*                                                                            */
N/******************************************************************************/
N
N/*****************  Bit definition for SysTick_CTRL register  *****************/
N#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
N#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
N#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
N#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
N
N/*****************  Bit definition for SysTick_LOAD register  *****************/
N#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
N
N/*****************  Bit definition for SysTick_VAL register  ******************/
N#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
N
N/*****************  Bit definition for SysTick_CALIB register  ****************/
N#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
N#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
N#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
N
N/******************************************************************************/
N/*                                                                            */
N/*               Nested Vectored Interrupt Controller (NVIC)                  */
N/*                                                                            */
N/******************************************************************************/
N
N/******************  Bit definition for NVIC_ISER register  *******************/
N#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
N#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ICER register  *******************/
N#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
N#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ISPR register  *******************/
N#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
N#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_ICPR register  *******************/
N#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
N#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_IABR register  *******************/
N#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
N#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
N#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
N#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
N#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
N#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
N#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
N#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
N#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
N#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
N#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
N#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
N#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
N#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
N#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
N#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
N#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
N#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
N#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
N#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
N#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
N#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
N#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
N#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
N#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
N#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
N#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
N#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
N#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
N#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
N#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
N#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
N#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
N
N/******************  Bit definition for NVIC_PRI0 register  *******************/
N#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
N#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
N#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
N#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
N
N/******************  Bit definition for NVIC_PRI1 register  *******************/
N#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
N#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
N#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
N#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
N
N/******************  Bit definition for NVIC_PRI2 register  *******************/
N#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
N#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
N#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
N#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
N
N/******************  Bit definition for NVIC_PRI3 register  *******************/
N#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
N#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
N#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
N#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
N
N/******************  Bit definition for NVIC_PRI4 register  *******************/
N#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
N#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
N#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
N#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
N
N/******************  Bit definition for NVIC_PRI5 register  *******************/
N#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
N#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
N#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
N#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
N
N/******************  Bit definition for NVIC_PRI6 register  *******************/
N#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
N#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
N#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
N#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
N
N/******************  Bit definition for NVIC_PRI7 register  *******************/
N#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
N#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
N#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
N#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
N
N/******************  Bit definition for SCB_CPUID register  *******************/
N#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
N#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
N#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
N#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
N#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
N
N/*******************  Bit definition for SCB_ICSR register  *******************/
N#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
N#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
N#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
N#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
N#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
N#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
N#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
N#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
N#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
N#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
N
N/*******************  Bit definition for SCB_VTOR register  *******************/
N#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
N#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
N
N/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
N#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
N#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
N#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
N
N#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
N#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
N
N/* prority group configuration */
N#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
N#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
N#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
N
N#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
N#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
N
N/*******************  Bit definition for SCB_SCR register  ********************/
N#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
N#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
N#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
N
N/********************  Bit definition for SCB_CCR register  *******************/
N#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
N#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
N#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
N#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
N#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
N#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
N
N/*******************  Bit definition for SCB_SHPR register ********************/
N#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
N#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
N#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
N#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
N
N/******************  Bit definition for SCB_SHCSR register  *******************/
N#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
N#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
N#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
N#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
N#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
N#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
N#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
N#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
N#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
N#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
N#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
N#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
N#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
N#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
N
N/*******************  Bit definition for SCB_CFSR register  *******************/
N/*!< MFSR */
N#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
N#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
N#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
N#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
N#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
N/*!< BFSR */
N#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
N#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
N#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
N#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
N#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
N#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
N/*!< UFSR */
N#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to excecute an undefined instruction */
N#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
N#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
N#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
N#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
N#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
N
N/*******************  Bit definition for SCB_HFSR register  *******************/
N#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occures because of vector table read on exception processing */
N#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
N#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
N
N/*******************  Bit definition for SCB_DFSR register  *******************/
N#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
N#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
N#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
N#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
N#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
N
N/*******************  Bit definition for SCB_MMFAR register  ******************/
N#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
N
N/*******************  Bit definition for SCB_BFAR register  *******************/
N#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
N
N/*******************  Bit definition for SCB_afsr register  *******************/
N#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */ 
N
N#ifdef USE_STDPERIPH_DRIVER
N  #include "stm32l1xx_conf.h"
L 1 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    Project/STM32L1xx_StdPeriph_Templates/stm32l1xx_conf.h 
N  * @author  MCD Application Team
N  * @version V1.1.1
N  * @date    13-April-2012
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_CONF_H
N#define __STM32L1xx_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */
N#include "stm32l1xx_adc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_adc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the ADC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_ADC_H
S#define __STM32L1xx_ADC_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32l1xx.h"
S
S/** @addtogroup STM32L1xx_StdPeriph_Driver
S  * @{
S  */
S
S/** @addtogroup ADC
S  * @{
S  */
S
S/* Exported types ------------------------------------------------------------*/
S
S/** 
S  * @brief  ADC Init structure definition  
S  */
S  
Stypedef struct
S{
S  uint32_t ADC_Resolution;                /*!< Selects the resolution of the conversion.
S                                               This parameter can be a value of @ref ADC_Resolution */
S  
S  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in
S                                               Scan (multichannel) or Single (one channel) mode.
S                                               This parameter can be set to ENABLE or DISABLE */
S  
S  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in
S                                               Continuous or Single mode.
S                                               This parameter can be set to ENABLE or DISABLE. */
S  
S  uint32_t ADC_ExternalTrigConvEdge;      /*!< Selects the external trigger Edge and enables the
S                                               trigger of a regular group. This parameter can be a value
S                                               of @ref ADC_external_trigger_edge_for_regular_channels_conversion */
S  
S  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog
S                                               to digital conversion of regular channels. This parameter
S                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
S  
S  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.
S                                               This parameter can be a value of @ref ADC_data_align */
S  
S  uint8_t  ADC_NbrOfConversion;           /*!< Specifies the number of ADC conversions that will be done
S                                               using the sequencer for regular channel group.
S                                               This parameter must range from 1 to 27. */
S}ADC_InitTypeDef;
S
Stypedef struct 
S{                                              
S  uint32_t ADC_Prescaler;                 /*!< Selects the ADC prescaler.
S                                               This parameter can be a value 
S                                               of @ref ADC_Prescaler */
S}ADC_CommonInitTypeDef;
S
S/* Exported constants --------------------------------------------------------*/
S
S/** @defgroup ADC_Exported_Constants
S  * @{
S  */ 
S#define IS_ADC_ALL_PERIPH(PERIPH)                  ((PERIPH) == ADC1)
S#define IS_ADC_DMA_PERIPH(PERIPH)                  ((PERIPH) == ADC1)
S
S/** @defgroup ADC_Power_down_during_Idle_and_or_Delay_phase 
S  * @{
S  */ 
S#define ADC_PowerDown_Delay                        ((uint32_t)0x00010000)
S#define ADC_PowerDown_Idle                         ((uint32_t)0x00020000)
S#define ADC_PowerDown_Idle_Delay                   ((uint32_t)0x00030000)
S
S#define IS_ADC_POWER_DOWN(DWON) (((DWON) == ADC_PowerDown_Delay) || \
S                                 ((DWON) == ADC_PowerDown_Idle) || \
S                                 ((DWON) == ADC_PowerDown_Idle_Delay))
X#define IS_ADC_POWER_DOWN(DWON) (((DWON) == ADC_PowerDown_Delay) ||                                  ((DWON) == ADC_PowerDown_Idle) ||                                  ((DWON) == ADC_PowerDown_Idle_Delay))
S/**
S  * @}
S  */ 
S
S
S/** @defgroup ADC_Prescaler 
S  * @{
S  */ 
S#define ADC_Prescaler_Div1                         ((uint32_t)0x00000000)
S#define ADC_Prescaler_Div2                         ((uint32_t)0x00010000)
S#define ADC_Prescaler_Div4                         ((uint32_t)0x00020000)
S
S#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div1) || \
S                                     ((PRESCALER) == ADC_Prescaler_Div2) || \
S                                     ((PRESCALER) == ADC_Prescaler_Div4))
X#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div1) ||                                      ((PRESCALER) == ADC_Prescaler_Div2) ||                                      ((PRESCALER) == ADC_Prescaler_Div4))
S/**
S  * @}
S  */ 
S
S
S
S/** @defgroup ADC_Resolution 
S  * @{
S  */ 
S#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
S#define ADC_Resolution_10b                         ((uint32_t)0x01000000)
S#define ADC_Resolution_8b                          ((uint32_t)0x02000000)
S#define ADC_Resolution_6b                          ((uint32_t)0x03000000)
S
S#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
S                                       ((RESOLUTION) == ADC_Resolution_10b) || \
S                                       ((RESOLUTION) == ADC_Resolution_8b) || \
S                                       ((RESOLUTION) == ADC_Resolution_6b))
X#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) ||                                        ((RESOLUTION) == ADC_Resolution_10b) ||                                        ((RESOLUTION) == ADC_Resolution_8b) ||                                        ((RESOLUTION) == ADC_Resolution_6b))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_external_trigger_edge_for_regular_channels_conversion 
S  * @{
S  */ 
S#define ADC_ExternalTrigConvEdge_None              ((uint32_t)0x00000000)
S#define ADC_ExternalTrigConvEdge_Rising            ((uint32_t)0x10000000)
S#define ADC_ExternalTrigConvEdge_Falling           ((uint32_t)0x20000000)
S#define ADC_ExternalTrigConvEdge_RisingFalling     ((uint32_t)0x30000000)
S
S#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
S                                    ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
S                                    ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
S                                    ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
X#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Rising) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Falling) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion
S  * @{
S  */ 
S
S/* TIM2 */
S#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x02000000)
S#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x03000000)
S#define ADC_ExternalTrigConv_T2_TRGO               ((uint32_t)0x06000000)
S
S/* TIM3 */
S#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x07000000)
S#define ADC_ExternalTrigConv_T3_CC3                ((uint32_t)0x08000000)
S#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x04000000)
S
S/* TIM4 */
S#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x05000000)
S#define ADC_ExternalTrigConv_T4_TRGO               ((uint32_t)0x09000000)
S
S/* TIM6 */
S#define ADC_ExternalTrigConv_T6_TRGO               ((uint32_t)0x0A000000)
S
S/* TIM9 */
S#define ADC_ExternalTrigConv_T9_CC2                ((uint32_t)0x00000000)
S#define ADC_ExternalTrigConv_T9_TRGO               ((uint32_t)0x01000000)
S
S/* EXTI */
S#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x0F000000)
S
S#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T9_CC2)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T9_TRGO) || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC3)  || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_TRGO) || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_T6_TRGO) || \
S                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T9_CC2)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T9_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC3)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T6_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_data_align 
S  * @{
S  */ 
S  
S#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
S#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
S
S#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
S                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_channels 
S  * @{
S  */ 
S/* ADC Bank A Channels -------------------------------------------------------*/  
S#define ADC_Channel_0                              ((uint8_t)0x00)
S#define ADC_Channel_1                              ((uint8_t)0x01)
S#define ADC_Channel_2                              ((uint8_t)0x02)
S#define ADC_Channel_3                              ((uint8_t)0x03)
S
S#define ADC_Channel_6                              ((uint8_t)0x06)
S#define ADC_Channel_7                              ((uint8_t)0x07)
S#define ADC_Channel_8                              ((uint8_t)0x08)
S#define ADC_Channel_9                              ((uint8_t)0x09)
S#define ADC_Channel_10                             ((uint8_t)0x0A)
S#define ADC_Channel_11                             ((uint8_t)0x0B)
S#define ADC_Channel_12                             ((uint8_t)0x0C)
S
S
S/* ADC Bank B Channels -------------------------------------------------------*/  
S#define ADC_Channel_0b                             ADC_Channel_0
S#define ADC_Channel_1b                             ADC_Channel_1
S#define ADC_Channel_2b                             ADC_Channel_2
S#define ADC_Channel_3b                             ADC_Channel_3
S
S#define ADC_Channel_6b                             ADC_Channel_6
S#define ADC_Channel_7b                             ADC_Channel_7
S#define ADC_Channel_8b                             ADC_Channel_8
S#define ADC_Channel_9b                             ADC_Channel_9
S#define ADC_Channel_10b                            ADC_Channel_10
S#define ADC_Channel_11b                            ADC_Channel_11
S#define ADC_Channel_12b                            ADC_Channel_12
S
S/* ADC Common Channels (ADC Bank A and B) ------------------------------------*/
S#define ADC_Channel_4                              ((uint8_t)0x04)
S#define ADC_Channel_5                              ((uint8_t)0x05)
S
S#define ADC_Channel_13                             ((uint8_t)0x0D)
S#define ADC_Channel_14                             ((uint8_t)0x0E)
S#define ADC_Channel_15                             ((uint8_t)0x0F)
S#define ADC_Channel_16                             ((uint8_t)0x10)
S#define ADC_Channel_17                             ((uint8_t)0x11)
S#define ADC_Channel_18                             ((uint8_t)0x12)
S#define ADC_Channel_19                             ((uint8_t)0x13)
S#define ADC_Channel_20                             ((uint8_t)0x14)
S#define ADC_Channel_21                             ((uint8_t)0x15)
S#define ADC_Channel_22                             ((uint8_t)0x16)
S#define ADC_Channel_23                             ((uint8_t)0x17)
S#define ADC_Channel_24                             ((uint8_t)0x18)
S#define ADC_Channel_25                             ((uint8_t)0x19)
S
S#define ADC_Channel_27                             ((uint8_t)0x1B)
S#define ADC_Channel_28                             ((uint8_t)0x1C)
S#define ADC_Channel_29                             ((uint8_t)0x1D)
S#define ADC_Channel_30                             ((uint8_t)0x1E)
S#define ADC_Channel_31                             ((uint8_t)0x1F)
S
S#define ADC_Channel_TempSensor                     ((uint8_t)ADC_Channel_16)
S#define ADC_Channel_Vrefint                        ((uint8_t)ADC_Channel_17)
S
S#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  || ((CHANNEL) == ADC_Channel_1)  || \
S                                 ((CHANNEL) == ADC_Channel_2)  || ((CHANNEL) == ADC_Channel_3)  || \
S                                 ((CHANNEL) == ADC_Channel_4)  || ((CHANNEL) == ADC_Channel_5)  || \
S                                 ((CHANNEL) == ADC_Channel_6)  || ((CHANNEL) == ADC_Channel_7)  || \
S                                 ((CHANNEL) == ADC_Channel_8)  || ((CHANNEL) == ADC_Channel_9)  || \
S                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
S                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
S                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
S                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17) || \
S                                 ((CHANNEL) == ADC_Channel_18) || ((CHANNEL) == ADC_Channel_19) || \
S                                 ((CHANNEL) == ADC_Channel_20) || ((CHANNEL) == ADC_Channel_21) || \
S                                 ((CHANNEL) == ADC_Channel_22) || ((CHANNEL) == ADC_Channel_23) || \
S                                 ((CHANNEL) == ADC_Channel_24) || ((CHANNEL) == ADC_Channel_25) || \
S                                 ((CHANNEL) == ADC_Channel_27) || ((CHANNEL) == ADC_Channel_28) || \
S                                 ((CHANNEL) == ADC_Channel_29) || ((CHANNEL) == ADC_Channel_30) || \
S                                 ((CHANNEL) == ADC_Channel_31))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  || ((CHANNEL) == ADC_Channel_1)  ||                                  ((CHANNEL) == ADC_Channel_2)  || ((CHANNEL) == ADC_Channel_3)  ||                                  ((CHANNEL) == ADC_Channel_4)  || ((CHANNEL) == ADC_Channel_5)  ||                                  ((CHANNEL) == ADC_Channel_6)  || ((CHANNEL) == ADC_Channel_7)  ||                                  ((CHANNEL) == ADC_Channel_8)  || ((CHANNEL) == ADC_Channel_9)  ||                                  ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17) ||                                  ((CHANNEL) == ADC_Channel_18) || ((CHANNEL) == ADC_Channel_19) ||                                  ((CHANNEL) == ADC_Channel_20) || ((CHANNEL) == ADC_Channel_21) ||                                  ((CHANNEL) == ADC_Channel_22) || ((CHANNEL) == ADC_Channel_23) ||                                  ((CHANNEL) == ADC_Channel_24) || ((CHANNEL) == ADC_Channel_25) ||                                  ((CHANNEL) == ADC_Channel_27) || ((CHANNEL) == ADC_Channel_28) ||                                  ((CHANNEL) == ADC_Channel_29) || ((CHANNEL) == ADC_Channel_30) ||                                  ((CHANNEL) == ADC_Channel_31))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_sampling_times 
S  * @{
S  */ 
S
S#define ADC_SampleTime_4Cycles                     ((uint8_t)0x00)
S#define ADC_SampleTime_9Cycles                     ((uint8_t)0x01)
S#define ADC_SampleTime_16Cycles                    ((uint8_t)0x02)
S#define ADC_SampleTime_24Cycles                    ((uint8_t)0x03)
S#define ADC_SampleTime_48Cycles                    ((uint8_t)0x04)
S#define ADC_SampleTime_96Cycles                    ((uint8_t)0x05)
S#define ADC_SampleTime_192Cycles                   ((uint8_t)0x06)
S#define ADC_SampleTime_384Cycles                   ((uint8_t)0x07)
S
S#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_4Cycles)   || \
S                                  ((TIME) == ADC_SampleTime_9Cycles)   || \
S                                  ((TIME) == ADC_SampleTime_16Cycles)  || \
S                                  ((TIME) == ADC_SampleTime_24Cycles)  || \
S                                  ((TIME) == ADC_SampleTime_48Cycles)  || \
S                                  ((TIME) == ADC_SampleTime_96Cycles)  || \
S                                  ((TIME) == ADC_SampleTime_192Cycles) || \
S                                  ((TIME) == ADC_SampleTime_384Cycles))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_4Cycles)   ||                                   ((TIME) == ADC_SampleTime_9Cycles)   ||                                   ((TIME) == ADC_SampleTime_16Cycles)  ||                                   ((TIME) == ADC_SampleTime_24Cycles)  ||                                   ((TIME) == ADC_SampleTime_48Cycles)  ||                                   ((TIME) == ADC_SampleTime_96Cycles)  ||                                   ((TIME) == ADC_SampleTime_192Cycles) ||                                   ((TIME) == ADC_SampleTime_384Cycles))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_Delay_length 
S  * @{
S  */ 
S
S#define ADC_DelayLength_None                       ((uint8_t)0x00)
S#define ADC_DelayLength_Freeze                     ((uint8_t)0x10)
S#define ADC_DelayLength_7Cycles                    ((uint8_t)0x20)
S#define ADC_DelayLength_15Cycles                   ((uint8_t)0x30)
S#define ADC_DelayLength_31Cycles                   ((uint8_t)0x40)
S#define ADC_DelayLength_63Cycles                   ((uint8_t)0x50)
S#define ADC_DelayLength_127Cycles                  ((uint8_t)0x60)
S#define ADC_DelayLength_255Cycles                  ((uint8_t)0x70)
S
S#define IS_ADC_DELAY_LENGTH(LENGTH) (((LENGTH) == ADC_DelayLength_None)      || \
S                                     ((LENGTH) == ADC_DelayLength_Freeze)    || \
S                                     ((LENGTH) == ADC_DelayLength_7Cycles)   || \
S                                     ((LENGTH) == ADC_DelayLength_15Cycles)  || \
S                                     ((LENGTH) == ADC_DelayLength_31Cycles)  || \
S                                     ((LENGTH) == ADC_DelayLength_63Cycles)  || \
S                                     ((LENGTH) == ADC_DelayLength_127Cycles) || \
S                                     ((LENGTH) == ADC_DelayLength_255Cycles))
X#define IS_ADC_DELAY_LENGTH(LENGTH) (((LENGTH) == ADC_DelayLength_None)      ||                                      ((LENGTH) == ADC_DelayLength_Freeze)    ||                                      ((LENGTH) == ADC_DelayLength_7Cycles)   ||                                      ((LENGTH) == ADC_DelayLength_15Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_31Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_63Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_127Cycles) ||                                      ((LENGTH) == ADC_DelayLength_255Cycles))
S
S/**
S  * @}
S  */
S
S/** @defgroup ADC_external_trigger_edge_for_injected_channels_conversion 
S  * @{
S  */ 
S#define ADC_ExternalTrigInjecConvEdge_None          ((uint32_t)0x00000000)
S#define ADC_ExternalTrigInjecConvEdge_Rising        ((uint32_t)0x00100000)
S#define ADC_ExternalTrigInjecConvEdge_Falling       ((uint32_t)0x00200000)
S#define ADC_ExternalTrigInjecConvEdge_RisingFalling ((uint32_t)0x00300000)
S
S#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None)    || \
S                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising)  || \
S                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) || \
S                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
X#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None)    ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising)  ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
S/**
S  * @}
S  */ 
S
S
S/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion 
S  * @{
S  */ 
S
S
S/* TIM2 */
S#define ADC_ExternalTrigInjecConv_T2_TRGO          ((uint32_t)0x00020000)
S#define ADC_ExternalTrigInjecConv_T2_CC1           ((uint32_t)0x00030000)
S
S/* TIM3 */
S#define ADC_ExternalTrigInjecConv_T3_CC4           ((uint32_t)0x00040000)
S
S/* TIM4 */
S#define ADC_ExternalTrigInjecConv_T4_TRGO          ((uint32_t)0x00050000)
S#define ADC_ExternalTrigInjecConv_T4_CC1           ((uint32_t)0x00060000)
S#define ADC_ExternalTrigInjecConv_T4_CC2           ((uint32_t)0x00070000)
S#define ADC_ExternalTrigInjecConv_T4_CC3           ((uint32_t)0x00080000)
S
S/* TIM7 */
S#define ADC_ExternalTrigInjecConv_T7_TRGO          ((uint32_t)0x000A0000)
S
S/* TIM9 */
S#define ADC_ExternalTrigInjecConv_T9_CC1           ((uint32_t)0x00000000)
S#define ADC_ExternalTrigInjecConv_T9_TRGO          ((uint32_t)0x00010000)
S
S/* TIM10 */
S#define ADC_ExternalTrigInjecConv_T10_CC1          ((uint32_t)0x00090000)
S
S/* EXTI */
S#define ADC_ExternalTrigInjecConv_Ext_IT15         ((uint32_t)0x000F0000)
S
S#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T9_CC1)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T9_TRGO) || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3)  || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T10_CC1) || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T7_TRGO) || \
S                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T9_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T9_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T10_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T7_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_injected_channel_selection 
S  * @{
S  */ 
S#define ADC_InjectedChannel_1                      ((uint8_t)0x18)
S#define ADC_InjectedChannel_2                      ((uint8_t)0x1C)
S#define ADC_InjectedChannel_3                      ((uint8_t)0x20)
S#define ADC_InjectedChannel_4                      ((uint8_t)0x24)
S
S#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
S                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
S                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
S                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_analog_watchdog_selection 
S  * @{
S  */ 
S  
S#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
S#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
S#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200) 
S#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
S#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
S#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
S#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
S
S#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable)        || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable)      || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable)           || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable)         || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable)   || \
S                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable)        ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable)      ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable)           ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable)         ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable)   ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_interrupts_definition 
S  * @{
S  */ 
S  
S#define ADC_IT_AWD                                 ((uint16_t)0x0106) 
S#define ADC_IT_EOC                                 ((uint16_t)0x0205) 
S#define ADC_IT_JEOC                                ((uint16_t)0x0407)  
S#define ADC_IT_OVR                                 ((uint16_t)0x201A) 
S 
S#define IS_ADC_IT(IT) (((IT) == ADC_IT_AWD) || ((IT) == ADC_IT_EOC) || \
S                       ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
X#define IS_ADC_IT(IT) (((IT) == ADC_IT_AWD) || ((IT) == ADC_IT_EOC) ||                        ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_flags_definition 
S  * @{
S  */ 
S  
S#define ADC_FLAG_AWD                               ((uint16_t)0x0001)
S#define ADC_FLAG_EOC                               ((uint16_t)0x0002)
S#define ADC_FLAG_JEOC                              ((uint16_t)0x0004)
S#define ADC_FLAG_JSTRT                             ((uint16_t)0x0008)
S#define ADC_FLAG_STRT                              ((uint16_t)0x0010)
S#define ADC_FLAG_OVR                               ((uint16_t)0x0020)
S#define ADC_FLAG_ADONS                             ((uint16_t)0x0040)
S#define ADC_FLAG_RCNR                              ((uint16_t)0x0100)
S#define ADC_FLAG_JCNR                              ((uint16_t)0x0200) 
S  
S#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFC0) == 0x00) && ((FLAG) != 0x00))
S   
S#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD)   || ((FLAG) == ADC_FLAG_EOC)  || \
S                               ((FLAG) == ADC_FLAG_JEOC)  || ((FLAG)== ADC_FLAG_JSTRT) || \
S                               ((FLAG) == ADC_FLAG_STRT)  || ((FLAG)== ADC_FLAG_OVR)   || \
S                               ((FLAG) == ADC_FLAG_ADONS) || ((FLAG)== ADC_FLAG_RCNR)  || \
S                               ((FLAG) == ADC_FLAG_JCNR))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD)   || ((FLAG) == ADC_FLAG_EOC)  ||                                ((FLAG) == ADC_FLAG_JEOC)  || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT)  || ((FLAG)== ADC_FLAG_OVR)   ||                                ((FLAG) == ADC_FLAG_ADONS) || ((FLAG)== ADC_FLAG_RCNR)  ||                                ((FLAG) == ADC_FLAG_JCNR))
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_thresholds 
S  * @{
S  */ 
S  
S#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_injected_offset 
S  * @{
S  */
S   
S#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_injected_length 
S  * @{
S  */
S   
S#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_injected_rank 
S  * @{
S  */ 
S  
S#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_regular_length 
S  * @{
S  */
S   
S#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 1) && ((LENGTH) <= 28))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_regular_rank 
S  * @{
S  */ 
S  
S#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 1) && ((RANK) <= 28))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_regular_discontinuous_mode_number 
S  * @{
S  */
S   
S#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup ADC_Bank_Selection 
S  * @{
S  */ 
S#define ADC_Bank_A                                 ((uint8_t)0x00)
S#define ADC_Bank_B                                 ((uint8_t)0x01)  
S#define IS_ADC_BANK(BANK) (((BANK) == ADC_Bank_A)   || ((BANK) == ADC_Bank_B))
S
S/**
S  * @}
S  */ 
S
S/**
S  * @}
S  */ 
S
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions ------------------------------------------------------- */ 
S
S/*  Function used to set the ADC configuration to the default reset state *****/   
Svoid ADC_DeInit(ADC_TypeDef* ADCx); 
S
S/* Initialization and Configuration functions *********************************/ 
Svoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Svoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Svoid ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Svoid ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Svoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Svoid ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank);
S
S/* Power saving functions *****************************************************/
Svoid ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState);
Svoid ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength);
S
S/* Analog Watchdog configuration functions ************************************/
Svoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
Svoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
Svoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
S
S/* Temperature Sensor & Vrefint (Voltage Reference internal) management function */
Svoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
S
S/* Regular Channels Configuration functions ***********************************/
Svoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Svoid ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
SFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Svoid ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Svoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Svoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
Svoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Suint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
S
S/* Regular Channels DMA Configuration functions *******************************/
Svoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Svoid ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
S
S/* Injected channels Configuration functions **********************************/
Svoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Svoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
Svoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
Svoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
Svoid ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge);
Svoid ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx);
SFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Svoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Svoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Suint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
S
S/* Interrupts and flags management functions **********************************/
Svoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
SFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG);
Svoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG);
SITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
Svoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /*__STM32L1xx_ADC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 35 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_aes.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_aes.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_aes.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the AES firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_AES_H
N#define __STM32L1xx_AES_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
L 1 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral register's definitions, bits 
N  *          definitions and memory mapping for STM32L1xx High-density, Medium-density
N  *          and Medium-density Plus devices.
N  *
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral’s registers hardware
N  *
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32l1xx
N  * @{
N  */
N    
N#ifndef __STM32L1XX_H
S#define __STM32L1XX_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif 
S  
S/** @addtogroup Library_configuration_section
S  * @{
S  */
S  
S/* Uncomment the line below according to the target STM32L device used in your 
S   application 
S  */
S
S#if !defined (STM32L1XX_MD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_HD)
S
S/* #define STM32L1XX_MD  */   /*!< - Ultra Low Power Medium-density devices: STM32L151x6xx, STM32L151x8xx,
S                                     STM32L151xBxx, STM32L152x6xx, STM32L152x8xx and STM32L152xBxx. 
S                                   - Ultra Low Power Medium-density Value Line devices: STM32L100x6xx,
S                                     STM32L100x8xx and STM32L100xBxx.  */
S
S/* #define STM32L1XX_MDP */   /*!< - Ultra Low Power Medium-density Plus devices: STM32L151xCxx, STM32L152xCxx and STM32L162xCxx 
S                                   - Ultra Low Power Medium-density Plus Value Line devices: STM32L100xCxx  */
S
S#define STM32L1XX_HD     /*!< Ultra Low Power High-density devices: STM32L151xDxx, STM32L152xDxx and STM32L162xDxx */
S#endif
S/*  Tip: To avoid modifying this file each time you need to switch between these
S        devices, you can define the device in your toolchain compiler preprocessor.
S  */
S
S#if !defined (STM32L1XX_MD) && !defined (STM32L1XX_MDP) && !defined (STM32L1XX_HD)
S #error "Please select first the target STM32L1xx device used in your application (in stm32l1xx.h file)"
S#endif
S
S#if !defined  USE_STDPERIPH_DRIVER
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
S#endif
S
S/**
S * @brief In the following line adjust the value of External High Speed oscillator (HSE)
S   used in your application 
S   
S   Tip: To avoid modifying this file each time you need to use different HSE, you
S        can define the HSE value in your toolchain compiler preprocessor.
S  */
S#if !defined  (HSE_VALUE)
S#define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */
S#endif
S
S/**
S * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
S   Timeout value 
S   */
S#if !defined  (HSE_STARTUP_TIMEOUT)
S#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */
S#endif
S
S/**
S * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
S   Timeout value 
S   */
S#if !defined  (HSI_STARTUP_TIMEOUT)
S#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSI start up */
S#endif
S
S#if !defined  (HSI_VALUE)
S#define HSI_VALUE  ((uint32_t)16000000) /*!< Value of the Internal High Speed oscillator in Hz.
S                                             The real value may vary depending on the variations
S                                             in voltage and temperature.  */
S#endif
S
S#if !defined  (LSI_VALUE)
S#define LSI_VALUE  ((uint32_t)37000)    /*!< Value of the Internal Low Speed oscillator in Hz
S                                             The real value may vary depending on the variations
S                                             in voltage and temperature.  */
S#endif
S
S#if !defined  (LSE_VALUE)
S#define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
S#endif
S
S/**
S * @brief STM32L1xx Standard Peripheral Library version number V1.2.0
S   */
S#define __STM32L1XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
S#define __STM32L1XX_STDPERIPH_VERSION_SUB1   (0x02) /*!< [23:16] sub1 version */
S#define __STM32L1XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
S#define __STM32L1XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __STM32L1XX_STDPERIPH_VERSION       ( (__STM32L1XX_STDPERIPH_VERSION_MAIN << 24)\
S                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB1 << 16)\
S                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB2 << 8)\
S                                             |(__STM32L1XX_STDPERIPH_VERSION_RC))
X#define __STM32L1XX_STDPERIPH_VERSION       ( (__STM32L1XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32L1XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32L1XX_STDPERIPH_VERSION_RC))
S
S/**
S  * @}
S  */
S
S/** @addtogroup Configuration_section_for_CMSIS
S  * @{
S  */
S
S/**
S * @brief STM32L1xx Interrupt Number Definition, according to the selected device 
S *        in @ref Library_configuration_section 
S */
S#define __CM3_REV                 0x200 /*!< Cortex-M3 Revision r2p0                      */
S#define __MPU_PRESENT             1     /*!< STM32L1 provides MPU                         */
S#define __NVIC_PRIO_BITS          4     /*!< STM32L1 uses 4 Bits for the Priority Levels  */
S#define __Vendor_SysTickConfig    0     /*!< Set to 1 if different SysTick Config is used */
S 
S/*!< Interrupt Number Definition */
Stypedef enum IRQn
S{
S/******  Cortex-M3 Processor Exceptions Numbers ******************************************************/
S  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                */
S  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt                 */
S  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                         */
S  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                       */
S  SVC_IRQn                    = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                          */
S  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                    */
S  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                          */
S  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                      */
S
S/******  STM32L specific Interrupt Numbers ***********************************************************/
S  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                               */
S  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt               */
S  TAMPER_STAMP_IRQn           = 2,      /*!< Tamper and Time Stamp through EXTI Line Interrupts      */
S  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup Timer through EXTI Line Interrupt            */
S  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                  */
S  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                    */
S  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                    */
S  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                    */
S  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                    */
S  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                    */
S  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                    */
S  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                         */
S  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                         */
S  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                         */
S  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                         */
S  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                         */
S  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                         */
S  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                         */
S  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                   */
S  USB_HP_IRQn                 = 19,     /*!< USB High Priority Interrupt                             */
S  USB_LP_IRQn                 = 20,     /*!< USB Low Priority Interrupt                              */
S  DAC_IRQn                    = 21,     /*!< DAC Interrupt                                           */
S  COMP_IRQn                   = 22,     /*!< Comparator through EXTI Line Interrupt                  */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                           */
S  LCD_IRQn                    = 24,     /*!< LCD Interrupt                                           */
S  TIM9_IRQn                   = 25,     /*!< TIM9 global Interrupt                                   */
S  TIM10_IRQn                  = 26,     /*!< TIM10 global Interrupt                                  */
S  TIM11_IRQn                  = 27,     /*!< TIM11 global Interrupt                                  */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                   */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                   */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                   */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                    */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                    */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                    */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                    */
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                   */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                   */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                 */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                 */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                 */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                         */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm through EXTI Line Interrupt                   */
S  USB_FS_WKUP_IRQn            = 42,     /*!< USB FS WakeUp from suspend through EXTI Line Interrupt  */
S  TIM6_IRQn                   = 43,     /*!< TIM6 global Interrupt                                   */
S#ifdef STM32L1XX_MD
S  TIM7_IRQn                   = 44      /*!< TIM7 global Interrupt                                   */
S#endif /* STM32L1XX_MD */
S
S#ifdef STM32L1XX_MDP
S  TIM7_IRQn                   = 44,     /*!< TIM7 global Interrupt                                   */
S  TIM5_IRQn                   = 46,     /*!< TIM5 global Interrupt                                   */
S  SPI3_IRQn                   = 47,     /*!< SPI3 global Interrupt                                   */
S  DMA2_Channel1_IRQn          = 50,     /*!< DMA2 Channel 1 global Interrupt                         */
S  DMA2_Channel2_IRQn          = 51,     /*!< DMA2 Channel 2 global Interrupt                         */
S  DMA2_Channel3_IRQn          = 52,     /*!< DMA2 Channel 3 global Interrupt                         */
S  DMA2_Channel4_IRQn          = 53,     /*!< DMA2 Channel 4 global Interrupt                         */
S  DMA2_Channel5_IRQn          = 54,     /*!< DMA2 Channel 5 global Interrupt                         */
S  AES_IRQn                    = 55,     /*!< AES global Interrupt                                    */
S  COMP_ACQ_IRQn               = 56      /*!< Comparator Channel Acquisition global Interrupt         */
S#endif /* STM32L1XX_MDP */
S
S#ifdef STM32L1XX_HD
S  TIM7_IRQn                   = 44,     /*!< TIM7 global Interrupt                                   */
S  SDIO_IRQn                   = 45,     /*!< SDIO global Interrupt                                   */
S  TIM5_IRQn                   = 46,     /*!< TIM5 global Interrupt                                   */
S  SPI3_IRQn                   = 47,     /*!< SPI3 global Interrupt                                   */
S  UART4_IRQn                  = 48,     /*!< UART4 global Interrupt                                  */
S  UART5_IRQn                  = 49,     /*!< UART5 global Interrupt                                  */
S  DMA2_Channel1_IRQn          = 50,     /*!< DMA2 Channel 1 global Interrupt                         */
S  DMA2_Channel2_IRQn          = 51,     /*!< DMA2 Channel 2 global Interrupt                         */
S  DMA2_Channel3_IRQn          = 52,     /*!< DMA2 Channel 3 global Interrupt                         */
S  DMA2_Channel4_IRQn          = 53,     /*!< DMA2 Channel 4 global Interrupt                         */
S  DMA2_Channel5_IRQn          = 54,     /*!< DMA2 Channel 5 global Interrupt                         */
S  AES_IRQn                    = 55,     /*!< AES global Interrupt                                    */
S  COMP_ACQ_IRQn               = 56      /*!< Comparator Channel Acquisition global Interrupt         */
S#endif /* STM32L1XX_HD */
S} IRQn_Type;
S
S/**
S  * @}
S  */
S
S#include "core_cm3.h"
S#include "system_stm32l1xx.h"
S#include <stdint.h>
S
S/** @addtogroup Exported_types
S  * @{
S  */  
S
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
S
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
S
S/** 
S  * @brief  __RAM_FUNC definition
S  */ 
S#if defined ( __CC_ARM   )
S/* ARM Compiler
S   ------------
S   RAM functions are defined using the toolchain options. 
S   Functions that are executed in RAM should reside in a separate source module.
S   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
S   area of a module to a memory space in physical RAM.
S   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
S   dialog. 
S*/
S #define __RAM_FUNC FLASH_Status 
S
S#elif defined ( __ICCARM__ )
S/* ICCARM Compiler
S   ---------------
S   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
S*/
S #define __RAM_FUNC __ramfunc FLASH_Status
S
S#elif defined   (  __GNUC__  )
S/* GNU Compiler
S   ------------
S   RAM functions are defined using a specific toolchain attribute 
S   "__attribute__((section(".data")))". 
S*/
S #define __RAM_FUNC FLASH_Status __attribute__((section(".data")))
S
S#elif defined   (  __TASKING__  )
S/* TASKING Compiler
S   ----------------
S   RAM functions are defined using a specific toolchain pragma. This pragma is 
S   defined in the stm32l1xx_flash_ramfunc.c 
S*/
S #define __RAM_FUNC  FLASH_Status
S
S#endif
S
S/**
S  * @}
S  */
S
S/** @addtogroup Peripheral_registers_structures
S  * @{
S  */   
S
S/** 
S  * @brief Analog to Digital Converter
S  */
S
Stypedef struct
S{
S  __IO uint32_t SR;           /*!< ADC status register,                         Address offset: 0x00 */
S  __IO uint32_t CR1;          /*!< ADC control register 1,                      Address offset: 0x04 */
S  __IO uint32_t CR2;          /*!< ADC control register 2,                      Address offset: 0x08 */
S  __IO uint32_t SMPR1;        /*!< ADC sample time register 1,                  Address offset: 0x0C */
S  __IO uint32_t SMPR2;        /*!< ADC sample time register 2,                  Address offset: 0x10 */
S  __IO uint32_t SMPR3;        /*!< ADC sample time register 3,                  Address offset: 0x14 */
S  __IO uint32_t JOFR1;        /*!< ADC injected channel data offset register 1, Address offset: 0x18 */
S  __IO uint32_t JOFR2;        /*!< ADC injected channel data offset register 2, Address offset: 0x1C */
S  __IO uint32_t JOFR3;        /*!< ADC injected channel data offset register 3, Address offset: 0x20 */
S  __IO uint32_t JOFR4;        /*!< ADC injected channel data offset register 4, Address offset: 0x24 */
S  __IO uint32_t HTR;          /*!< ADC watchdog higher threshold register,      Address offset: 0x28 */
S  __IO uint32_t LTR;          /*!< ADC watchdog lower threshold register,       Address offset: 0x2C */
S  __IO uint32_t SQR1;         /*!< ADC regular sequence register 1,             Address offset: 0x30 */
S  __IO uint32_t SQR2;         /*!< ADC regular sequence register 2,             Address offset: 0x34 */
S  __IO uint32_t SQR3;         /*!< ADC regular sequence register 3,             Address offset: 0x38 */
S  __IO uint32_t SQR4;         /*!< ADC regular sequence register 4,             Address offset: 0x3C */
S  __IO uint32_t SQR5;         /*!< ADC regular sequence register 5,             Address offset: 0x40 */
S  __IO uint32_t JSQR;         /*!< ADC injected sequence register,              Address offset: 0x44 */
S  __IO uint32_t JDR1;         /*!< ADC injected data register 1,                Address offset: 0x48 */
S  __IO uint32_t JDR2;         /*!< ADC injected data register 2,                Address offset: 0x4C */
S  __IO uint32_t JDR3;         /*!< ADC injected data register 3,                Address offset: 0x50 */
S  __IO uint32_t JDR4;         /*!< ADC injected data register 4,                Address offset: 0x54 */
S  __IO uint32_t DR;           /*!< ADC regular data register,                   Address offset: 0x58 */
S  __IO uint32_t SMPR0;        /*!< ADC sample time register 0,                  Address offset: 0x5C */
S} ADC_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t CSR;          /*!< ADC common status register,                  Address offset: ADC1 base address + 0x300 */
S  __IO uint32_t CCR;          /*!< ADC common control register,                 Address offset: ADC1 base address + 0x304 */
S} ADC_Common_TypeDef;
S
S
S/** 
S  * @brief AES hardware accelerator
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;           /*!< AES control register,                        Address offset: 0x00 */
S  __IO uint32_t SR;           /*!< AES status register,                         Address offset: 0x04 */
S  __IO uint32_t DINR;         /*!< AES data input register,                     Address offset: 0x08 */
S  __IO uint32_t DOUTR;        /*!< AES data output register,                    Address offset: 0x0C */
S  __IO uint32_t KEYR0;        /*!< AES key register 0,                          Address offset: 0x10 */
S  __IO uint32_t KEYR1;        /*!< AES key register 1,                          Address offset: 0x14 */
S  __IO uint32_t KEYR2;        /*!< AES key register 2,                          Address offset: 0x18 */
S  __IO uint32_t KEYR3;        /*!< AES key register 3,                          Address offset: 0x1C */
S  __IO uint32_t IVR0;         /*!< AES initialization vector register 0,        Address offset: 0x20 */
S  __IO uint32_t IVR1;         /*!< AES initialization vector register 1,        Address offset: 0x24 */
S  __IO uint32_t IVR2;         /*!< AES initialization vector register 2,        Address offset: 0x28 */
S  __IO uint32_t IVR3;         /*!< AES initialization vector register 3,        Address offset: 0x2C */
S} AES_TypeDef;
S
S/** 
S  * @brief Comparator 
S  */
S
Stypedef struct
S{
S  __IO uint32_t CSR;          /*!< COMP comparator control and status register, Address offset: 0x00 */
S} COMP_TypeDef;
S
S/** 
S  * @brief CRC calculation unit
S  */
S
Stypedef struct
S{
S  __IO uint32_t DR;           /*!< CRC Data register,                           Address offset: 0x00 */
S  __IO uint8_t  IDR;          /*!< CRC Independent data register,               Address offset: 0x04 */
S  uint8_t   RESERVED0;        /*!< Reserved,                                    0x05                 */
S  uint16_t  RESERVED1;        /*!< Reserved,                                    0x06                 */
S  __IO uint32_t CR;           /*!< CRC Control register,                        Address offset: 0x08 */ 
S} CRC_TypeDef;
S
S/** 
S  * @brief Digital to Analog Converter
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;           /*!< DAC control register,                                     Address offset: 0x00 */
S  __IO uint32_t SWTRIGR;      /*!< DAC software trigger register,                            Address offset: 0x04 */
S  __IO uint32_t DHR12R1;      /*!< DAC channel1 12-bit right-aligned data holding register,  Address offset: 0x08 */
S  __IO uint32_t DHR12L1;      /*!< DAC channel1 12-bit left aligned data holding register,   Address offset: 0x0C */
S  __IO uint32_t DHR8R1;       /*!< DAC channel1 8-bit right aligned data holding register,   Address offset: 0x10 */
S  __IO uint32_t DHR12R2;      /*!< DAC channel2 12-bit right aligned data holding register,  Address offset: 0x14 */
S  __IO uint32_t DHR12L2;      /*!< DAC channel2 12-bit left aligned data holding register,   Address offset: 0x18 */
S  __IO uint32_t DHR8R2;       /*!< DAC channel2 8-bit right-aligned data holding register,   Address offset: 0x1C */
S  __IO uint32_t DHR12RD;      /*!< Dual DAC 12-bit right-aligned data holding register,      Address offset: 0x20 */
S  __IO uint32_t DHR12LD;      /*!< DUAL DAC 12-bit left aligned data holding register,       Address offset: 0x24 */
S  __IO uint32_t DHR8RD;       /*!< DUAL DAC 8-bit right aligned data holding register,       Address offset: 0x28 */
S  __IO uint32_t DOR1;         /*!< DAC channel1 data output register,                        Address offset: 0x2C */
S  __IO uint32_t DOR2;         /*!< DAC channel2 data output register,                        Address offset: 0x30 */
S  __IO uint32_t SR;           /*!< DAC status register,                                      Address offset: 0x34 */
S} DAC_TypeDef;
S
S/** 
S  * @brief Debug MCU
S  */
S
Stypedef struct
S{
S  __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
S  __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
S  __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
S  __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
S}DBGMCU_TypeDef;
S
S/** 
S  * @brief DMA Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t CCR;          /*!< DMA channel x configuration register        */
S  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register       */
S  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register   */
S  __IO uint32_t CMAR;         /*!< DMA channel x memory address register       */
S} DMA_Channel_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t ISR;          /*!< DMA interrupt status register,               Address offset: 0x00 */
S  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,           Address offset: 0x04 */
S} DMA_TypeDef;
S
S/** 
S  * @brief External Interrupt/Event Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t IMR;          /*!< EXTI interrupt mask register,                 Address offset: 0x00 */
S  __IO uint32_t EMR;          /*!< EXTI event mask register,                     Address offset: 0x04 */
S  __IO uint32_t RTSR;         /*!< EXTI rising edge trigger selection register,  Address offset: 0x08 */
S  __IO uint32_t FTSR;         /*!< EXTI Falling edge trigger selection register, Address offset: 0x0C */
S  __IO uint32_t SWIER;        /*!< EXTI software interrupt event register,       Address offset: 0x10 */
S  __IO uint32_t PR;           /*!< EXTI pending register,                        Address offset: 0x14 */
S} EXTI_TypeDef;
S
S/** 
S  * @brief FLASH Registers
S  */
S
Stypedef struct
S{
S  __IO uint32_t ACR;          /*!< Access control register,                     Address offset: 0x00 */
S  __IO uint32_t PECR;         /*!< Program/erase control register,              Address offset: 0x04 */
S  __IO uint32_t PDKEYR;       /*!< Power down key register,                     Address offset: 0x08 */
S  __IO uint32_t PEKEYR;       /*!< Program/erase key register,                  Address offset: 0x0c */
S  __IO uint32_t PRGKEYR;      /*!< Program memory key register,                 Address offset: 0x10 */
S  __IO uint32_t OPTKEYR;      /*!< Option byte key register,                    Address offset: 0x14 */
S  __IO uint32_t SR;           /*!< Status register,                             Address offset: 0x18 */
S  __IO uint32_t OBR;          /*!< Option byte register,                        Address offset: 0x1c */
S  __IO uint32_t WRPR;         /*!< Write protection register,                   Address offset: 0x20 */
S  uint32_t   RESERVED[23];    /*!< Reserved,                                    0x24                 */
S  __IO uint32_t WRPR1;        /*!< Write protection register 1,                 Address offset: 0x28 */
S  __IO uint32_t WRPR2;        /*!< Write protection register 2,                 Address offset: 0x2C */
S} FLASH_TypeDef;
S
S/** 
S  * @brief Option Bytes Registers
S  */
S  
Stypedef struct
S{
S  __IO uint32_t RDP;               /*!< Read protection register,               Address offset: 0x00 */
S  __IO uint32_t USER;              /*!< user register,                          Address offset: 0x04 */
S  __IO uint32_t WRP01;             /*!< write protection register 0 1,          Address offset: 0x08 */
S  __IO uint32_t WRP23;             /*!< write protection register 2 3,          Address offset: 0x0C */
S  __IO uint32_t WRP45;             /*!< write protection register 4 5,          Address offset: 0x10 */
S  __IO uint32_t WRP67;             /*!< write protection register 6 7,          Address offset: 0x14 */
S  __IO uint32_t WRP89;             /*!< write protection register 8 9,          Address offset: 0x18 */
S  __IO uint32_t WRP1011;           /*!< write protection register 10 11,        Address offset: 0x1C */
S} OB_TypeDef;
S
S/** 
S  * @brief Operational Amplifier (OPAMP)
S  */
S
Stypedef struct
S{
S  __IO uint32_t CSR;          /*!< OPAMP control/status register,                     Address offset: 0x00 */
S  __IO uint32_t OTR;          /*!< OPAMP offset trimming register for normal mode,    Address offset: 0x04 */ 
S  __IO uint32_t LPOTR;        /*!< OPAMP offset trimming register for low power mode, Address offset: 0x08 */
S} OPAMP_TypeDef;
S
S/** 
S  * @brief Flexible Static Memory Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t BTCR[8];      /*!< NOR/PSRAM chip-select control register(BCR) and chip-select timing register(BTR), Address offset: 0x00-1C */
S} FSMC_Bank1_TypeDef; 
S
S/** 
S  * @brief Flexible Static Memory Controller Bank1E
S  */
S  
Stypedef struct
S{
S  __IO uint32_t BWTR[7];      /*!< NOR/PSRAM write timing registers, Address offset: 0x104-0x11C */
S} FSMC_Bank1E_TypeDef;        
S
S/** 
S  * @brief General Purpose IO
S  */
S
Stypedef struct
S{
S  __IO uint32_t MODER;        /*!< GPIO port mode register,                     Address offset: 0x00      */
S  __IO uint16_t OTYPER;       /*!< GPIO port output type register,              Address offset: 0x04      */
S  uint16_t RESERVED0;         /*!< Reserved,                                    0x06                      */
S  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,             Address offset: 0x08      */
S  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,        Address offset: 0x0C      */
S  __IO uint16_t IDR;          /*!< GPIO port input data register,               Address offset: 0x10      */
S  uint16_t RESERVED1;         /*!< Reserved,                                    0x12                      */
S  __IO uint16_t ODR;          /*!< GPIO port output data register,              Address offset: 0x14      */
S  uint16_t RESERVED2;         /*!< Reserved,                                    0x16                      */
S  __IO uint16_t BSRRL;        /*!< GPIO port bit set/reset low registerBSRR,    Address offset: 0x18      */
S  __IO uint16_t BSRRH;        /*!< GPIO port bit set/reset high registerBSRR,   Address offset: 0x1A      */
S  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,       Address offset: 0x1C      */
S  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,        Address offset: 0x20-0x24 */
S  __IO uint16_t BRR;          /*!< GPIO bit reset register,                     Address offset: 0x28      */
S  uint16_t RESERVED3;         /*!< Reserved,                                    0x2A                      */
S} GPIO_TypeDef;
S
S/** 
S  * @brief SysTem Configuration
S  */
S
Stypedef struct
S{
S  __IO uint32_t MEMRMP;       /*!< SYSCFG memory remap register,                      Address offset: 0x00      */
S  __IO uint32_t PMC;          /*!< SYSCFG peripheral mode configuration register,     Address offset: 0x04      */
S  __IO uint32_t EXTICR[4];    /*!< SYSCFG external interrupt configuration registers, Address offset: 0x08-0x14 */
S} SYSCFG_TypeDef;
S
S/** 
S  * @brief Inter-integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;          /*!< I2C Control register 1,                      Address offset: 0x00 */
S  uint16_t  RESERVED0;        /*!< Reserved,                                    0x02                 */
S  __IO uint16_t CR2;          /*!< I2C Control register 2,                      Address offset: 0x04 */
S  uint16_t  RESERVED1;        /*!< Reserved,                                    0x06                 */
S  __IO uint16_t OAR1;         /*!< I2C Own address register 1,                  Address offset: 0x08 */
S  uint16_t  RESERVED2;        /*!< Reserved,                                    0x0A                 */
S  __IO uint16_t OAR2;         /*!< I2C Own address register 2,                  Address offset: 0x0C */
S  uint16_t  RESERVED3;        /*!< Reserved,                                    0x0E                 */
S  __IO uint16_t DR;           /*!< I2C Data register,                           Address offset: 0x10 */
S  uint16_t  RESERVED4;        /*!< Reserved,                                    0x12                 */
S  __IO uint16_t SR1;          /*!< I2C Status register 1,                       Address offset: 0x14 */
S  uint16_t  RESERVED5;        /*!< Reserved,                                    0x16                 */
S  __IO uint16_t SR2;          /*!< I2C Status register 2,                       Address offset: 0x18 */
S  uint16_t  RESERVED6;        /*!< Reserved,                                    0x1A                 */
S  __IO uint16_t CCR;          /*!< I2C Clock control register,                  Address offset: 0x1C */
S  uint16_t  RESERVED7;        /*!< Reserved,                                    0x1E                 */
S  __IO uint16_t TRISE;        /*!< I2C TRISE register,                          Address offset: 0x20 */
S  uint16_t  RESERVED8;        /*!< Reserved,                                    0x22                 */
S} I2C_TypeDef;
S
S/** 
S  * @brief Independent WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t KR;           /*!< Key register,                                Address offset: 0x00 */
S  __IO uint32_t PR;           /*!< Prescaler register,                          Address offset: 0x04 */
S  __IO uint32_t RLR;          /*!< Reload register,                             Address offset: 0x08 */
S  __IO uint32_t SR;           /*!< Status register,                             Address offset: 0x0C */
S} IWDG_TypeDef;
S
S
S/** 
S  * @brief LCD
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;        /*!< LCD control register,              Address offset: 0x00 */
S  __IO uint32_t FCR;       /*!< LCD frame control register,        Address offset: 0x04 */
S  __IO uint32_t SR;        /*!< LCD status register,               Address offset: 0x08 */
S  __IO uint32_t CLR;       /*!< LCD clear register,                Address offset: 0x0C */
S  uint32_t RESERVED;       /*!< Reserved,                          Address offset: 0x10 */
S  __IO uint32_t RAM[16];   /*!< LCD display memory,           Address offset: 0x14-0x50 */
S} LCD_TypeDef;
S
S/** 
S  * @brief Power Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
S  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
S} PWR_TypeDef;
S
S/** 
S  * @brief Reset and Clock Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;            /*!< RCC clock control register,                                   Address offset: 0x00 */
S  __IO uint32_t ICSCR;         /*!< RCC Internal clock sources calibration register,              Address offset: 0x04 */
S  __IO uint32_t CFGR;          /*!< RCC Clock configuration register,                             Address offset: 0x08 */
S  __IO uint32_t CIR;           /*!< RCC Clock interrupt register,                                 Address offset: 0x0C */
S  __IO uint32_t AHBRSTR;       /*!< RCC AHB peripheral reset register,                            Address offset: 0x10 */
S  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                           Address offset: 0x14 */
S  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                           Address offset: 0x18 */
S  __IO uint32_t AHBENR;        /*!< RCC AHB peripheral clock enable register,                     Address offset: 0x1C */
S  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                    Address offset: 0x20 */
S  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                    Address offset: 0x24 */
S  __IO uint32_t AHBLPENR;      /*!< RCC AHB peripheral clock enable in low power mode register,   Address offset: 0x28 */
S  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register,  Address offset: 0x2C */
S  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register,  Address offset: 0x30 */
S  __IO uint32_t CSR;           /*!< RCC Control/status register,                                  Address offset: 0x34 */
S} RCC_TypeDef;
S
S/** 
S  * @brief Routing Interface 
S  */
S
Stypedef struct
S{
S  __IO uint32_t ICR;       /*!< RI input capture register,             Address offset: 0x00 */
S  __IO uint32_t ASCR1;     /*!< RI analog switches control register,   Address offset: 0x04 */
S  __IO uint32_t ASCR2;     /*!< RI analog switch control register 2,   Address offset: 0x08 */
S  __IO uint32_t HYSCR1;     /*!< RI hysteresis control register,       Address offset: 0x0C */
S  __IO uint32_t HYSCR2;     /*!< RI Hysteresis control register,       Address offset: 0x10 */
S  __IO uint32_t HYSCR3;     /*!< RI Hysteresis control register,       Address offset: 0x14 */
S  __IO uint32_t HYSCR4;     /*!< RI Hysteresis control register,       Address offset: 0x18 */
S} RI_TypeDef;
S
S/** 
S  * @brief Real-Time Clock
S  */
S
Stypedef struct
S{
S  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
S  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
S  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
S  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
S  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
S  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                 Address offset: 0x14 */
S  __IO uint32_t CALIBR;     /*!< RTC calibration register,                                  Address offset: 0x18 */
S  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
S  __IO uint32_t ALRMBR;     /*!< RTC alarm B register,                                      Address offset: 0x20 */
S  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
S  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
S  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
S  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
S  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
S  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
S  __IO uint32_t CALR;       /*!< RRTC calibration register,                                 Address offset: 0x3C */
S  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
S  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
S  __IO uint32_t ALRMBSSR;   /*!< RTC alarm B sub second register,                           Address offset: 0x48 */
S  uint32_t RESERVED7;       /*!< Reserved, 0x4C                                                                  */
S  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                     Address offset: 0x50 */
S  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                     Address offset: 0x54 */
S  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                     Address offset: 0x58 */
S  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                     Address offset: 0x5C */
S  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                     Address offset: 0x60 */
S  __IO uint32_t BKP5R;      /*!< RTC backup register 5,                                     Address offset: 0x64 */
S  __IO uint32_t BKP6R;      /*!< RTC backup register 6,                                     Address offset: 0x68 */
S  __IO uint32_t BKP7R;      /*!< RTC backup register 7,                                     Address offset: 0x6C */
S  __IO uint32_t BKP8R;      /*!< RTC backup register 8,                                     Address offset: 0x70 */
S  __IO uint32_t BKP9R;      /*!< RTC backup register 9,                                     Address offset: 0x74 */
S  __IO uint32_t BKP10R;     /*!< RTC backup register 10,                                    Address offset: 0x78 */
S  __IO uint32_t BKP11R;     /*!< RTC backup register 11,                                    Address offset: 0x7C */
S  __IO uint32_t BKP12R;     /*!< RTC backup register 12,                                    Address offset: 0x80 */
S  __IO uint32_t BKP13R;     /*!< RTC backup register 13,                                    Address offset: 0x84 */
S  __IO uint32_t BKP14R;     /*!< RTC backup register 14,                                    Address offset: 0x88 */
S  __IO uint32_t BKP15R;     /*!< RTC backup register 15,                                    Address offset: 0x8C */
S  __IO uint32_t BKP16R;     /*!< RTC backup register 16,                                    Address offset: 0x90 */
S  __IO uint32_t BKP17R;     /*!< RTC backup register 17,                                    Address offset: 0x94 */
S  __IO uint32_t BKP18R;     /*!< RTC backup register 18,                                    Address offset: 0x98 */
S  __IO uint32_t BKP19R;     /*!< RTC backup register 19,                                    Address offset: 0x9C */
S  __IO uint32_t BKP20R;     /*!< RTC backup register 20,                                    Address offset: 0xA0 */
S  __IO uint32_t BKP21R;     /*!< RTC backup register 21,                                    Address offset: 0xA4 */
S  __IO uint32_t BKP22R;     /*!< RTC backup register 22,                                    Address offset: 0xA8 */
S  __IO uint32_t BKP23R;     /*!< RTC backup register 23,                                    Address offset: 0xAC */
S  __IO uint32_t BKP24R;     /*!< RTC backup register 24,                                    Address offset: 0xB0 */
S  __IO uint32_t BKP25R;     /*!< RTC backup register 25,                                    Address offset: 0xB4 */
S  __IO uint32_t BKP26R;     /*!< RTC backup register 26,                                    Address offset: 0xB8 */
S  __IO uint32_t BKP27R;     /*!< RTC backup register 27,                                    Address offset: 0xBC */
S  __IO uint32_t BKP28R;     /*!< RTC backup register 28,                                    Address offset: 0xC0 */
S  __IO uint32_t BKP29R;     /*!< RTC backup register 29,                                    Address offset: 0xC4 */
S  __IO uint32_t BKP30R;     /*!< RTC backup register 30,                                    Address offset: 0xC8 */
S  __IO uint32_t BKP31R;     /*!< RTC backup register 31,                                    Address offset: 0xCC */
S} RTC_TypeDef;
S
S/** 
S  * @brief SD host Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t POWER;          /*!< SDIO power control register,    Address offset: 0x00 */
S  __IO uint32_t CLKCR;          /*!< SDI clock control register,     Address offset: 0x04 */
S  __IO uint32_t ARG;            /*!< SDIO argument register,         Address offset: 0x08 */
S  __IO uint32_t CMD;            /*!< SDIO command register,          Address offset: 0x0C */
S  __I uint32_t  RESPCMD;        /*!< SDIO command response register, Address offset: 0x10 */
S  __I uint32_t  RESP1;          /*!< SDIO response 1 register,       Address offset: 0x14 */
S  __I uint32_t  RESP2;          /*!< SDIO response 2 register,       Address offset: 0x18 */
S  __I uint32_t  RESP3;          /*!< SDIO response 3 register,       Address offset: 0x1C */
S  __I uint32_t  RESP4;          /*!< SDIO response 4 register,       Address offset: 0x20 */
S  __IO uint32_t DTIMER;         /*!< SDIO data timer register,       Address offset: 0x24 */
S  __IO uint32_t DLEN;           /*!< SDIO data length register,      Address offset: 0x28 */
S  __IO uint32_t DCTRL;          /*!< SDIO data control register,     Address offset: 0x2C */
S  __I uint32_t  DCOUNT;         /*!< SDIO data counter register,     Address offset: 0x30 */
S  __I uint32_t  STA;            /*!< SDIO status register,           Address offset: 0x34 */
S  __IO uint32_t ICR;            /*!< SDIO interrupt clear register,  Address offset: 0x38 */
S  __IO uint32_t MASK;           /*!< SDIO mask register,             Address offset: 0x3C */
S  uint32_t      RESERVED0[2];   /*!< Reserved, 0x40-0x44                                  */
S  __I uint32_t  FIFOCNT;        /*!< SDIO FIFO counter register,     Address offset: 0x48 */
S  uint32_t      RESERVED1[13];  /*!< Reserved, 0x4C-0x7C                                  */
S  __IO uint32_t FIFO;           /*!< SDIO data FIFO register,        Address offset: 0x80 */
S} SDIO_TypeDef;
S
S/** 
S  * @brief Serial Peripheral Interface
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;        /*!< SPI control register 1 (not used in I2S mode),      Address offset: 0x00 */
S  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                           */
S  __IO uint16_t CR2;        /*!< SPI control register 2,                             Address offset: 0x04 */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                           */
S  __IO uint16_t SR;         /*!< SPI status register,                                Address offset: 0x08 */
S  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                           */
S  __IO uint16_t DR;         /*!< SPI data register,                                  Address offset: 0x0C */
S  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                           */
S  __IO uint16_t CRCPR;      /*!< SPI CRC polynomial register (not used in I2S mode), Address offset: 0x10 */
S  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                           */
S  __IO uint16_t RXCRCR;     /*!< SPI RX CRC register (not used in I2S mode),         Address offset: 0x14 */
S  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                           */
S  __IO uint16_t TXCRCR;     /*!< SPI TX CRC register (not used in I2S mode),         Address offset: 0x18 */
S  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                           */
S  __IO uint16_t I2SCFGR;    /*!< SPI_I2S configuration register,                     Address offset: 0x1C */
S  uint16_t      RESERVED7;  /*!< Reserved, 0x1E                                                           */
S  __IO uint16_t I2SPR;      /*!< SPI_I2S prescaler register,                         Address offset: 0x20 */
S  uint16_t      RESERVED8;  /*!< Reserved, 0x22                                                           */
S} SPI_TypeDef;
S
S/** 
S  * @brief TIM
S  */
S
Stypedef struct
S{
S  __IO uint16_t CR1;          /*!< TIM control register 1,              Address offset: 0x00 */
S  uint16_t      RESERVED0;    /*!< Reserved, 0x02                                            */
S  __IO uint16_t CR2;          /*!< TIM control register 2,              Address offset: 0x04 */
S  uint16_t      RESERVED1;    /*!< Reserved, 0x06                                            */
S  __IO uint16_t SMCR;         /*!< TIM slave mode control register,     Address offset: 0x08 */
S  uint16_t      RESERVED2;    /*!< Reserved, 0x0A                                            */
S  __IO uint16_t DIER;         /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
S  uint16_t      RESERVED3;    /*!< Reserved, 0x0E                                            */
S  __IO uint16_t SR;           /*!< TIM status register,                 Address offset: 0x10 */
S  uint16_t      RESERVED4;    /*!< Reserved, 0x12                                            */
S  __IO uint16_t EGR;          /*!< TIM event generation register,       Address offset: 0x14 */
S  uint16_t      RESERVED5;    /*!< Reserved, 0x16                                            */
S  __IO uint16_t CCMR1;        /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
S  uint16_t      RESERVED6;    /*!< Reserved, 0x1A                                            */
S  __IO uint16_t CCMR2;        /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
S  uint16_t      RESERVED7;    /*!< Reserved, 0x1E                                            */
S  __IO uint16_t CCER;         /*!< TIM capture/compare enable register, Address offset: 0x20 */
S  uint16_t      RESERVED8;    /*!< Reserved, 0x22                                            */
S  __IO uint32_t CNT;          /*!< TIM counter register,                Address offset: 0x24 */
S  __IO uint16_t PSC;          /*!< TIM prescaler,                       Address offset: 0x28 */
S  uint16_t      RESERVED10;   /*!< Reserved, 0x2A                                            */
S  __IO uint32_t ARR;          /*!< TIM auto-reload register,            Address offset: 0x2C */
S  uint32_t      RESERVED12;   /*!< Reserved, 0x30                                            */
S  __IO uint32_t CCR1;         /*!< TIM capture/compare register 1,      Address offset: 0x34 */
S  __IO uint32_t CCR2;         /*!< TIM capture/compare register 2,      Address offset: 0x38 */
S  __IO uint32_t CCR3;         /*!< TIM capture/compare register 3,      Address offset: 0x3C */
S  __IO uint32_t CCR4;         /*!< TIM capture/compare register 4,      Address offset: 0x40 */
S  uint32_t      RESERVED17;   /*!< Reserved, 0x44                                            */
S  __IO uint16_t DCR;          /*!< TIM DMA control register,            Address offset: 0x48 */
S  uint16_t      RESERVED18;   /*!< Reserved, 0x4A                                            */
S  __IO uint16_t DMAR;         /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
S  uint16_t      RESERVED19;   /*!< Reserved, 0x4E                                            */
S  __IO uint16_t OR;           /*!< TIM option register,                 Address offset: 0x50 */
S  uint16_t      RESERVED20;   /*!< Reserved, 0x52                                            */
S} TIM_TypeDef;
S
S/** 
S  * @brief Universal Synchronous Asynchronous Receiver Transmitter
S  */
S 
Stypedef struct
S{
S  __IO uint16_t SR;         /*!< USART Status register,                   Address offset: 0x00 */
S  uint16_t      RESERVED0;  /*!< Reserved, 0x02                                                */
S  __IO uint16_t DR;         /*!< USART Data register,                     Address offset: 0x04 */
S  uint16_t      RESERVED1;  /*!< Reserved, 0x06                                                */
S  __IO uint16_t BRR;        /*!< USART Baud rate register,                Address offset: 0x08 */
S  uint16_t      RESERVED2;  /*!< Reserved, 0x0A                                                */
S  __IO uint16_t CR1;        /*!< USART Control register 1,                Address offset: 0x0C */
S  uint16_t      RESERVED3;  /*!< Reserved, 0x0E                                                */
S  __IO uint16_t CR2;        /*!< USART Control register 2,                Address offset: 0x10 */
S  uint16_t      RESERVED4;  /*!< Reserved, 0x12                                                */
S  __IO uint16_t CR3;        /*!< USART Control register 3,                Address offset: 0x14 */
S  uint16_t      RESERVED5;  /*!< Reserved, 0x16                                                */
S  __IO uint16_t GTPR;       /*!< USART Guard time and prescaler register, Address offset: 0x18 */
S  uint16_t      RESERVED6;  /*!< Reserved, 0x1A                                                */
S} USART_TypeDef;
S
S/** 
S  * @brief Window WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
S  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
S  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
S} WWDG_TypeDef;
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_memory_map
S  * @{
S  */
S
S#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
S#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
S#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
S
S#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
S#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
S
S#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
S
S/*!< Peripheral memory map */
S#define APB1PERIPH_BASE       PERIPH_BASE
S#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
S#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
S
S#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
S#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
S#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
S#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
S#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
S#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
S#define LCD_BASE              (APB1PERIPH_BASE + 0x2400)
S#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
S#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
S#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
S#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
S#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
S#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
S#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
S#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
S#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
S#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
S#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
S#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
S#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
S#define COMP_BASE             (APB1PERIPH_BASE + 0x7C00)
S#define RI_BASE               (APB1PERIPH_BASE + 0x7C04)
S#define OPAMP_BASE            (APB1PERIPH_BASE + 0x7C5C)
S
S#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x0000)
S#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
S#define TIM9_BASE             (APB2PERIPH_BASE + 0x0800)
S#define TIM10_BASE            (APB2PERIPH_BASE + 0x0C00)
S#define TIM11_BASE            (APB2PERIPH_BASE + 0x1000)
S#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
S#define ADC_BASE              (APB2PERIPH_BASE + 0x2700)
S#define SDIO_BASE             (APB2PERIPH_BASE + 0x2C00)
S#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
S#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
S
S#define GPIOA_BASE            (AHBPERIPH_BASE + 0x0000)
S#define GPIOB_BASE            (AHBPERIPH_BASE + 0x0400)
S#define GPIOC_BASE            (AHBPERIPH_BASE + 0x0800)
S#define GPIOD_BASE            (AHBPERIPH_BASE + 0x0C00)
S#define GPIOE_BASE            (AHBPERIPH_BASE + 0x1000)
S#define GPIOH_BASE            (AHBPERIPH_BASE + 0x1400)
S#define GPIOF_BASE            (AHBPERIPH_BASE + 0x1800)
S#define GPIOG_BASE            (AHBPERIPH_BASE + 0x1C00)
S#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
S#define RCC_BASE              (AHBPERIPH_BASE + 0x3800)
S
S
S#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x3C00) /*!< FLASH registers base address */
S#define OB_BASE               ((uint32_t)0x1FF80000)    /*!< FLASH Option Bytes base address */
S
S#define DMA1_BASE             (AHBPERIPH_BASE + 0x6000)
S#define DMA1_Channel1_BASE    (DMA1_BASE + 0x0008)
S#define DMA1_Channel2_BASE    (DMA1_BASE + 0x001C)
S#define DMA1_Channel3_BASE    (DMA1_BASE + 0x0030)
S#define DMA1_Channel4_BASE    (DMA1_BASE + 0x0044)
S#define DMA1_Channel5_BASE    (DMA1_BASE + 0x0058)
S#define DMA1_Channel6_BASE    (DMA1_BASE + 0x006C)
S#define DMA1_Channel7_BASE    (DMA1_BASE + 0x0080)
S
S#define DMA2_BASE             (AHBPERIPH_BASE + 0x6400)
S#define DMA2_Channel1_BASE    (DMA2_BASE + 0x0008)
S#define DMA2_Channel2_BASE    (DMA2_BASE + 0x001C)
S#define DMA2_Channel3_BASE    (DMA2_BASE + 0x0030)
S#define DMA2_Channel4_BASE    (DMA2_BASE + 0x0044)
S#define DMA2_Channel5_BASE    (DMA2_BASE + 0x0058)
S
S#define AES_BASE              ((uint32_t)0x50060000)
S
S#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */
S#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */
S
S#define DBGMCU_BASE           ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
S
S/**
S  * @}
S  */
S  
S/** @addtogroup Peripheral_declaration
S  * @{
S  */  
S
S#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
S#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
S#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
S#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
S#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
S#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
S#define LCD                 ((LCD_TypeDef *) LCD_BASE)
S#define RTC                 ((RTC_TypeDef *) RTC_BASE)
S#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
S#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
S#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
S#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
S#define USART2              ((USART_TypeDef *) USART2_BASE)
S#define USART3              ((USART_TypeDef *) USART3_BASE)
S#define UART4               ((USART_TypeDef *) UART4_BASE)
S#define UART5               ((USART_TypeDef *) UART5_BASE)
S#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
S#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
S#define PWR                 ((PWR_TypeDef *) PWR_BASE)
S#define DAC                 ((DAC_TypeDef *) DAC_BASE)
S#define COMP                ((COMP_TypeDef *) COMP_BASE)
S#define RI                  ((RI_TypeDef *) RI_BASE)
S#define OPAMP               ((OPAMP_TypeDef *) OPAMP_BASE)
S#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
S#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
S
S#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
S#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
S#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
S#define TIM9                ((TIM_TypeDef *) TIM9_BASE)
S#define TIM10               ((TIM_TypeDef *) TIM10_BASE)
S#define TIM11               ((TIM_TypeDef *) TIM11_BASE)
S#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
S#define USART1              ((USART_TypeDef *) USART1_BASE)
S#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
S#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
S#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
S#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
S#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
S#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
S#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
S
S#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
S#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
S#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
S#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
S#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
S#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
S
S#define RCC                 ((RCC_TypeDef *) RCC_BASE)
S#define CRC                 ((CRC_TypeDef *) CRC_BASE)
S
S#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
S#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
S#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
S#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
S#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
S#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)
S#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
S#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
S
S#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
S#define OB                  ((OB_TypeDef *) OB_BASE) 
S
S#define AES                 ((AES_TypeDef *) AES_BASE)
S
S#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S
S#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
S
S/**
S  * @}
S  */
S
S/** @addtogroup Exported_constants
S  * @{
S  */
S
S/** @addtogroup Peripheral_Registers_Bits_Definition
S  * @{
S  */
S    
S/******************************************************************************/
S/*                         Peripheral Registers Bits Definition               */
S/******************************************************************************/
S/******************************************************************************/
S/*                                                                            */
S/*                      Analog to Digital Converter (ADC)                     */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for ADC_SR register  ********************/
S#define  ADC_SR_AWD                          ((uint32_t)0x00000001)        /*!< Analog watchdog flag */
S#define  ADC_SR_EOC                          ((uint32_t)0x00000002)        /*!< End of conversion */
S#define  ADC_SR_JEOC                         ((uint32_t)0x00000004)        /*!< Injected channel end of conversion */
S#define  ADC_SR_JSTRT                        ((uint32_t)0x00000008)        /*!< Injected channel Start flag */
S#define  ADC_SR_STRT                         ((uint32_t)0x00000010)        /*!< Regular channel Start flag */
S#define  ADC_SR_OVR                          ((uint32_t)0x00000020)        /*!< Overrun flag */
S#define  ADC_SR_ADONS                        ((uint32_t)0x00000040)        /*!< ADC ON status */
S#define  ADC_SR_RCNR                         ((uint32_t)0x00000100)        /*!< Regular channel not ready flag */
S#define  ADC_SR_JCNR                         ((uint32_t)0x00000200)        /*!< Injected channel not ready flag */
S
S/*******************  Bit definition for ADC_CR1 register  ********************/
S#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
S#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */
S#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */
S#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */
S#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */
S#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */
S#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */
S#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */
S#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */
S
S#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
S#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */
S#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */
S#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */
S
S#define  ADC_CR1_PDD                         ((uint32_t)0x00010000)        /*!< Power Down during Delay phase */
S#define  ADC_CR1_PDI                         ((uint32_t)0x00020000)        /*!< Power Down during Idle phase */
S
S#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */
S#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */
S
S#define  ADC_CR1_RES                         ((uint32_t)0x03000000)        /*!< RES[1:0] bits (Resolution) */
S#define  ADC_CR1_RES_0                       ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_CR1_RES_1                       ((uint32_t)0x02000000)        /*!< Bit 1 */
S
S#define  ADC_CR1_OVRIE                       ((uint32_t)0x04000000)        /*!< Overrun interrupt enable */
S  
S/*******************  Bit definition for ADC_CR2 register  ********************/
S#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */
S#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */
S#define  ADC_CR2_CFG                         ((uint32_t)0x00000004)        /*!< ADC Configuration */
S
S#define  ADC_CR2_DELS                        ((uint32_t)0x00000070)        /*!< DELS[2:0] bits (Delay selection) */
S#define  ADC_CR2_DELS_0                      ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  ADC_CR2_DELS_1                      ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  ADC_CR2_DELS_2                      ((uint32_t)0x00000040)        /*!< Bit 2 */
S
S#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */
S#define  ADC_CR2_DDS                         ((uint32_t)0x00000200)        /*!< DMA disable selection (Single ADC) */
S#define  ADC_CR2_EOCS                        ((uint32_t)0x00000400)        /*!< End of conversion selection */
S#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */
S
S#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x000F0000)        /*!< JEXTSEL[3:0] bits (External event select for injected group) */
S#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  ADC_CR2_JEXTSEL_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  ADC_CR2_JEXTEN                      ((uint32_t)0x00300000)        /*!< JEXTEN[1:0] bits (External Trigger Conversion mode for injected channels) */
S#define  ADC_CR2_JEXTEN_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_CR2_JEXTEN_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00400000)        /*!< Start Conversion of injected channels */
S
S#define  ADC_CR2_EXTSEL                      ((uint32_t)0x0F000000)        /*!< EXTSEL[3:0] bits (External Event Select for regular group) */
S#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  ADC_CR2_EXTSEL_3                    ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  ADC_CR2_EXTEN                       ((uint32_t)0x30000000)        /*!< EXTEN[1:0] bits (External Trigger Conversion mode for regular channels) */
S#define  ADC_CR2_EXTEN_0                     ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  ADC_CR2_EXTEN_1                     ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S#define  ADC_CR2_SWSTART                     ((uint32_t)0x40000000)        /*!< Start Conversion of regular channels */
S
S/******************  Bit definition for ADC_SMPR1 register  *******************/
S#define  ADC_SMPR1_SMP20                     ((uint32_t)0x00000007)        /*!< SMP20[2:0] bits (Channel 20 Sample time selection) */
S#define  ADC_SMPR1_SMP20_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP20_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP20_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP21                     ((uint32_t)0x00000038)        /*!< SMP21[2:0] bits (Channel 21 Sample time selection) */
S#define  ADC_SMPR1_SMP21_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP21_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP21_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP22                     ((uint32_t)0x000001C0)        /*!< SMP22[2:0] bits (Channel 22 Sample time selection) */
S#define  ADC_SMPR1_SMP22_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP22_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP22_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP23                     ((uint32_t)0x00000E00)        /*!< SMP23[2:0] bits (Channel 23 Sample time selection) */
S#define  ADC_SMPR1_SMP23_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP23_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP23_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP24                     ((uint32_t)0x00007000)        /*!< SMP24[2:0] bits (Channel 24 Sample time selection) */
S#define  ADC_SMPR1_SMP24_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP24_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP24_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP25                     ((uint32_t)0x00038000)        /*!< SMP25[2:0] bits (Channel 25 Sample time selection) */
S#define  ADC_SMPR1_SMP25_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP25_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP25_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP26                     ((uint32_t)0x001C0000)        /*!< SMP26[2:0] bits (Channel 26 Sample time selection) */
S#define  ADC_SMPR1_SMP26_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP26_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP26_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP27                     ((uint32_t)0x00E00000)        /*!< SMP27[2:0] bits (Channel 27 Sample time selection) */
S#define  ADC_SMPR1_SMP27_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP27_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP27_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP28                     ((uint32_t)0x07000000)        /*!< SMP28[2:0] bits (Channel 28 Sample time selection) */
S#define  ADC_SMPR1_SMP28_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP28_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP28_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define  ADC_SMPR1_SMP29                     ((uint32_t)0x38000000)        /*!< SMP29[2:0] bits (Channel 29 Sample time selection) */
S#define  ADC_SMPR1_SMP29_0                   ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP29_1                   ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP29_2                   ((uint32_t)0x20000000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_SMPR2 register  *******************/
S#define  ADC_SMPR2_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
S#define  ADC_SMPR2_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
S#define  ADC_SMPR2_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
S#define  ADC_SMPR2_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
S#define  ADC_SMPR2_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
S#define  ADC_SMPR2_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 5 Sample time selection) */
S#define  ADC_SMPR2_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
S#define  ADC_SMPR2_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
S#define  ADC_SMPR2_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP18                     ((uint32_t)0x07000000)        /*!< SMP18[2:0] bits (Channel 18 Sample time selection) */
S#define  ADC_SMPR2_SMP18_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP18_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP18_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define  ADC_SMPR2_SMP19                     ((uint32_t)0x38000000)        /*!< SMP19[2:0] bits (Channel 19 Sample time selection) */
S#define  ADC_SMPR2_SMP19_0                   ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP19_1                   ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP19_2                   ((uint32_t)0x20000000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_SMPR3 register  *******************/
S#define  ADC_SMPR3_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
S#define  ADC_SMPR3_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
S 
S#define  ADC_SMPR3_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
S#define  ADC_SMPR3_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
S#define  ADC_SMPR3_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
S#define  ADC_SMPR3_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
S#define  ADC_SMPR3_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
S#define  ADC_SMPR3_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
S#define  ADC_SMPR3_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
S#define  ADC_SMPR3_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
S#define  ADC_SMPR3_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define  ADC_SMPR3_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
S#define  ADC_SMPR3_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_JOFR1 register  *******************/
S#define  ADC_JOFR1_JOFFSET1                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 1 */
S
S/******************  Bit definition for ADC_JOFR2 register  *******************/
S#define  ADC_JOFR2_JOFFSET2                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 2 */
S
S/******************  Bit definition for ADC_JOFR3 register  *******************/
S#define  ADC_JOFR3_JOFFSET3                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 3 */
S
S/******************  Bit definition for ADC_JOFR4 register  *******************/
S#define  ADC_JOFR4_JOFFSET4                  ((uint32_t)0x00000FFF)        /*!< Data offset for injected channel 4 */
S
S/*******************  Bit definition for ADC_HTR register  ********************/
S#define  ADC_HTR_HT                          ((uint32_t)0x00000FFF)        /*!< Analog watchdog high threshold */
S
S/*******************  Bit definition for ADC_LTR register  ********************/
S#define  ADC_LTR_LT                          ((uint32_t)0x00000FFF)         /*!< Analog watchdog low threshold */
S
S/*******************  Bit definition for ADC_SQR1 register  *******************/
S#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
S#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  ADC_SQR1_SQ28                       ((uint32_t)0x000F8000)        /*!< SQ28[4:0] bits (25th conversion in regular sequence) */
S#define  ADC_SQR1_SQ28_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ28_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ28_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ28_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ28_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ27                       ((uint32_t)0x00007C00)        /*!< SQ27[4:0] bits (27th conversion in regular sequence) */
S#define  ADC_SQR1_SQ27_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ27_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ27_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ27_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ27_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ26                       ((uint32_t)0x000003E0)        /*!< SQ26[4:0] bits (26th conversion in regular sequence) */
S#define  ADC_SQR1_SQ26_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ26_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ26_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ26_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ26_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR1_SQ25                       ((uint32_t)0x0000001F)        /*!< SQ25[4:0] bits (25th conversion in regular sequence) */
S#define  ADC_SQR1_SQ25_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ25_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ25_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ25_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ25_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR2 register  *******************/
S#define  ADC_SQR2_SQ19                       ((uint32_t)0x0000001F)        /*!< SQ19[4:0] bits (19th conversion in regular sequence) */
S#define  ADC_SQR2_SQ19_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ19_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ19_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ19_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ19_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ20                       ((uint32_t)0x000003E0)        /*!< SQ20[4:0] bits (20th conversion in regular sequence) */
S#define  ADC_SQR2_SQ20_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ20_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ20_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ20_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ20_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ21                       ((uint32_t)0x00007C00)        /*!< SQ21[4:0] bits (21th conversion in regular sequence) */
S#define  ADC_SQR2_SQ21_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ21_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ21_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ21_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ21_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ22                       ((uint32_t)0x000F8000)        /*!< SQ22[4:0] bits (22th conversion in regular sequence) */
S#define  ADC_SQR2_SQ22_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ22_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ22_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ22_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ22_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ23                       ((uint32_t)0x01F00000)        /*!< SQ23[4:0] bits (23th conversion in regular sequence) */
S#define  ADC_SQR2_SQ23_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ23_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ23_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ23_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ23_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR2_SQ24                       ((uint32_t)0x3E000000)        /*!< SQ24[4:0] bits (24th conversion in regular sequence) */
S#define  ADC_SQR2_SQ24_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ24_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ24_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ24_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ24_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR3 register  *******************/
S#define  ADC_SQR3_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
S#define  ADC_SQR3_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
S#define  ADC_SQR3_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
S#define  ADC_SQR3_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
S#define  ADC_SQR3_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ17                       ((uint32_t)0x01F00000)        /*!< SQ17[4:0] bits (17th conversion in regular sequence) */
S#define  ADC_SQR3_SQ17_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ17_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ17_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ17_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ17_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR3_SQ18                       ((uint32_t)0x3E000000)        /*!< SQ18[4:0] bits (18th conversion in regular sequence) */
S#define  ADC_SQR3_SQ18_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ18_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ18_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ18_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ18_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR4 register  *******************/
S#define  ADC_SQR4_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
S#define  ADC_SQR4_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR4_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
S#define  ADC_SQR4_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR4_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
S#define  ADC_SQR4_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR4_SQ10                        ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
S#define  ADC_SQR4_SQ10_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ10_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ10_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ10_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ10_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR4_SQ11                        ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
S#define  ADC_SQR4_SQ11_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ11_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ11_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ11_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ11_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR4_SQ12                        ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
S#define  ADC_SQR4_SQ12_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR4_SQ12_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR4_SQ12_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR4_SQ12_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR4_SQ12_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR5 register  *******************/
S#define  ADC_SQR5_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
S#define  ADC_SQR5_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_SQR5_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
S#define  ADC_SQR5_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_SQR5_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
S#define  ADC_SQR5_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_SQR5_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
S#define  ADC_SQR5_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_SQR5_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
S#define  ADC_SQR5_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
S
S#define  ADC_SQR5_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
S#define  ADC_SQR5_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR5_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR5_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR5_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR5_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S
S/*******************  Bit definition for ADC_JSQR register  *******************/
S#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
S#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
S#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S
S#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
S#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S/*******************  Bit definition for ADC_JDR1 register  *******************/
S#define  ADC_JDR1_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR2 register  *******************/
S#define  ADC_JDR2_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR3 register  *******************/
S#define  ADC_JDR3_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR4 register  *******************/
S#define  ADC_JDR4_JDATA                      ((uint32_t)0x0000FFFF)        /*!< Injected data */
S
S/********************  Bit definition for ADC_DR register  ********************/
S#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
S
S/******************  Bit definition for ADC_SMPR0 register  *******************/
S#define  ADC_SMPR3_SMP30                     ((uint32_t)0x00000007)        /*!< SMP30[2:0] bits (Channel 30 Sample time selection) */
S#define  ADC_SMPR3_SMP30_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP30_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP30_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */
S 
S#define  ADC_SMPR3_SMP31                     ((uint32_t)0x00000038)        /*!< SMP31[2:0] bits (Channel 31 Sample time selection) */
S#define  ADC_SMPR3_SMP31_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR3_SMP31_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR3_SMP31_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S/*******************  Bit definition for ADC_CSR register  ********************/
S#define  ADC_CSR_AWD1                        ((uint32_t)0x00000001)        /*!< ADC1 Analog watchdog flag */
S#define  ADC_CSR_EOC1                        ((uint32_t)0x00000002)        /*!< ADC1 End of conversion */
S#define  ADC_CSR_JEOC1                       ((uint32_t)0x00000004)        /*!< ADC1 Injected channel end of conversion */
S#define  ADC_CSR_JSTRT1                      ((uint32_t)0x00000008)        /*!< ADC1 Injected channel Start flag */
S#define  ADC_CSR_STRT1                       ((uint32_t)0x00000010)        /*!< ADC1 Regular channel Start flag */
S#define  ADC_CSR_OVR1                        ((uint32_t)0x00000020)        /*!< ADC1 overrun  flag */
S#define  ADC_CSR_ADONS1                      ((uint32_t)0x00000040)        /*!< ADON status of ADC1 */
S
S/*******************  Bit definition for ADC_CCR register  ********************/
S#define  ADC_CCR_ADCPRE                      ((uint32_t)0x00030000)        /*!< ADC prescaler*/
S#define  ADC_CCR_ADCPRE_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  ADC_CCR_ADCPRE_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */ 
S#define  ADC_CCR_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */
S
S/******************************************************************************/
S/*                                                                            */
S/*                       Advanced Encryption Standard (AES)                   */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for AES_CR register  *********************/
S#define  AES_CR_EN                           ((uint32_t)0x00000001)        /*!< AES Enable */
S#define  AES_CR_DATATYPE                     ((uint32_t)0x00000006)        /*!< Data type selection */
S#define  AES_CR_DATATYPE_0                   ((uint32_t)0x00000002)        /*!< Bit 0 */
S#define  AES_CR_DATATYPE_1                   ((uint32_t)0x00000004)        /*!< Bit 1 */
S
S#define  AES_CR_MODE                         ((uint32_t)0x00000018)        /*!< AES Mode Of Operation */
S#define  AES_CR_MODE_0                       ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  AES_CR_MODE_1                       ((uint32_t)0x00000010)        /*!< Bit 1 */
S
S#define  AES_CR_CHMOD                        ((uint32_t)0x00000060)        /*!< AES Chaining Mode */
S#define  AES_CR_CHMOD_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  AES_CR_CHMOD_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S
S#define  AES_CR_CCFC                         ((uint32_t)0x00000080)        /*!< Computation Complete Flag Clear */
S#define  AES_CR_ERRC                         ((uint32_t)0x00000100)        /*!< Error Clear */
S#define  AES_CR_CCIE                         ((uint32_t)0x00000200)        /*!< Computation Complete Interrupt Enable */
S#define  AES_CR_ERRIE                        ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
S#define  AES_CR_DMAINEN                      ((uint32_t)0x00000800)        /*!< DMA ENable managing the data input phase */
S#define  AES_CR_DMAOUTEN                     ((uint32_t)0x00001000)        /*!< DMA Enable managing the data output phase */
S
S/*******************  Bit definition for AES_SR register  *********************/
S#define  AES_SR_CCF                          ((uint32_t)0x00000001)        /*!< Computation Complete Flag */
S#define  AES_SR_RDERR                        ((uint32_t)0x00000002)        /*!< Read Error Flag */
S#define  AES_SR_WRERR                        ((uint32_t)0x00000004)        /*!< Write Error Flag */
S
S/*******************  Bit definition for AES_DINR register  *******************/
S#define  AES_DINR                            ((uint32_t)0x0000FFFF)        /*!< AES Data Input Register */
S
S/*******************  Bit definition for AES_DOUTR register  ******************/
S#define  AES_DOUTR                           ((uint32_t)0x0000FFFF)        /*!< AES Data Output Register */
S
S/*******************  Bit definition for AES_KEYR0 register  ******************/
S#define  AES_KEYR0                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 0 */
S
S/*******************  Bit definition for AES_KEYR1 register  ******************/
S#define  AES_KEYR1                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 1 */
S
S/*******************  Bit definition for AES_KEYR2 register  ******************/
S#define  AES_KEYR2                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 2 */
S
S/*******************  Bit definition for AES_KEYR3 register  ******************/
S#define  AES_KEYR3                           ((uint32_t)0x0000FFFF)        /*!< AES Key Register 3 */
S
S/*******************  Bit definition for AES_IVR0 register  *******************/
S#define  AES_IVR0                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 0 */
S
S/*******************  Bit definition for AES_IVR1 register  *******************/
S#define  AES_IVR1                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 1 */
S
S/*******************  Bit definition for AES_IVR2 register  *******************/
S#define  AES_IVR2                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 2 */
S
S/*******************  Bit definition for AES_IVR3 register  *******************/
S#define  AES_IVR3                            ((uint32_t)0x0000FFFF)        /*!< AES Initialization Vector Register 3 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Analog Comparators (COMP)                             */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for COMP_CSR register  ********************/
S#define  COMP_CSR_10KPU                      ((uint32_t)0x00000001)        /*!< 10K pull-up resistor */
S#define  COMP_CSR_400KPU                     ((uint32_t)0x00000002)        /*!< 400K pull-up resistor */
S#define  COMP_CSR_10KPD                      ((uint32_t)0x00000004)        /*!< 10K pull-down resistor */
S#define  COMP_CSR_400KPD                     ((uint32_t)0x00000008)        /*!< 400K pull-down resistor */
S
S#define  COMP_CSR_CMP1EN                     ((uint32_t)0x00000010)        /*!< Comparator 1 enable */
S#define  COMP_CSR_SW1                        ((uint32_t)0x00000020)        /*!< SW1 analog switch enable */
S#define  COMP_CSR_CMP1OUT                    ((uint32_t)0x00000080)        /*!< Comparator 1 output */
S
S#define  COMP_CSR_SPEED                      ((uint32_t)0x00001000)        /*!< Comparator 2 speed */
S#define  COMP_CSR_CMP2OUT                    ((uint32_t)0x00002000)        /*!< Comparator 2 ouput */
S
S#define  COMP_CSR_VREFOUTEN                  ((uint32_t)0x00010000)        /*!< Comparator Vref Enable */
S#define  COMP_CSR_WNDWE                      ((uint32_t)0x00020000)        /*!< Window mode enable */
S
S#define  COMP_CSR_INSEL                      ((uint32_t)0x001C0000)        /*!< INSEL[2:0] Inversion input Selection */
S#define  COMP_CSR_INSEL_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  COMP_CSR_INSEL_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  COMP_CSR_INSEL_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
S
S#define  COMP_CSR_OUTSEL                     ((uint32_t)0x00E00000)        /*!< OUTSEL[2:0] comparator 2 output redirection */
S#define  COMP_CSR_OUTSEL_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  COMP_CSR_OUTSEL_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  COMP_CSR_OUTSEL_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S#define  COMP_CSR_FCH3                       ((uint32_t)0x04000000)        /*!< Bit 26 */
S#define  COMP_CSR_FCH8                       ((uint32_t)0x08000000)        /*!< Bit 27 */
S#define  COMP_CSR_RCH13                      ((uint32_t)0x10000000)        /*!< Bit 28 */
S
S#define  COMP_CSR_CAIE                       ((uint32_t)0x20000000)        /*!< Bit 29 */
S#define  COMP_CSR_CAIF                       ((uint32_t)0x40000000)        /*!< Bit 30 */
S#define  COMP_CSR_TSUSP                      ((uint32_t)0x80000000)        /*!< Bit 31 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Operational Amplifier (OPAMP)                      */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for OPAMP_CSR register  ******************/
S#define OPAMP_CSR_OPA1PD                     ((uint32_t)0x00000001)        /*!< OPAMP1 disable */
S#define OPAMP_CSR_S3SEL1                     ((uint32_t)0x00000002)        /*!< Switch 3 for OPAMP1 Enable */
S#define OPAMP_CSR_S4SEL1                     ((uint32_t)0x00000004)        /*!< Switch 4 for OPAMP1 Enable */
S#define OPAMP_CSR_S5SEL1                     ((uint32_t)0x00000008)        /*!< Switch 5 for OPAMP1 Enable */
S#define OPAMP_CSR_S6SEL1                     ((uint32_t)0x00000010)        /*!< Switch 6 for OPAMP1 Enable */
S#define OPAMP_CSR_OPA1CAL_L                  ((uint32_t)0x00000020)        /*!< OPAMP1 Offset calibration for P differential pair */
S#define OPAMP_CSR_OPA1CAL_H                  ((uint32_t)0x00000040)        /*!< OPAMP1 Offset calibration for N differential pair */
S#define OPAMP_CSR_OPA1LPM                    ((uint32_t)0x00000080)        /*!< OPAMP1 Low power enable */
S#define OPAMP_CSR_OPA2PD                     ((uint32_t)0x00000100)        /*!< OPAMP2 disable */
S#define OPAMP_CSR_S3SEL2                     ((uint32_t)0x00000200)        /*!< Switch 3 for OPAMP2 Enable */
S#define OPAMP_CSR_S4SEL2                     ((uint32_t)0x00000400)        /*!< Switch 4 for OPAMP2 Enable */
S#define OPAMP_CSR_S5SEL2                     ((uint32_t)0x00000800)        /*!< Switch 5 for OPAMP2 Enable */
S#define OPAMP_CSR_S6SEL2                     ((uint32_t)0x00001000)        /*!< Switch 6 for OPAMP2 Enable */
S#define OPAMP_CSR_OPA2CAL_L                  ((uint32_t)0x00002000)        /*!< OPAMP2 Offset calibration for P differential pair */
S#define OPAMP_CSR_OPA2CAL_H                  ((uint32_t)0x00004000)        /*!< OPAMP2 Offset calibration for N differential pair */
S#define OPAMP_CSR_OPA2LPM                    ((uint32_t)0x00008000)        /*!< OPAMP2 Low power enable */
S#define OPAMP_CSR_OPA3PD                     ((uint32_t)0x00010000)        /*!< OPAMP3 disable */
S#define OPAMP_CSR_S3SEL3                     ((uint32_t)0x00020000)        /*!< Switch 3 for OPAMP3 Enable */
S#define OPAMP_CSR_S4SEL3                     ((uint32_t)0x00040000)        /*!< Switch 4 for OPAMP3 Enable */
S#define OPAMP_CSR_S5SEL3                     ((uint32_t)0x00080000)        /*!< Switch 5 for OPAMP3 Enable */
S#define OPAMP_CSR_S6SEL3                     ((uint32_t)0x00100000)        /*!< Switch 6 for OPAMP3 Enable */
S#define OPAMP_CSR_OPA3CAL_L                  ((uint32_t)0x00200000)        /*!< OPAMP3 Offset calibration for P differential pair */
S#define OPAMP_CSR_OPA3CAL_H                  ((uint32_t)0x00400000)        /*!< OPAMP3 Offset calibration for N differential pair */
S#define OPAMP_CSR_OPA3LPM                    ((uint32_t)0x00800000)        /*!< OPAMP3 Low power enable */
S#define OPAMP_CSR_ANAWSEL1                   ((uint32_t)0x01000000)        /*!< Switch ANA Enable for OPAMP1 */ 
S#define OPAMP_CSR_ANAWSEL2                   ((uint32_t)0x02000000)        /*!< Switch ANA Enable for OPAMP2 */
S#define OPAMP_CSR_ANAWSEL3                   ((uint32_t)0x04000000)        /*!< Switch ANA Enable for OPAMP3 */
S#define OPAMP_CSR_S7SEL2                     ((uint32_t)0x08000000)        /*!< Switch 7 for OPAMP2 Enable */
S#define OPAMP_CSR_AOP_RANGE                  ((uint32_t)0x10000000)        /*!< Power range selection */
S#define OPAMP_CSR_OPA1CALOUT                 ((uint32_t)0x20000000)        /*!< OPAMP1 calibration output */
S#define OPAMP_CSR_OPA2CALOUT                 ((uint32_t)0x40000000)        /*!< OPAMP2 calibration output */
S#define OPAMP_CSR_OPA3CALOUT                 ((uint32_t)0x80000000)        /*!< OPAMP3 calibration output */
S
S/*******************  Bit definition for OPAMP_OTR register  ******************/
S#define OPAMP_OTR_AO1_OPT_OFFSET_TRIM        ((uint32_t)0x000003FF)        /*!< Offset trim for OPAMP1 */
S#define OPAMP_OTR_AO2_OPT_OFFSET_TRIM        ((uint32_t)0x000FFC00)        /*!< Offset trim for OPAMP2 */
S#define OPAMP_OTR_AO3_OPT_OFFSET_TRIM        ((uint32_t)0x3FF00000)        /*!< Offset trim for OPAMP2 */
S#define OPAMP_OTR_OT_USER                    ((uint32_t)0x80000000)        /*!< Switch to OPAMP offset user trimmed values */
S
S/*******************  Bit definition for OPAMP_LPOTR register  ****************/
S#define OPAMP_LP_OTR_AO1_OPT_OFFSET_TRIM_LP  ((uint32_t)0x000003FF)        /*!< Offset trim in low power for OPAMP1 */
S#define OPAMP_LP_OTR_AO2_OPT_OFFSET_TRIM_LP  ((uint32_t)0x000FFC00)        /*!< Offset trim in low power for OPAMP2 */
S#define OPAMP_LP_OTR_AO3_OPT_OFFSET_TRIM_LP  ((uint32_t)0x3FF00000)        /*!< Offset trim in low power for OPAMP3 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                       CRC calculation unit (CRC)                           */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for CRC_DR register  *********************/
S#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF)        /*!< Data register bits */
S
S/*******************  Bit definition for CRC_IDR register  ********************/
S#define  CRC_IDR_IDR                         ((uint8_t)0xFF)               /*!< General-purpose 8-bit data register bits */
S
S/********************  Bit definition for CRC_CR register  ********************/
S#define  CRC_CR_RESET                        ((uint32_t)0x00000001)        /*!< RESET bit */
S
S/******************************************************************************/
S/*                                                                            */
S/*                    Digital to Analog Converter (DAC)                       */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for DAC_CR register  ********************/
S#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!<DAC channel1 enable */
S#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!<DAC channel1 output buffer disable */
S#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!<DAC channel1 Trigger enable */
S
S#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!<TSEL1[2:0] (DAC channel1 Trigger selection) */
S#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!<Bit 0 */
S#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!<Bit 1 */
S#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!<Bit 2 */
S
S#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!<WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!<Bit 0 */
S#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!<Bit 1 */
S
S#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!<MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!<Bit 0 */
S#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!<Bit 1 */
S#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!<Bit 2 */
S#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!<Bit 3 */
S
S#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!<DAC channel1 DMA enable */
S#define  DAC_CR_DMAUDRIE1                    ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun interrupt enable */
S#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!<DAC channel2 enable */
S#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!<DAC channel2 output buffer disable */
S#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!<DAC channel2 Trigger enable */
S
S#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!<TSEL2[2:0] (DAC channel2 Trigger selection) */
S#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!<Bit 0 */
S#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!<Bit 1 */
S#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!<Bit 2 */
S
S#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!<WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!<Bit 0 */
S#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!<Bit 1 */
S
S#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!<MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!<Bit 0 */
S#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!<Bit 1 */
S#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!<Bit 2 */
S#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!<Bit 3 */
S
S#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!<DAC channel2 DMA enabled */
S#define  DAC_CR_DMAUDRIE2                    ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun interrupt enable */
S/*****************  Bit definition for DAC_SWTRIGR register  ******************/
S#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!<DAC channel1 software trigger */
S#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!<DAC channel2 software trigger */
S
S/*****************  Bit definition for DAC_DHR12R1 register  ******************/
S#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!<DAC channel1 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L1 register  ******************/
S#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!<DAC channel1 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R1 register  ******************/
S#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!<DAC channel1 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12R2 register  ******************/
S#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!<DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L2 register  ******************/
S#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!<DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R2 register  ******************/
S#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!<DAC channel2 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12RD register  ******************/
S#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!<DAC channel1 12-bit Right aligned data */
S#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!<DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12LD register  ******************/
S#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!<DAC channel1 12-bit Left aligned data */
S#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!<DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8RD register  ******************/
S#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!<DAC channel1 8-bit Right aligned data */
S#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!<DAC channel2 8-bit Right aligned data */
S
S/*******************  Bit definition for DAC_DOR1 register  *******************/
S#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel1 data output */
S
S/*******************  Bit definition for DAC_DOR2 register  *******************/
S#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!<DAC channel2 data output */
S
S/********************  Bit definition for DAC_SR register  ********************/
S#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!<DAC channel1 DMA underrun flag */
S#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!<DAC channel2 DMA underrun flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Debug MCU (DBGMCU)                               */
S/*                                                                            */
S/******************************************************************************/
S
S/****************  Bit definition for DBGMCU_IDCODE register  *****************/
S#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
S
S#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
S#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
S#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
S#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
S#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
S#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
S#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
S#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
S#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
S#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
S#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
S#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
S#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
S#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
S
S/******************  Bit definition for DBGMCU_CR register  *******************/
S#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */
S#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
S#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
S#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */
S
S#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
S#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
S
S#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP             ((uint32_t)0x00000001)   /*!< TIM2 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP             ((uint32_t)0x00000002)   /*!< TIM3 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP             ((uint32_t)0x00000004)   /*!< TIM4 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP             ((uint32_t)0x00000008)   /*!< TIM5 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP             ((uint32_t)0x00000010)   /*!< TIM6 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP             ((uint32_t)0x00000020)   /*!< TIM7 counter stopped when core is halted */
S#define  DBGMCU_APB1_FZ_DBG_RTC_STOP              ((uint32_t)0x00000400)   /*!< RTC Counter stopped when Core is halted */
S#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP             ((uint32_t)0x00000800)   /*!< Debug Window Watchdog stopped when Core is halted */
S#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP             ((uint32_t)0x00001000)   /*!< Debug Independent Watchdog stopped when Core is halted */
S#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)   /*!< SMBUS timeout mode stopped when Core is halted */
S#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)   /*!< SMBUS timeout mode stopped when Core is halted */
S
S/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
S
S#define  DBGMCU_APB2_FZ_DBG_TIM9_STOP             ((uint32_t)0x00000004)   /*!< TIM9 counter stopped when core is halted */
S#define  DBGMCU_APB2_FZ_DBG_TIM10_STOP            ((uint32_t)0x00000008)   /*!< TIM10 counter stopped when core is halted */
S#define  DBGMCU_APB2_FZ_DBG_TIM11_STOP            ((uint32_t)0x00000010)   /*!< TIM11 counter stopped when core is halted */
S
S/******************************************************************************/
S/*                                                                            */
S/*                           DMA Controller (DMA)                             */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for DMA_ISR register  ********************/
S#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
S#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
S#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
S#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
S#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
S#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
S#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
S#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
S#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
S#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
S#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
S#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
S#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
S#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
S#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
S#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
S#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
S#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
S#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
S#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
S#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
S#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
S#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
S#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
S#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
S#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
S#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
S#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
S
S/*******************  Bit definition for DMA_IFCR register  *******************/
S#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clearr */
S#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
S#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
S#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
S#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
S#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
S#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
S#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
S#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
S#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
S#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
S#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
S#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
S#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
S#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
S#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
S#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
S#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
S#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
S#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
S#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
S
S/*******************  Bit definition for DMA_CCR1 register  *******************/
S#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/
S#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */
S#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR2 register  *******************/
S#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< ransfer complete interrupt enable */
S#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR3 register  *******************/
S#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*!<******************  Bit definition for DMA_CCR4 register  *******************/
S#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/******************  Bit definition for DMA_CCR5 register  *******************/
S#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
S
S/*******************  Bit definition for DMA_CCR6 register  *******************/
S#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */
S
S/*******************  Bit definition for DMA_CCR7 register  *******************/
S#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */
S#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */
S#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */
S#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */
S#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */
S#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */
S#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */
S#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */
S
S#define  DMA_CCR7_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */
S#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */
S
S#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */
S#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */
S
S#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */
S#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */
S
S/******************  Bit definition for DMA_CNDTR1 register  ******************/
S#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR2 register  ******************/
S#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR3 register  ******************/
S#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR4 register  ******************/
S#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR5 register  ******************/
S#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR6 register  ******************/
S#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CNDTR7 register  ******************/
S#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */
S
S/******************  Bit definition for DMA_CPAR1 register  *******************/
S#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR2 register  *******************/
S#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR3 register  *******************/
S#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S
S/******************  Bit definition for DMA_CPAR4 register  *******************/
S#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR5 register  *******************/
S#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CPAR6 register  *******************/
S#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S
S/******************  Bit definition for DMA_CPAR7 register  *******************/
S#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */
S
S/******************  Bit definition for DMA_CMAR1 register  *******************/
S#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR2 register  *******************/
S#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR3 register  *******************/
S#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S
S/******************  Bit definition for DMA_CMAR4 register  *******************/
S#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR5 register  *******************/
S#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR6 register  *******************/
S#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************  Bit definition for DMA_CMAR7 register  *******************/
S#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */
S
S/******************************************************************************/
S/*                                                                            */
S/*                  External Interrupt/Event Controller (EXTI)                */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for EXTI_IMR register  *******************/
S#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
S#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
S#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
S#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
S#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
S#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
S#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
S#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
S#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
S#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
S#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
S#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
S#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
S#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
S#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
S#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
S#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
S#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
S#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
S#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
S#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
S#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
S#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
S#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
S
S/*******************  Bit definition for EXTI_EMR register  *******************/
S#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
S#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
S#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
S#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
S#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
S#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
S#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
S#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
S#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
S#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
S#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
S#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
S#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
S#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
S#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
S#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
S#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
S#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
S#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
S#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
S#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
S#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
S#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
S#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
S
S/******************  Bit definition for EXTI_RTSR register  *******************/
S#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
S#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
S#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
S#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
S#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
S#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
S#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
S#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
S#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
S#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
S#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
S#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
S#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
S#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
S#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
S#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
S#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
S#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
S#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
S#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
S#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
S#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
S#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
S#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
S
S/******************  Bit definition for EXTI_FTSR register  *******************/
S#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
S#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
S#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
S#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
S#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
S#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
S#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
S#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
S#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
S#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
S#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
S#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
S#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
S#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
S#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
S#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
S#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
S#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
S#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
S#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
S#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
S#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
S#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
S#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
S
S/******************  Bit definition for EXTI_SWIER register  ******************/
S#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
S#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
S#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
S#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
S#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
S#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
S#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
S#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
S#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
S#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
S#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
S#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
S#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
S#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
S#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
S#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
S#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
S#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
S#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
S#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
S#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
S#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
S#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
S#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
S
S/*******************  Bit definition for EXTI_PR register  ********************/
S#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit 0 */
S#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit 1 */
S#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit 2 */
S#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit 3 */
S#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit 4 */
S#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit 5 */
S#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit 6 */
S#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit 7 */
S#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit 8 */
S#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit 9 */
S#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit 10 */
S#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit 11 */
S#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit 12 */
S#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit 13 */
S#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit 14 */
S#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit 15 */
S#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit 16 */
S#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit 17 */
S#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit 18 */
S#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit 19 */
S#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit 20 */
S#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit 21 */
S#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit 22 */
S#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit 23 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                FLASH, DATA EEPROM and Option Bytes Registers               */
S/*                        (FLASH, DATA_EEPROM, OB)                            */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for FLASH_ACR register  ******************/
S#define  FLASH_ACR_LATENCY                   ((uint32_t)0x00000001)        /*!< Latency */
S#define  FLASH_ACR_PRFTEN                    ((uint32_t)0x00000002)        /*!< Prefetch Buffer Enable */
S#define  FLASH_ACR_ACC64                     ((uint32_t)0x00000004)        /*!< Access 64 bits */
S#define  FLASH_ACR_SLEEP_PD                  ((uint32_t)0x00000008)        /*!< Flash mode during sleep mode */
S#define  FLASH_ACR_RUN_PD                    ((uint32_t)0x00000010)        /*!< Flash mode during RUN mode */
S
S/*******************  Bit definition for FLASH_PECR register  ******************/
S#define FLASH_PECR_PELOCK                    ((uint32_t)0x00000001)        /*!< FLASH_PECR and Flash data Lock */
S#define FLASH_PECR_PRGLOCK                   ((uint32_t)0x00000002)        /*!< Program matrix Lock */
S#define FLASH_PECR_OPTLOCK                   ((uint32_t)0x00000004)        /*!< Option byte matrix Lock */
S#define FLASH_PECR_PROG                      ((uint32_t)0x00000008)        /*!< Program matrix selection */
S#define FLASH_PECR_DATA                      ((uint32_t)0x00000010)        /*!< Data matrix selection */
S#define FLASH_PECR_FTDW                      ((uint32_t)0x00000100)        /*!< Fixed Time Data write for Word/Half Word/Byte programming */
S#define FLASH_PECR_ERASE                     ((uint32_t)0x00000200)        /*!< Page erasing mode */
S#define FLASH_PECR_FPRG                      ((uint32_t)0x00000400)        /*!< Fast Page/Half Page programming mode */
S#define FLASH_PECR_PARALLBANK                ((uint32_t)0x00008000)        /*!< Parallel Bank mode */
S#define FLASH_PECR_EOPIE                     ((uint32_t)0x00010000)        /*!< End of programming interrupt */ 
S#define FLASH_PECR_ERRIE                     ((uint32_t)0x00020000)        /*!< Error interrupt */ 
S#define FLASH_PECR_OBL_LAUNCH                ((uint32_t)0x00040000)        /*!< Launch the option byte loading */ 
S
S/******************  Bit definition for FLASH_PDKEYR register  ******************/
S#define  FLASH_PDKEYR_PDKEYR                 ((uint32_t)0xFFFFFFFF)       /*!< FLASH_PEC and data matrix Key */
S
S/******************  Bit definition for FLASH_PEKEYR register  ******************/
S#define  FLASH_PEKEYR_PEKEYR                 ((uint32_t)0xFFFFFFFF)       /*!< FLASH_PEC and data matrix Key */
S
S/******************  Bit definition for FLASH_PRGKEYR register  ******************/
S#define  FLASH_PRGKEYR_PRGKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Program matrix Key */
S
S/******************  Bit definition for FLASH_OPTKEYR register  ******************/
S#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option bytes matrix Key */
S
S/******************  Bit definition for FLASH_SR register  *******************/
S#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
S#define  FLASH_SR_EOP                        ((uint32_t)0x00000002)        /*!< End Of Programming*/
S#define  FLASH_SR_ENHV                       ((uint32_t)0x00000004)        /*!< End of high voltage */
S#define  FLASH_SR_READY                      ((uint32_t)0x00000008)        /*!< Flash ready after low power mode */
S
S#define  FLASH_SR_WRPERR                     ((uint32_t)0x00000100)        /*!< Write protected error */
S#define  FLASH_SR_PGAERR                     ((uint32_t)0x00000200)        /*!< Programming Alignment Error */
S#define  FLASH_SR_SIZERR                     ((uint32_t)0x00000400)        /*!< Size error */
S#define  FLASH_SR_OPTVERR                    ((uint32_t)0x00000800)        /*!< Option validity error */
S#define  FLASH_SR_OPTVERRUSR                 ((uint32_t)0x00001000)        /*!< Option User validity error */
S#define  FLASH_SR_RDERR                      ((uint32_t)0x00002000)        /*!< Read protected error */
S
S/******************  Bit definition for FLASH_OBR register  *******************/
S#define  FLASH_OBR_RDPRT                     ((uint32_t)0x000000AA)        /*!< Read Protection */
S#define  FLASH_OBR_SPRMOD                    ((uint32_t)0x00000100)        /*!< Selection of protection mode of WPRi bits 
S                                                                                (available only in STM32L1xx Medium-density Plus devices) */
S#define  FLASH_OBR_BOR_LEV                   ((uint32_t)0x000F0000)        /*!< BOR_LEV[3:0] Brown Out Reset Threshold Level*/
S#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00100000)        /*!< IWDG_SW */
S#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00200000)        /*!< nRST_STOP */
S#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00400000)        /*!< nRST_STDBY */
S#define  FLASH_OBR_BFB2                      ((uint32_t)0x00800000)        /*!< BFB2(available only in STM32L1xx High-density devices) */
S
S/******************  Bit definition for FLASH_WRPR register  ******************/
S#define  FLASH_WRPR_WRP                      ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits */
S
S/******************  Bit definition for FLASH_WRPR1 register  *****************/
S#define  FLASH_WRPR1_WRP                     ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits (available only in STM32L1xx
S                                                                                Medium-density Plus and High-density devices) */
S
S/******************  Bit definition for FLASH_WRPR2 register  *****************/
S#define  FLASH_WRPR2_WRP                     ((uint32_t)0xFFFFFFFF)        /*!< Write Protection bits (available only in STM32L1xx
S                                                                                High-density devices) */
S/******************************************************************************/
S/*                                                                            */
S/*                       Flexible Static Memory Controller                    */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for FSMC_BCR1 register  *******************/
S#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR2 register  *******************/
S#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR3 register  *******************/
S#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */
S#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BCR4 register  *******************/
S#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */
S#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */
S
S#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */
S#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */
S#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */
S
S#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */
S#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */
S#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */
S#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */
S#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */
S#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */
S#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */
S#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */
S#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */
S#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */
S
S/******************  Bit definition for FSMC_BTR1 register  ******************/
S#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BTR2 register  *******************/
S#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/*******************  Bit definition for FSMC_BTR3 register  *******************/
S#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BTR4 register  *******************/
S#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */
S#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */
S#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */
S#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR1 register  ******************/
S#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR2 register  ******************/
S#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/
S#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR3 register  ******************/
S#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************  Bit definition for FSMC_BWTR4 register  ******************/
S#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */
S#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */
S#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */
S#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */
S#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */
S#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */
S#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      General Purpose IOs (GPIO)                            */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for GPIO_MODER register  *****************/  
S#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
S#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
S#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
S#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
S#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
S#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
S#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
S#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
S#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
S#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
S#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
S#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
S#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
S#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
S#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
S#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
S#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
S#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
S#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
S#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
S#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
S#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
S#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
S#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
S#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
S#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
S#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
S#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
S#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
S#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
S#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
S#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
S#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
S#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
S#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
S#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
S#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
S#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
S#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
S#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
S#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
S#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
S#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
S#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
S#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
S#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
S#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
S#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
S
S/*******************  Bit definition for GPIO_OTYPER register  ****************/   
S#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
S#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
S#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
S#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
S#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
S#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
S#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
S#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
S#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
S#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
S#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
S#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
S#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
S#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
S#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
S#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
S
S/*******************  Bit definition for GPIO_OSPEEDR register  ***************/  
S#define GPIO_OSPEEDER_OSPEEDR0     ((uint32_t)0x00000003)
S#define GPIO_OSPEEDER_OSPEEDR0_0   ((uint32_t)0x00000001)
S#define GPIO_OSPEEDER_OSPEEDR0_1   ((uint32_t)0x00000002)
S#define GPIO_OSPEEDER_OSPEEDR1     ((uint32_t)0x0000000C)
S#define GPIO_OSPEEDER_OSPEEDR1_0   ((uint32_t)0x00000004)
S#define GPIO_OSPEEDER_OSPEEDR1_1   ((uint32_t)0x00000008)
S#define GPIO_OSPEEDER_OSPEEDR2     ((uint32_t)0x00000030)
S#define GPIO_OSPEEDER_OSPEEDR2_0   ((uint32_t)0x00000010)
S#define GPIO_OSPEEDER_OSPEEDR2_1   ((uint32_t)0x00000020)
S#define GPIO_OSPEEDER_OSPEEDR3     ((uint32_t)0x000000C0)
S#define GPIO_OSPEEDER_OSPEEDR3_0   ((uint32_t)0x00000040)
S#define GPIO_OSPEEDER_OSPEEDR3_1   ((uint32_t)0x00000080)
S#define GPIO_OSPEEDER_OSPEEDR4     ((uint32_t)0x00000300)
S#define GPIO_OSPEEDER_OSPEEDR4_0   ((uint32_t)0x00000100)
S#define GPIO_OSPEEDER_OSPEEDR4_1   ((uint32_t)0x00000200)
S#define GPIO_OSPEEDER_OSPEEDR5     ((uint32_t)0x00000C00)
S#define GPIO_OSPEEDER_OSPEEDR5_0   ((uint32_t)0x00000400)
S#define GPIO_OSPEEDER_OSPEEDR5_1   ((uint32_t)0x00000800)
S#define GPIO_OSPEEDER_OSPEEDR6     ((uint32_t)0x00003000)
S#define GPIO_OSPEEDER_OSPEEDR6_0   ((uint32_t)0x00001000)
S#define GPIO_OSPEEDER_OSPEEDR6_1   ((uint32_t)0x00002000)
S#define GPIO_OSPEEDER_OSPEEDR7     ((uint32_t)0x0000C000)
S#define GPIO_OSPEEDER_OSPEEDR7_0   ((uint32_t)0x00004000)
S#define GPIO_OSPEEDER_OSPEEDR7_1   ((uint32_t)0x00008000)
S#define GPIO_OSPEEDER_OSPEEDR8     ((uint32_t)0x00030000)
S#define GPIO_OSPEEDER_OSPEEDR8_0   ((uint32_t)0x00010000)
S#define GPIO_OSPEEDER_OSPEEDR8_1   ((uint32_t)0x00020000)
S#define GPIO_OSPEEDER_OSPEEDR9     ((uint32_t)0x000C0000)
S#define GPIO_OSPEEDER_OSPEEDR9_0   ((uint32_t)0x00040000)
S#define GPIO_OSPEEDER_OSPEEDR9_1   ((uint32_t)0x00080000)
S#define GPIO_OSPEEDER_OSPEEDR10    ((uint32_t)0x00300000)
S#define GPIO_OSPEEDER_OSPEEDR10_0  ((uint32_t)0x00100000)
S#define GPIO_OSPEEDER_OSPEEDR10_1  ((uint32_t)0x00200000)
S#define GPIO_OSPEEDER_OSPEEDR11    ((uint32_t)0x00C00000)
S#define GPIO_OSPEEDER_OSPEEDR11_0  ((uint32_t)0x00400000)
S#define GPIO_OSPEEDER_OSPEEDR11_1  ((uint32_t)0x00800000)
S#define GPIO_OSPEEDER_OSPEEDR12    ((uint32_t)0x03000000)
S#define GPIO_OSPEEDER_OSPEEDR12_0  ((uint32_t)0x01000000)
S#define GPIO_OSPEEDER_OSPEEDR12_1  ((uint32_t)0x02000000)
S#define GPIO_OSPEEDER_OSPEEDR13    ((uint32_t)0x0C000000)
S#define GPIO_OSPEEDER_OSPEEDR13_0  ((uint32_t)0x04000000)
S#define GPIO_OSPEEDER_OSPEEDR13_1  ((uint32_t)0x08000000)
S#define GPIO_OSPEEDER_OSPEEDR14    ((uint32_t)0x30000000)
S#define GPIO_OSPEEDER_OSPEEDR14_0  ((uint32_t)0x10000000)
S#define GPIO_OSPEEDER_OSPEEDR14_1  ((uint32_t)0x20000000)
S#define GPIO_OSPEEDER_OSPEEDR15    ((uint32_t)0xC0000000)
S#define GPIO_OSPEEDER_OSPEEDR15_0  ((uint32_t)0x40000000)
S#define GPIO_OSPEEDER_OSPEEDR15_1  ((uint32_t)0x80000000)
S
S/*******************  Bit definition for GPIO_PUPDR register  *****************/  
S#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
S#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
S#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
S#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
S#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
S#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
S#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
S#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
S#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
S#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
S#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
S#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
S#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
S#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
S#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
S#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
S#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
S#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
S#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
S#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
S#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
S#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
S#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
S#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
S#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
S#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
S#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
S#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
S#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
S#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
S#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
S#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
S#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
S#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
S#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
S#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
S#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
S#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
S#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
S#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
S#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
S#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
S#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
S#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
S#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
S#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
S#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
S#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
S
S/******************  Bits definition for GPIO_IDR register  *******************/
S#define GPIO_IDR_IDR_0                       ((uint32_t)0x00000001)
S#define GPIO_IDR_IDR_1                       ((uint32_t)0x00000002)
S#define GPIO_IDR_IDR_2                       ((uint32_t)0x00000004)
S#define GPIO_IDR_IDR_3                       ((uint32_t)0x00000008)
S#define GPIO_IDR_IDR_4                       ((uint32_t)0x00000010)
S#define GPIO_IDR_IDR_5                       ((uint32_t)0x00000020)
S#define GPIO_IDR_IDR_6                       ((uint32_t)0x00000040)
S#define GPIO_IDR_IDR_7                       ((uint32_t)0x00000080)
S#define GPIO_IDR_IDR_8                       ((uint32_t)0x00000100)
S#define GPIO_IDR_IDR_9                       ((uint32_t)0x00000200)
S#define GPIO_IDR_IDR_10                      ((uint32_t)0x00000400)
S#define GPIO_IDR_IDR_11                      ((uint32_t)0x00000800)
S#define GPIO_IDR_IDR_12                      ((uint32_t)0x00001000)
S#define GPIO_IDR_IDR_13                      ((uint32_t)0x00002000)
S#define GPIO_IDR_IDR_14                      ((uint32_t)0x00004000)
S#define GPIO_IDR_IDR_15                      ((uint32_t)0x00008000)
S/* Old GPIO_IDR register bits definition, maintained for legacy purpose */
S#define GPIO_OTYPER_IDR_0                    GPIO_IDR_IDR_0
S#define GPIO_OTYPER_IDR_1                    GPIO_IDR_IDR_1
S#define GPIO_OTYPER_IDR_2                    GPIO_IDR_IDR_2
S#define GPIO_OTYPER_IDR_3                    GPIO_IDR_IDR_3
S#define GPIO_OTYPER_IDR_4                    GPIO_IDR_IDR_4
S#define GPIO_OTYPER_IDR_5                    GPIO_IDR_IDR_5
S#define GPIO_OTYPER_IDR_6                    GPIO_IDR_IDR_6
S#define GPIO_OTYPER_IDR_7                    GPIO_IDR_IDR_7
S#define GPIO_OTYPER_IDR_8                    GPIO_IDR_IDR_8
S#define GPIO_OTYPER_IDR_9                    GPIO_IDR_IDR_9
S#define GPIO_OTYPER_IDR_10                   GPIO_IDR_IDR_10
S#define GPIO_OTYPER_IDR_11                   GPIO_IDR_IDR_11
S#define GPIO_OTYPER_IDR_12                   GPIO_IDR_IDR_12
S#define GPIO_OTYPER_IDR_13                   GPIO_IDR_IDR_13
S#define GPIO_OTYPER_IDR_14                   GPIO_IDR_IDR_14
S#define GPIO_OTYPER_IDR_15                   GPIO_IDR_IDR_15
S
S/******************  Bits definition for GPIO_ODR register  *******************/
S#define GPIO_ODR_ODR_0                       ((uint32_t)0x00000001)
S#define GPIO_ODR_ODR_1                       ((uint32_t)0x00000002)
S#define GPIO_ODR_ODR_2                       ((uint32_t)0x00000004)
S#define GPIO_ODR_ODR_3                       ((uint32_t)0x00000008)
S#define GPIO_ODR_ODR_4                       ((uint32_t)0x00000010)
S#define GPIO_ODR_ODR_5                       ((uint32_t)0x00000020)
S#define GPIO_ODR_ODR_6                       ((uint32_t)0x00000040)
S#define GPIO_ODR_ODR_7                       ((uint32_t)0x00000080)
S#define GPIO_ODR_ODR_8                       ((uint32_t)0x00000100)
S#define GPIO_ODR_ODR_9                       ((uint32_t)0x00000200)
S#define GPIO_ODR_ODR_10                      ((uint32_t)0x00000400)
S#define GPIO_ODR_ODR_11                      ((uint32_t)0x00000800)
S#define GPIO_ODR_ODR_12                      ((uint32_t)0x00001000)
S#define GPIO_ODR_ODR_13                      ((uint32_t)0x00002000)
S#define GPIO_ODR_ODR_14                      ((uint32_t)0x00004000)
S#define GPIO_ODR_ODR_15                      ((uint32_t)0x00008000)
S/* Old GPIO_ODR register bits definition, maintained for legacy purpose */
S#define GPIO_OTYPER_ODR_0                    GPIO_ODR_ODR_0
S#define GPIO_OTYPER_ODR_1                    GPIO_ODR_ODR_1
S#define GPIO_OTYPER_ODR_2                    GPIO_ODR_ODR_2
S#define GPIO_OTYPER_ODR_3                    GPIO_ODR_ODR_3
S#define GPIO_OTYPER_ODR_4                    GPIO_ODR_ODR_4
S#define GPIO_OTYPER_ODR_5                    GPIO_ODR_ODR_5
S#define GPIO_OTYPER_ODR_6                    GPIO_ODR_ODR_6
S#define GPIO_OTYPER_ODR_7                    GPIO_ODR_ODR_7
S#define GPIO_OTYPER_ODR_8                    GPIO_ODR_ODR_8
S#define GPIO_OTYPER_ODR_9                    GPIO_ODR_ODR_9
S#define GPIO_OTYPER_ODR_10                   GPIO_ODR_ODR_10
S#define GPIO_OTYPER_ODR_11                   GPIO_ODR_ODR_11
S#define GPIO_OTYPER_ODR_12                   GPIO_ODR_ODR_12
S#define GPIO_OTYPER_ODR_13                   GPIO_ODR_ODR_13
S#define GPIO_OTYPER_ODR_14                   GPIO_ODR_ODR_14
S#define GPIO_OTYPER_ODR_15                   GPIO_ODR_ODR_15
S
S/*******************  Bit definition for GPIO_BSRR register  ******************/  
S#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
S#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
S#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
S#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
S#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
S#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
S#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
S#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
S#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
S#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
S#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
S#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
S#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
S#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
S#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
S#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
S#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
S#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
S#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
S#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
S#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
S#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
S#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
S#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
S#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
S#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
S#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
S#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
S#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
S#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
S#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
S#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
S
S/*******************  Bit definition for GPIO_LCKR register  ******************/
S#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
S#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
S#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
S#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
S#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
S#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
S#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
S#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
S#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
S#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
S#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
S#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
S#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
S#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
S#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
S#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
S#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
S
S/*******************  Bit definition for GPIO_AFRL register  ******************/
S#define GPIO_AFRL_AFRL0            ((uint32_t)0x0000000F)
S#define GPIO_AFRL_AFRL1            ((uint32_t)0x000000F0)
S#define GPIO_AFRL_AFRL2            ((uint32_t)0x00000F00)
S#define GPIO_AFRL_AFRL3            ((uint32_t)0x0000F000)
S#define GPIO_AFRL_AFRL4            ((uint32_t)0x000F0000)
S#define GPIO_AFRL_AFRL5            ((uint32_t)0x00F00000)
S#define GPIO_AFRL_AFRL6            ((uint32_t)0x0F000000)
S#define GPIO_AFRL_AFRL7            ((uint32_t)0xF0000000)
S
S/*******************  Bit definition for GPIO_AFRH register  ******************/
S#define GPIO_AFRH_AFRH8            ((uint32_t)0x0000000F)
S#define GPIO_AFRH_AFRH9            ((uint32_t)0x000000F0)
S#define GPIO_AFRH_AFRH10           ((uint32_t)0x00000F00)
S#define GPIO_AFRH_AFRH11           ((uint32_t)0x0000F000)
S#define GPIO_AFRH_AFRH12           ((uint32_t)0x000F0000)
S#define GPIO_AFRH_AFRH13           ((uint32_t)0x00F00000)
S#define GPIO_AFRH_AFRH14           ((uint32_t)0x0F000000)
S#define GPIO_AFRH_AFRH15           ((uint32_t)0xF0000000)
S
S/******************************************************************************/
S/*                                                                            */
S/*                   Inter-integrated Circuit Interface (I2C)                 */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for I2C_CR1 register  ********************/
S#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */
S#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */
S#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */
S#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */
S#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */
S#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */
S#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */
S#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */
S#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */
S#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */
S#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */
S#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */
S#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */
S#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */
S
S/*******************  Bit definition for I2C_CR2 register  ********************/
S#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
S#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */
S
S#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */
S#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */
S#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */
S#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */
S#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */
S
S/*******************  Bit definition for I2C_OAR1 register  *******************/
S#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */
S#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */
S
S#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */
S#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */
S#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */
S#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */
S
S#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */
S
S/*******************  Bit definition for I2C_OAR2 register  *******************/
S#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */
S#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */
S
S/********************  Bit definition for I2C_DR register  ********************/
S#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */
S
S/*******************  Bit definition for I2C_SR1 register  ********************/
S#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */
S#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */
S#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */
S#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */
S#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */
S#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */
S#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */
S#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */
S#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */
S#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */
S#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */
S#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */
S#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */
S#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */
S
S/*******************  Bit definition for I2C_SR2 register  ********************/
S#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */
S#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */
S#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */
S#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */
S#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */
S#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */
S#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */
S#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */
S
S/*******************  Bit definition for I2C_CCR register  ********************/
S#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */
S#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */
S#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */
S
S/******************  Bit definition for I2C_TRISE register  *******************/
S#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Independent WATCHDOG (IWDG)                         */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for IWDG_KR register  ********************/
S#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
S
S/*******************  Bit definition for IWDG_PR register  ********************/
S#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
S#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
S#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
S#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
S
S/*******************  Bit definition for IWDG_RLR register  *******************/
S#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
S
S/*******************  Bit definition for IWDG_SR register  ********************/
S#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
S#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          LCD Controller (LCD)                              */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for LCD_CR register  *********************/
S#define LCD_CR_LCDEN               ((uint32_t)0x00000001)     /*!< LCD Enable Bit */
S#define LCD_CR_VSEL                ((uint32_t)0x00000002)     /*!< Voltage source selector Bit */
S
S#define LCD_CR_DUTY                ((uint32_t)0x0000001C)     /*!< DUTY[2:0] bits (Duty selector) */
S#define LCD_CR_DUTY_0              ((uint32_t)0x00000004)     /*!< Duty selector Bit 0 */
S#define LCD_CR_DUTY_1              ((uint32_t)0x00000008)     /*!< Duty selector Bit 1 */
S#define LCD_CR_DUTY_2              ((uint32_t)0x00000010)     /*!< Duty selector Bit 2 */
S
S#define LCD_CR_BIAS                ((uint32_t)0x00000060)     /*!< BIAS[1:0] bits (Bias selector) */
S#define LCD_CR_BIAS_0              ((uint32_t)0x00000020)     /*!< Bias selector Bit 0 */
S#define LCD_CR_BIAS_1              ((uint32_t)0x00000040)     /*!< Bias selector Bit 1 */
S
S#define LCD_CR_MUX_SEG             ((uint32_t)0x00000080)     /*!< Mux Segment Enable Bit */
S
S/*******************  Bit definition for LCD_FCR register  ********************/
S#define LCD_FCR_HD                 ((uint32_t)0x00000001)     /*!< High Drive Enable Bit */
S#define LCD_FCR_SOFIE              ((uint32_t)0x00000002)     /*!< Start of Frame Interrupt Enable Bit */
S#define LCD_FCR_UDDIE              ((uint32_t)0x00000008)     /*!< Update Display Done Interrupt Enable Bit */
S
S#define LCD_FCR_PON                ((uint32_t)0x00000070)     /*!< PON[2:0] bits (Puls ON Duration) */
S#define LCD_FCR_PON_0              ((uint32_t)0x00000010)     /*!< Bit 0 */
S#define LCD_FCR_PON_1              ((uint32_t)0x00000020)     /*!< Bit 1 */
S#define LCD_FCR_PON_2              ((uint32_t)0x00000040)     /*!< Bit 2 */
S
S#define LCD_FCR_DEAD               ((uint32_t)0x00000380)     /*!< DEAD[2:0] bits (DEAD Time) */
S#define LCD_FCR_DEAD_0             ((uint32_t)0x00000080)     /*!< Bit 0 */
S#define LCD_FCR_DEAD_1             ((uint32_t)0x00000100)     /*!< Bit 1 */
S#define LCD_FCR_DEAD_2             ((uint32_t)0x00000200)     /*!< Bit 2 */
S
S#define LCD_FCR_CC                 ((uint32_t)0x00001C00)     /*!< CC[2:0] bits (Contrast Control) */
S#define LCD_FCR_CC_0               ((uint32_t)0x00000400)     /*!< Bit 0 */
S#define LCD_FCR_CC_1               ((uint32_t)0x00000800)     /*!< Bit 1 */
S#define LCD_FCR_CC_2               ((uint32_t)0x00001000)     /*!< Bit 2 */
S
S#define LCD_FCR_BLINKF             ((uint32_t)0x0000E000)     /*!< BLINKF[2:0] bits (Blink Frequency) */
S#define LCD_FCR_BLINKF_0           ((uint32_t)0x00002000)     /*!< Bit 0 */
S#define LCD_FCR_BLINKF_1           ((uint32_t)0x00004000)     /*!< Bit 1 */
S#define LCD_FCR_BLINKF_2           ((uint32_t)0x00008000)     /*!< Bit 2 */
S
S#define LCD_FCR_BLINK              ((uint32_t)0x00030000)     /*!< BLINK[1:0] bits (Blink Enable) */
S#define LCD_FCR_BLINK_0            ((uint32_t)0x00010000)     /*!< Bit 0 */
S#define LCD_FCR_BLINK_1            ((uint32_t)0x00020000)     /*!< Bit 1 */
S
S#define LCD_FCR_DIV                ((uint32_t)0x003C0000)     /*!< DIV[3:0] bits (Divider) */
S#define LCD_FCR_PS                 ((uint32_t)0x03C00000)     /*!< PS[3:0] bits (Prescaler) */
S
S/*******************  Bit definition for LCD_SR register  *********************/
S#define LCD_SR_ENS                 ((uint32_t)0x00000001)     /*!< LCD Enabled Bit */
S#define LCD_SR_SOF                 ((uint32_t)0x00000002)     /*!< Start Of Frame Flag Bit */
S#define LCD_SR_UDR                 ((uint32_t)0x00000004)     /*!< Update Display Request Bit */
S#define LCD_SR_UDD                 ((uint32_t)0x00000008)     /*!< Update Display Done Flag Bit */
S#define LCD_SR_RDY                 ((uint32_t)0x00000010)     /*!< Ready Flag Bit */
S#define LCD_SR_FCRSR               ((uint32_t)0x00000020)     /*!< LCD FCR Register Synchronization Flag Bit */
S
S/*******************  Bit definition for LCD_CLR register  ********************/
S#define LCD_CLR_SOFC               ((uint32_t)0x00000002)     /*!< Start Of Frame Flag Clear Bit */
S#define LCD_CLR_UDDC               ((uint32_t)0x00000008)     /*!< Update Display Done Flag Clear Bit */
S
S/*******************  Bit definition for LCD_RAM register  ********************/
S#define LCD_RAM_SEGMENT_DATA       ((uint32_t)0xFFFFFFFF)     /*!< Segment Data Bits */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          Power Control (PWR)                               */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for PWR_CR register  ********************/
S#define  PWR_CR_LPSDSR                       ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep/low power run */
S#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
S#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
S#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
S#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
S
S#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
S#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
S#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
S#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
S
S/*!< PVD level configuration */
S#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
S#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
S#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
S#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
S#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
S#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
S#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
S#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
S
S#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
S#define  PWR_CR_ULP                          ((uint16_t)0x0200)     /*!< Ultra Low Power mode */
S#define  PWR_CR_FWU                          ((uint16_t)0x0400)     /*!< Fast wakeup */
S
S#define  PWR_CR_VOS                          ((uint16_t)0x1800)     /*!< VOS[1:0] bits (Voltage scaling range selection) */
S#define  PWR_CR_VOS_0                        ((uint16_t)0x0800)     /*!< Bit 0 */
S#define  PWR_CR_VOS_1                        ((uint16_t)0x1000)     /*!< Bit 1 */
S#define  PWR_CR_LPRUN                        ((uint16_t)0x4000)     /*!< Low power run mode */
S
S/*******************  Bit definition for PWR_CSR register  ********************/
S#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
S#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
S#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
S#define  PWR_CSR_VREFINTRDYF                 ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready flag */
S#define  PWR_CSR_VOSF                        ((uint16_t)0x0010)     /*!< Voltage Scaling select flag */
S#define  PWR_CSR_REGLPF                      ((uint16_t)0x0020)     /*!< Regulator LP flag */
S
S#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
S#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
S#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Reset and Clock Control (RCC)                         */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for RCC_CR register  ********************/
S#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
S#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
S
S#define  RCC_CR_MSION                        ((uint32_t)0x00000100)        /*!< Internal Multi Speed clock enable */
S#define  RCC_CR_MSIRDY                       ((uint32_t)0x00000200)        /*!< Internal Multi Speed clock ready flag */
S
S#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
S#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
S#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
S
S#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
S#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
S#define  RCC_CR_CSSON                        ((uint32_t)0x10000000)        /*!< Clock Security System enable */
S
S#define  RCC_CR_RTCPRE                       ((uint32_t)0x60000000)        /*!< RTC/LCD Prescaler */
S#define  RCC_CR_RTCPRE_0                     ((uint32_t)0x20000000)        /*!< Bit0 */
S#define  RCC_CR_RTCPRE_1                     ((uint32_t)0x40000000)        /*!< Bit1 */
S
S/********************  Bit definition for RCC_ICSCR register  *****************/
S#define  RCC_ICSCR_HSICAL                    ((uint32_t)0x000000FF)        /*!< Internal High Speed clock Calibration */
S#define  RCC_ICSCR_HSITRIM                   ((uint32_t)0x00001F00)        /*!< Internal High Speed clock trimming */
S
S#define  RCC_ICSCR_MSIRANGE                  ((uint32_t)0x0000E000)        /*!< Internal Multi Speed clock Range */
S#define  RCC_ICSCR_MSIRANGE_0                ((uint32_t)0x00000000)        /*!< Internal Multi Speed clock Range 65.536 KHz */
S#define  RCC_ICSCR_MSIRANGE_1                ((uint32_t)0x00002000)        /*!< Internal Multi Speed clock Range 131.072 KHz */
S#define  RCC_ICSCR_MSIRANGE_2                ((uint32_t)0x00004000)        /*!< Internal Multi Speed clock Range 262.144 KHz */
S#define  RCC_ICSCR_MSIRANGE_3                ((uint32_t)0x00006000)        /*!< Internal Multi Speed clock Range 524.288 KHz */
S#define  RCC_ICSCR_MSIRANGE_4                ((uint32_t)0x00008000)        /*!< Internal Multi Speed clock Range 1.048 MHz */
S#define  RCC_ICSCR_MSIRANGE_5                ((uint32_t)0x0000A000)        /*!< Internal Multi Speed clock Range 2.097 MHz */
S#define  RCC_ICSCR_MSIRANGE_6                ((uint32_t)0x0000C000)        /*!< Internal Multi Speed clock Range 4.194 MHz */
S#define  RCC_ICSCR_MSICAL                    ((uint32_t)0x00FF0000)        /*!< Internal Multi Speed clock Calibration */
S#define  RCC_ICSCR_MSITRIM                   ((uint32_t)0xFF000000)        /*!< Internal Multi Speed clock trimming */
S
S/********************  Bit definition for RCC_CFGR register  ******************/
S#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
S#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S/*!< SW configuration */
S#define  RCC_CFGR_SW_MSI                     ((uint32_t)0x00000000)        /*!< MSI selected as system clock */
S#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000001)        /*!< HSI selected as system clock */
S#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000002)        /*!< HSE selected as system clock */
S#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000003)        /*!< PLL selected as system clock */
S
S#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
S#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S/*!< SWS configuration */
S#define  RCC_CFGR_SWS_MSI                    ((uint32_t)0x00000000)        /*!< MSI oscillator used as system clock */
S#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000004)        /*!< HSI oscillator used as system clock */
S#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000008)        /*!< HSE oscillator used as system clock */
S#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x0000000C)        /*!< PLL used as system clock */
S
S#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
S#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S/*!< HPRE configuration */
S#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
S#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
S#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
S#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
S#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
S#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
S#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
S#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
S#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
S
S#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
S#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
S
S/*!< PPRE1 configuration */
S#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
S
S#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
S#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
S
S/*!< PPRE2 configuration */
S#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
S
S/*!< PLL entry clock source*/
S#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
S
S#define  RCC_CFGR_PLLSRC_HSI                 ((uint32_t)0x00000000)        /*!< HSI as PLL entry clock source */
S#define  RCC_CFGR_PLLSRC_HSE                 ((uint32_t)0x00010000)        /*!< HSE as PLL entry clock source */
S
S
S#define  RCC_CFGR_PLLMUL                     ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
S#define  RCC_CFGR_PLLMUL_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  RCC_CFGR_PLLMUL_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  RCC_CFGR_PLLMUL_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
S#define  RCC_CFGR_PLLMUL_3                   ((uint32_t)0x00200000)        /*!< Bit 3 */
S
S/*!< PLLMUL configuration */
S#define  RCC_CFGR_PLLMUL3                    ((uint32_t)0x00000000)        /*!< PLL input clock * 3 */
S#define  RCC_CFGR_PLLMUL4                    ((uint32_t)0x00040000)        /*!< PLL input clock * 4 */
S#define  RCC_CFGR_PLLMUL6                    ((uint32_t)0x00080000)        /*!< PLL input clock * 6 */
S#define  RCC_CFGR_PLLMUL8                    ((uint32_t)0x000C0000)        /*!< PLL input clock * 8 */
S#define  RCC_CFGR_PLLMUL12                   ((uint32_t)0x00100000)        /*!< PLL input clock * 12 */
S#define  RCC_CFGR_PLLMUL16                   ((uint32_t)0x00140000)        /*!< PLL input clock * 16 */
S#define  RCC_CFGR_PLLMUL24                   ((uint32_t)0x00180000)        /*!< PLL input clock * 24 */
S#define  RCC_CFGR_PLLMUL32                   ((uint32_t)0x001C0000)        /*!< PLL input clock * 32 */
S#define  RCC_CFGR_PLLMUL48                   ((uint32_t)0x00200000)        /*!< PLL input clock * 48 */
S
S/*!< PLLDIV configuration */
S#define  RCC_CFGR_PLLDIV                     ((uint32_t)0x00C00000)        /*!< PLLDIV[1:0] bits (PLL Output Division) */
S#define  RCC_CFGR_PLLDIV_0                   ((uint32_t)0x00400000)        /*!< Bit0 */
S#define  RCC_CFGR_PLLDIV_1                   ((uint32_t)0x00800000)        /*!< Bit1 */
S
S
S/*!< PLLDIV configuration */
S#define  RCC_CFGR_PLLDIV1                    ((uint32_t)0x00000000)        /*!< PLL clock output = CKVCO / 1 */
S#define  RCC_CFGR_PLLDIV2                    ((uint32_t)0x00400000)        /*!< PLL clock output = CKVCO / 2 */
S#define  RCC_CFGR_PLLDIV3                    ((uint32_t)0x00800000)        /*!< PLL clock output = CKVCO / 3 */
S#define  RCC_CFGR_PLLDIV4                    ((uint32_t)0x00C00000)        /*!< PLL clock output = CKVCO / 4 */
S
S
S#define  RCC_CFGR_MCOSEL                     ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
S#define  RCC_CFGR_MCOSEL_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  RCC_CFGR_MCOSEL_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  RCC_CFGR_MCOSEL_2                   ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S/*!< MCO configuration */
S#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
S#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x01000000)        /*!< System clock selected */
S#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x02000000)        /*!< Internal 16 MHz RC oscillator clock selected */
S#define  RCC_CFGR_MCO_MSI                    ((uint32_t)0x03000000)        /*!< Internal Medium Speed RC oscillator clock selected */
S#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x04000000)        /*!< External 1-25 MHz oscillator clock selected */
S#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x05000000)        /*!< PLL clock divided */
S#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x06000000)        /*!< LSI selected */
S#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x07000000)        /*!< LSE selected */
S
S#define  RCC_CFGR_MCOPRE                     ((uint32_t)0x70000000)        /*!< MCOPRE[2:0] bits (Microcontroller Clock Output Prescaler) */
S#define  RCC_CFGR_MCOPRE_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */
S#define  RCC_CFGR_MCOPRE_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */
S#define  RCC_CFGR_MCOPRE_2                   ((uint32_t)0x40000000)        /*!< Bit 2 */
S
S/*!< MCO Prescaler configuration */
S#define  RCC_CFGR_MCO_DIV1                   ((uint32_t)0x00000000)        /*!< MCO Clock divided by 1 */
S#define  RCC_CFGR_MCO_DIV2                   ((uint32_t)0x10000000)        /*!< MCO Clock divided by 2 */
S#define  RCC_CFGR_MCO_DIV4                   ((uint32_t)0x20000000)        /*!< MCO Clock divided by 4 */
S#define  RCC_CFGR_MCO_DIV8                   ((uint32_t)0x30000000)        /*!< MCO Clock divided by 8 */
S#define  RCC_CFGR_MCO_DIV16                  ((uint32_t)0x40000000)        /*!< MCO Clock divided by 16 */
S
S/*!<******************  Bit definition for RCC_CIR register  ********************/
S#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
S#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
S#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
S#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
S#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
S#define  RCC_CIR_MSIRDYF                     ((uint32_t)0x00000020)        /*!< MSI Ready Interrupt flag */
S#define  RCC_CIR_LSECSS                      ((uint32_t)0x00000040)        /*!< LSE CSS Interrupt flag */
S#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
S
S#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
S#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
S#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
S#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
S#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
S#define  RCC_CIR_MSIRDYIE                    ((uint32_t)0x00002000)        /*!< MSI Ready Interrupt Enable */
S#define  RCC_CIR_LSECSSIE                    ((uint32_t)0x00004000)        /*!< LSE CSS Interrupt Enable */
S
S#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
S#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
S#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
S#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
S#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
S#define  RCC_CIR_MSIRDYC                     ((uint32_t)0x00200000)        /*!< MSI Ready Interrupt Clear */
S#define  RCC_CIR_LSECSSC                     ((uint32_t)0x00400000)        /*!< LSE CSS Interrupt Clear */
S#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
S
S
S/*****************  Bit definition for RCC_AHBRSTR register  ******************/
S#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00000001)        /*!< GPIO port A reset */
S#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00000002)        /*!< GPIO port B reset */
S#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00000004)        /*!< GPIO port C reset */
S#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00000008)        /*!< GPIO port D reset */
S#define  RCC_AHBRSTR_GPIOERST                ((uint32_t)0x00000010)        /*!< GPIO port E reset */
S#define  RCC_AHBRSTR_GPIOHRST                ((uint32_t)0x00000020)        /*!< GPIO port H reset */
S#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00000040)        /*!< GPIO port F reset */
S#define  RCC_AHBRSTR_GPIOGRST                ((uint32_t)0x00000080)        /*!< GPIO port G reset */
S#define  RCC_AHBRSTR_CRCRST                  ((uint32_t)0x00001000)        /*!< CRC reset */
S#define  RCC_AHBRSTR_FLITFRST                ((uint32_t)0x00008000)        /*!< FLITF reset */
S#define  RCC_AHBRSTR_DMA1RST                 ((uint32_t)0x01000000)        /*!< DMA1 reset */
S#define  RCC_AHBRSTR_DMA2RST                 ((uint32_t)0x02000000)        /*!< DMA2 reset */
S#define  RCC_AHBRSTR_AESRST                  ((uint32_t)0x08000000)        /*!< AES reset */
S#define  RCC_AHBRSTR_FSMCRST                 ((uint32_t)0x40000000)        /*!< FSMC reset */
S 
S/*****************  Bit definition for RCC_APB2RSTR register  *****************/
S#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< System Configuration SYSCFG reset */
S#define  RCC_APB2RSTR_TIM9RST                ((uint32_t)0x00000004)        /*!< TIM9 reset */
S#define  RCC_APB2RSTR_TIM10RST               ((uint32_t)0x00000008)        /*!< TIM10 reset */
S#define  RCC_APB2RSTR_TIM11RST               ((uint32_t)0x00000010)        /*!< TIM11 reset */
S#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC1 reset */
S#define  RCC_APB2RSTR_SDIORST                ((uint32_t)0x00000800)        /*!< SDIO reset */
S#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 reset */
S#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
S
S/*****************  Bit definition for RCC_APB1RSTR register  *****************/
S#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
S#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
S#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)        /*!< Timer 4 reset */
S#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
S#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
S#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
S#define  RCC_APB1RSTR_LCDRST                 ((uint32_t)0x00000200)        /*!< LCD reset */
S#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
S#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI 2 reset */
S#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */
S#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
S#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 reset */
S#define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */
S#define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */
S#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
S#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 reset */
S#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB reset */
S#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */
S#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */
S#define  RCC_APB1RSTR_COMPRST                ((uint32_t)0x80000000)        /*!< Comparator interface reset */
S
S/******************  Bit definition for RCC_AHBENR register  ******************/
S#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00000001)        /*!< GPIO port A clock enable */
S#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00000002)        /*!< GPIO port B clock enable */
S#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00000004)        /*!< GPIO port C clock enable */
S#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00000008)        /*!< GPIO port D clock enable */
S#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00000010)        /*!< GPIO port E clock enable */
S#define  RCC_AHBENR_GPIOHEN                  ((uint32_t)0x00000020)        /*!< GPIO port H clock enable */
S#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00000040)        /*!< GPIO port F clock enable */
S#define  RCC_AHBENR_GPIOGEN                  ((uint32_t)0x00000080)        /*!< GPIO port G clock enable */
S#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00001000)        /*!< CRC clock enable */
S#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00008000)        /*!< FLITF clock enable (has effect only when
S                                                                                the Flash memory is in power down mode) */
S#define  RCC_AHBENR_DMA1EN                   ((uint32_t)0x01000000)        /*!< DMA1 clock enable */
S#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x02000000)        /*!< DMA2 clock enable */
S#define  RCC_AHBENR_AESEN                    ((uint32_t)0x08000000)        /*!< AES clock enable */
S#define  RCC_AHBENR_FSMCEN                   ((uint32_t)0x40000000)        /*!< FSMC clock enable */
S
S
S/******************  Bit definition for RCC_APB2ENR register  *****************/
S#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00000001)         /*!< System Configuration SYSCFG clock enable */
S#define  RCC_APB2ENR_TIM9EN                  ((uint32_t)0x00000004)         /*!< TIM9 interface clock enable */
S#define  RCC_APB2ENR_TIM10EN                 ((uint32_t)0x00000008)         /*!< TIM10 interface clock enable */
S#define  RCC_APB2ENR_TIM11EN                 ((uint32_t)0x00000010)         /*!< TIM11 Timer clock enable */
S#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC1 clock enable */
S#define  RCC_APB2ENR_SDIOEN                  ((uint32_t)0x00000800)         /*!< SDIO clock enable */
S#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI1 clock enable */
S#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */
S
S
S/*****************  Bit definition for RCC_APB1ENR register  ******************/
S#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/
S#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
S#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
S#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
S#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
S#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
S#define  RCC_APB1ENR_LCDEN                   ((uint32_t)0x00000200)        /*!< LCD clock enable */
S#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
S#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */
S#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */
S#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
S#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
S#define  RCC_APB1ENR_UART4EN                 ((uint32_t)0x00080000)        /*!< UART 4 clock enable */
S#define  RCC_APB1ENR_UART5EN                 ((uint32_t)0x00100000)        /*!< UART 5 clock enable */
S#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
S#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
S#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
S#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */
S#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)        /*!< DAC interface clock enable */
S#define  RCC_APB1ENR_COMPEN                  ((uint32_t)0x80000000)        /*!< Comparator interface clock enable */
S
S/******************  Bit definition for RCC_AHBLPENR register  ****************/
S#define  RCC_AHBLPENR_GPIOALPEN              ((uint32_t)0x00000001)        /*!< GPIO port A clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOBLPEN              ((uint32_t)0x00000002)        /*!< GPIO port B clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOCLPEN              ((uint32_t)0x00000004)        /*!< GPIO port C clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIODLPEN              ((uint32_t)0x00000008)        /*!< GPIO port D clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOELPEN              ((uint32_t)0x00000010)        /*!< GPIO port E clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOHLPEN              ((uint32_t)0x00000020)        /*!< GPIO port H clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOFLPEN              ((uint32_t)0x00000040)        /*!< GPIO port F clock enabled in sleep mode */
S#define  RCC_AHBLPENR_GPIOGLPEN              ((uint32_t)0x00000080)        /*!< GPIO port G clock enabled in sleep mode */
S#define  RCC_AHBLPENR_CRCLPEN                ((uint32_t)0x00001000)        /*!< CRC clock enabled in sleep mode */
S#define  RCC_AHBLPENR_FLITFLPEN              ((uint32_t)0x00008000)        /*!< Flash Interface clock enabled in sleep mode
S                                                                                (has effect only when the Flash memory is
S                                                                                 in power down mode) */
S#define  RCC_AHBLPENR_SRAMLPEN               ((uint32_t)0x00010000)        /*!< SRAM clock enabled in sleep mode */
S#define  RCC_AHBLPENR_DMA1LPEN               ((uint32_t)0x01000000)        /*!< DMA1 clock enabled in sleep mode */
S#define  RCC_AHBLPENR_DMA2LPEN               ((uint32_t)0x02000000)        /*!< DMA2 clock enabled in sleep mode */
S#define  RCC_AHBLPENR_AESLPEN                ((uint32_t)0x08000000)        /*!< AES clock enabled in sleep mode */
S#define  RCC_AHBLPENR_FSMCLPEN               ((uint32_t)0x40000000)        /*!< FSMC clock enabled in sleep mode */
S
S/******************  Bit definition for RCC_APB2LPENR register  ***************/
S#define  RCC_APB2LPENR_SYSCFGLPEN            ((uint32_t)0x00000001)         /*!< System Configuration SYSCFG clock enabled in sleep mode */
S#define  RCC_APB2LPENR_TIM9LPEN              ((uint32_t)0x00000004)         /*!< TIM9 interface clock enabled in sleep mode */
S#define  RCC_APB2LPENR_TIM10LPEN             ((uint32_t)0x00000008)         /*!< TIM10 interface clock enabled in sleep mode */
S#define  RCC_APB2LPENR_TIM11LPEN             ((uint32_t)0x00000010)         /*!< TIM11 Timer clock enabled in sleep mode */
S#define  RCC_APB2LPENR_ADC1LPEN              ((uint32_t)0x00000200)         /*!< ADC1 clock enabled in sleep mode */
S#define  RCC_APB2LPENR_SDIOLPEN              ((uint32_t)0x00000800)         /*!< SDIO clock enabled in sleep mode */
S#define  RCC_APB2LPENR_SPI1LPEN              ((uint32_t)0x00001000)         /*!< SPI1 clock enabled in sleep mode */
S#define  RCC_APB2LPENR_USART1LPEN            ((uint32_t)0x00004000)         /*!< USART1 clock enabled in sleep mode */
S
S/*****************  Bit definition for RCC_APB1LPENR register  ****************/
S#define  RCC_APB1LPENR_TIM2LPEN              ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_TIM3LPEN              ((uint32_t)0x00000002)        /*!< Timer 3 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_TIM4LPEN              ((uint32_t)0x00000004)        /*!< Timer 4 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_TIM5LPEN              ((uint32_t)0x00000008)        /*!< Timer 5 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_TIM6LPEN              ((uint32_t)0x00000010)        /*!< Timer 6 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_TIM7LPEN              ((uint32_t)0x00000020)        /*!< Timer 7 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_LCDLPEN               ((uint32_t)0x00000200)        /*!< LCD clock enabled in sleep mode */
S#define  RCC_APB1LPENR_WWDGLPEN              ((uint32_t)0x00000800)        /*!< Window Watchdog clock enabled in sleep mode */
S#define  RCC_APB1LPENR_SPI2LPEN              ((uint32_t)0x00004000)        /*!< SPI 2 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_SPI3LPEN              ((uint32_t)0x00008000)        /*!< SPI 3 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_USART2LPEN            ((uint32_t)0x00020000)        /*!< USART 2 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_USART3LPEN            ((uint32_t)0x00040000)        /*!< USART 3 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_UART4LPEN             ((uint32_t)0x00080000)        /*!< UART 4 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_UART5LPEN             ((uint32_t)0x00100000)        /*!< UART 5 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_I2C1LPEN              ((uint32_t)0x00200000)        /*!< I2C 1 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_I2C2LPEN              ((uint32_t)0x00400000)        /*!< I2C 2 clock enabled in sleep mode */
S#define  RCC_APB1LPENR_USBLPEN               ((uint32_t)0x00800000)        /*!< USB clock enabled in sleep mode */
S#define  RCC_APB1LPENR_PWRLPEN               ((uint32_t)0x10000000)        /*!< Power interface clock enabled in sleep mode */
S#define  RCC_APB1LPENR_DACLPEN               ((uint32_t)0x20000000)        /*!< DAC interface clock enabled in sleep mode */
S#define  RCC_APB1LPENR_COMPLPEN              ((uint32_t)0x80000000)        /*!< Comparator interface clock enabled in sleep mode*/
S
S/*******************  Bit definition for RCC_CSR register  ********************/
S#define  RCC_CSR_LSION                      ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
S#define  RCC_CSR_LSIRDY                     ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
S
S#define  RCC_CSR_LSEON                      ((uint32_t)0x00000100)        /*!< External Low Speed oscillator enable */
S#define  RCC_CSR_LSERDY                     ((uint32_t)0x00000200)        /*!< External Low Speed oscillator Ready */
S#define  RCC_CSR_LSEBYP                     ((uint32_t)0x00000400)        /*!< External Low Speed oscillator Bypass */
S#define  RCC_CSR_LSECSSON                   ((uint32_t)0x00000800)        /*!< External Low Speed oscillator CSS Enable */
S#define  RCC_CSR_LSECSSD                    ((uint32_t)0x00001000)        /*!< External Low Speed oscillator CSS Detected */
S
S#define  RCC_CSR_RTCSEL                     ((uint32_t)0x00030000)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
S#define  RCC_CSR_RTCSEL_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  RCC_CSR_RTCSEL_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */
S
S/*!< RTC congiguration */
S#define  RCC_CSR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
S#define  RCC_CSR_RTCSEL_LSE                 ((uint32_t)0x00010000)        /*!< LSE oscillator clock used as RTC clock */
S#define  RCC_CSR_RTCSEL_LSI                 ((uint32_t)0x00020000)        /*!< LSI oscillator clock used as RTC clock */
S#define  RCC_CSR_RTCSEL_HSE                 ((uint32_t)0x00030000)        /*!< HSE oscillator clock divided by 2, 4, 8 or 16 by RTCPRE used as RTC clock */
S
S#define  RCC_CSR_RTCEN                      ((uint32_t)0x00400000)        /*!< RTC clock enable */
S#define  RCC_CSR_RTCRST                     ((uint32_t)0x00800000)        /*!< RTC reset  */
S 
S#define  RCC_CSR_RMVF                       ((uint32_t)0x01000000)        /*!< Remove reset flag */
S#define  RCC_CSR_OBLRSTF                    ((uint32_t)0x02000000)        /*!< Option Bytes Loader reset flag */
S#define  RCC_CSR_PINRSTF                    ((uint32_t)0x04000000)        /*!< PIN reset flag */
S#define  RCC_CSR_PORRSTF                    ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
S#define  RCC_CSR_SFTRSTF                    ((uint32_t)0x10000000)        /*!< Software Reset flag */
S#define  RCC_CSR_IWDGRSTF                   ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
S#define  RCC_CSR_WWDGRSTF                   ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
S#define  RCC_CSR_LPWRRSTF                   ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
S
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Real-Time Clock (RTC)                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for RTC_TR register  *******************/
S#define RTC_TR_PM                            ((uint32_t)0x00400000)
S#define RTC_TR_HT                            ((uint32_t)0x00300000)
S#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
S#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
S#define RTC_TR_HU                            ((uint32_t)0x000F0000)
S#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
S#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
S#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
S#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
S#define RTC_TR_MNT                           ((uint32_t)0x00007000)
S#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
S#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
S#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
S#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
S#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
S#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
S#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
S#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
S#define RTC_TR_ST                            ((uint32_t)0x00000070)
S#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
S#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
S#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
S#define RTC_TR_SU                            ((uint32_t)0x0000000F)
S#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
S#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
S#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
S#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_DR register  *******************/
S#define RTC_DR_YT                            ((uint32_t)0x00F00000)
S#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
S#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
S#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
S#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
S#define RTC_DR_YU                            ((uint32_t)0x000F0000)
S#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
S#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
S#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
S#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
S#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
S#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
S#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
S#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
S#define RTC_DR_MT                            ((uint32_t)0x00001000)
S#define RTC_DR_MU                            ((uint32_t)0x00000F00)
S#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
S#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
S#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
S#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
S#define RTC_DR_DT                            ((uint32_t)0x00000030)
S#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
S#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
S#define RTC_DR_DU                            ((uint32_t)0x0000000F)
S#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
S#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
S#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
S#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_CR register  *******************/
S#define RTC_CR_COE                           ((uint32_t)0x00800000)
S#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
S#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
S#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
S#define RTC_CR_POL                           ((uint32_t)0x00100000)
S#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
S#define RTC_CR_BCK                           ((uint32_t)0x00040000)
S#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
S#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
S#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
S#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
S#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
S#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
S#define RTC_CR_TSE                           ((uint32_t)0x00000800)
S#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
S#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
S#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
S#define RTC_CR_DCE                           ((uint32_t)0x00000080)
S#define RTC_CR_FMT                           ((uint32_t)0x00000040)
S#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
S#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
S#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
S#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
S#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
S#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
S#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
S
S/********************  Bits definition for RTC_ISR register  ******************/
S#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
S#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)
S#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
S#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
S#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
S#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
S#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
S#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
S#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
S#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
S#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
S#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
S#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
S#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
S#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
S#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
S#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_PRER register  *****************/
S#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
S#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_WUTR register  *****************/
S#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_CALIBR register  ***************/
S#define RTC_CALIBR_DCS                       ((uint32_t)0x00000080)
S#define RTC_CALIBR_DC                        ((uint32_t)0x0000001F)
S
S/********************  Bits definition for RTC_ALRMAR register  ***************/
S#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_ALRMBR register  ***************/
S#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_WPR register  ******************/
S#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
S
S/********************  Bits definition for RTC_SSR register  ******************/
S#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_SHIFTR register  ***************/
S#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
S#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
S
S/********************  Bits definition for RTC_TSTR register  *****************/
S#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
S#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
S#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
S#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
S#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
S#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
S#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
S#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
S#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
S#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
S#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
S#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
S#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
S#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
S#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
S#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
S#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
S#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
S#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
S#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
S#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
S#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
S#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
S#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
S#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
S#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
S#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSDR register  *****************/
S#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
S#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
S#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
S#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
S#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
S#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
S#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
S#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
S#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
S#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
S#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
S#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
S#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
S#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
S#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
S#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
S#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
S#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSSSR register  ****************/
S#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_CAL register  *****************/
S#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
S#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
S#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
S#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
S#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
S#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
S#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
S#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
S#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
S#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
S#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
S#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
S#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
S
S/********************  Bits definition for RTC_TAFCR register  ****************/
S#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
S#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
S#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
S#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
S#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
S#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
S#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
S#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
S#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
S#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
S#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
S#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
S#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
S#define RTC_TAFCR_TAMP3TRG                   ((uint32_t)0x00000040)
S#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)
S#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
S#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)
S#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
S#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
S#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_ALRMASSR register  *************/
S#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_ALRMBSSR register  *************/
S#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_BKP0R register  ****************/
S#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP1R register  ****************/
S#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP2R register  ****************/
S#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP3R register  ****************/
S#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP4R register  ****************/
S#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP5R register  ****************/
S#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP6R register  ****************/
S#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP7R register  ****************/
S#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP8R register  ****************/
S#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP9R register  ****************/
S#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP10R register  ***************/
S#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP11R register  ***************/
S#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP12R register  ***************/
S#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP13R register  ***************/
S#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP14R register  ***************/
S#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP15R register  ***************/
S#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP16R register  ***************/
S#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP17R register  ***************/
S#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP18R register  ***************/
S#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP19R register  ***************/
S#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP20R register  ***************/
S#define RTC_BKP20R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP21R register  ***************/
S#define RTC_BKP21R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP22R register  ***************/
S#define RTC_BKP22R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP23R register  ***************/
S#define RTC_BKP23R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP24R register  ***************/
S#define RTC_BKP24R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP25R register  ***************/
S#define RTC_BKP25R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP26R register  ***************/
S#define RTC_BKP26R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP27R register  ***************/
S#define RTC_BKP27R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP28R register  ***************/
S#define RTC_BKP28R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP29R register  ***************/
S#define RTC_BKP29R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP30R register  ***************/
S#define RTC_BKP30R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP31R register  ***************/
S#define RTC_BKP31R                           ((uint32_t)0xFFFFFFFF)
S
S/******************************************************************************/
S/*                                                                            */
S/*                          SD host Interface                                 */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for SDIO_POWER register  ******************/
S#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */
S#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */
S#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */
S
S/******************  Bit definition for SDIO_CLKCR register  ******************/
S#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */
S#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */
S#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */
S#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */
S
S#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
S#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */
S#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */
S
S#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */
S#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */
S
S/*******************  Bit definition for SDIO_ARG register  *******************/
S#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */
S
S/*******************  Bit definition for SDIO_CMD register  *******************/
S#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */
S
S#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */
S#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */
S#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */
S
S#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */
S#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
S#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */
S#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */
S#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */
S#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */
S#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */
S
S/*****************  Bit definition for SDIO_RESPCMD register  *****************/
S#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */
S
S/******************  Bit definition for SDIO_RESP0 register  ******************/
S#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP1 register  ******************/
S#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP2 register  ******************/
S#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP3 register  ******************/
S#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_RESP4 register  ******************/
S#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */
S
S/******************  Bit definition for SDIO_DTIMER register  *****************/
S#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */
S
S/******************  Bit definition for SDIO_DLEN register  *******************/
S#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */
S
S/******************  Bit definition for SDIO_DCTRL register  ******************/
S#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */
S#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */
S#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */
S#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */
S
S#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */
S#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */
S#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */
S#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */
S#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */
S
S#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */
S#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */
S#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */
S#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */
S
S/******************  Bit definition for SDIO_DCOUNT register  *****************/
S#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */
S
S/******************  Bit definition for SDIO_STA register  ********************/
S#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */
S#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */
S#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */
S#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */
S#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */
S#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */
S#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */
S#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */
S#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */
S#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */
S#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */
S#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */
S#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */
S#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */
S#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
S#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
S#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */
S#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */
S#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */
S#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */
S#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */
S#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */
S#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */
S#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */
S
S/*******************  Bit definition for SDIO_ICR register  *******************/
S#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */
S#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */
S#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */
S#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */
S#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */
S#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */
S#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */
S#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */
S#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */
S#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */
S#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */
S#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */
S#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */
S
S/******************  Bit definition for SDIO_MASK register  *******************/
S#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */
S#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */
S#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */
S#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */
S#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */
S#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */
S#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */
S#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */
S#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */
S#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */
S#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */
S#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */
S#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */
S#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */
S#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */
S#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */
S#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */
S#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */
S#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */
S#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */
S#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */
S#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */
S#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */
S#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */
S
S/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
S#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */
S
S/******************  Bit definition for SDIO_FIFO register  *******************/
S#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */
S
S/******************************************************************************/
S/*                                                                            */
S/*                     Serial Peripheral Interface (SPI)                      */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for SPI_CR1 register  ********************/
S#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
S#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
S#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
S
S#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
S#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
S#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
S#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
S
S#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
S#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
S#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
S#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
S#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
S#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */
S#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
S#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
S#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
S#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
S
S/*******************  Bit definition for SPI_CR2 register  ********************/
S#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */
S#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */
S#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */
S#define  SPI_CR2_FRF                         ((uint8_t)0x08)               /*!< Frame format */
S#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */
S#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */
S#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */
S
S/********************  Bit definition for SPI_SR register  ********************/
S#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */
S#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */
S#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */
S#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */
S#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */
S#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */
S#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */
S#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */
S
S/********************  Bit definition for SPI_DR register  ********************/
S#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
S
S/*******************  Bit definition for SPI_CRCPR register  ******************/
S#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
S
S/******************  Bit definition for SPI_RXCRCR register  ******************/
S#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
S
S/******************  Bit definition for SPI_TXCRCR register  ******************/
S#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
S
S/******************  Bit definition for SPI_I2SCFGR register  *****************/
S#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
S
S#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
S#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
S
S#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
S#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
S
S#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
S#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
S#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
S
S/******************  Bit definition for SPI_I2SPR register  *******************/
S#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
S#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
S#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
S
S/******************************************************************************/
S/*                                                                            */
S/*                       System Configuration (SYSCFG)                        */
S/*                                                                            */
S/******************************************************************************/
S/*****************  Bit definition for SYSCFG_MEMRMP register  ****************/
S#define SYSCFG_MEMRMP_MEM_MODE          ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
S#define SYSCFG_MEMRMP_MEM_MODE_0        ((uint32_t)0x00000001) /*!< Bit 0 */
S#define SYSCFG_MEMRMP_MEM_MODE_1        ((uint32_t)0x00000002) /*!< Bit 1 */
S#define SYSCFG_MEMRMP_BOOT_MODE         ((uint32_t)0x00000300) /*!< Boot mode Config */
S#define SYSCFG_MEMRMP_BOOT_MODE_0       ((uint32_t)0x00000100) /*!< Bit 0 */
S#define SYSCFG_MEMRMP_BOOT_MODE_1       ((uint32_t)0x00000200) /*!< Bit 1 */
S
S/*****************  Bit definition for SYSCFG_PMC register  *******************/
S#define SYSCFG_PMC_USB_PU               ((uint32_t)0x00000001) /*!< SYSCFG PMC */
S
S/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
S#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
S#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
S#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
S#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
S
S/** 
S  * @brief  EXTI0 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PH         ((uint16_t)0x0005) /*!< PH[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0006) /*!< PF[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PG         ((uint16_t)0x0007) /*!< PG[0] pin */
S
S/** 
S  * @brief  EXTI1 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PH         ((uint16_t)0x0050) /*!< PH[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0060) /*!< PF[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PG         ((uint16_t)0x0070) /*!< PG[1] pin */
S
S/** 
S  * @brief  EXTI2 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PH         ((uint16_t)0x0500) /*!< PH[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0600) /*!< PF[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PG         ((uint16_t)0x0700) /*!< PG[2] pin */
S
S/** 
S  * @brief  EXTI3 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x3000) /*!< PF[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PG         ((uint16_t)0x4000) /*!< PG[3] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
S#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
S#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
S#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
S#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
S
S/** 
S  * @brief  EXTI4 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0006) /*!< PF[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PG         ((uint16_t)0x0007) /*!< PG[4] pin */
S
S/** 
S  * @brief  EXTI5 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0060) /*!< PF[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PG         ((uint16_t)0x0070) /*!< PG[5] pin */
S
S/** 
S  * @brief  EXTI6 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0600) /*!< PF[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PG         ((uint16_t)0x0700) /*!< PG[6] pin */
S
S/** 
S  * @brief  EXTI7 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x6000) /*!< PF[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PG         ((uint16_t)0x7000) /*!< PG[7] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
S#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
S#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
S#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
S#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
S
S/** 
S  * @brief  EXTI8 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PF         ((uint16_t)0x0006) /*!< PF[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PG         ((uint16_t)0x0007) /*!< PG[8] pin */
S
S/** 
S  * @brief  EXTI9 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0060) /*!< PF[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PG         ((uint16_t)0x0070) /*!< PG[9] pin */
S
S/** 
S  * @brief  EXTI10 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PD[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PE[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0600) /*!< PF[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PG        ((uint16_t)0x0700) /*!< PG[10] pin */
S
S/** 
S  * @brief  EXTI11 configuration  
S  */ 
S#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!< PB[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PF        ((uint16_t)0x6000) /*!< PF[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PG        ((uint16_t)0x7000) /*!< PG[11] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
S#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
S#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
S#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
S#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
S
S/** 
S  * @brief  EXTI12 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!< PB[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PF        ((uint16_t)0x0006) /*!< PF[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PG        ((uint16_t)0x0007) /*!< PG[12] pin */
S
S/** 
S  * @brief  EXTI13 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!< PB[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PF        ((uint16_t)0x0060) /*!< PF[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PG        ((uint16_t)0x0070) /*!< PG[13] pin */
S
S/** 
S  * @brief  EXTI14 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PF        ((uint16_t)0x0600) /*!< PF[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PG        ((uint16_t)0x0700) /*!< PG[14] pin */
S
S/** 
S  * @brief  EXTI15 configuration  
S  */ 
S#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PF        ((uint16_t)0x6000) /*!< PF[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PG        ((uint16_t)0x7000) /*!< PG[15] pin */
S 
S/******************************************************************************/
S/*                                                                            */
S/*                       Routing Interface (RI)                               */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for RI_ICR register  ********************/
S#define  RI_ICR_IC1Z                    ((uint32_t)0x0000000F) /*!< IC1Z[3:0] bits (Input Capture 1 select bits) */
S#define  RI_ICR_IC1Z_0                  ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_ICR_IC1Z_1                  ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_ICR_IC1Z_2                  ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_ICR_IC1Z_3                  ((uint32_t)0x00000008) /*!< Bit 3 */
S
S#define  RI_ICR_IC2Z                    ((uint32_t)0x000000F0) /*!< IC2Z[3:0] bits (Input Capture 2 select bits) */
S#define  RI_ICR_IC2Z_0                  ((uint32_t)0x00000010) /*!< Bit 0 */
S#define  RI_ICR_IC2Z_1                  ((uint32_t)0x00000020) /*!< Bit 1 */
S#define  RI_ICR_IC2Z_2                  ((uint32_t)0x00000040) /*!< Bit 2 */
S#define  RI_ICR_IC2Z_3                  ((uint32_t)0x00000080) /*!< Bit 3 */
S
S#define  RI_ICR_IC3Z                    ((uint32_t)0x00000F00) /*!< IC3Z[3:0] bits (Input Capture 3 select bits) */
S#define  RI_ICR_IC3Z_0                  ((uint32_t)0x00000100) /*!< Bit 0 */
S#define  RI_ICR_IC3Z_1                  ((uint32_t)0x00000200) /*!< Bit 1 */
S#define  RI_ICR_IC3Z_2                  ((uint32_t)0x00000400) /*!< Bit 2 */
S#define  RI_ICR_IC3Z_3                  ((uint32_t)0x00000800) /*!< Bit 3 */
S
S#define  RI_ICR_IC4Z                    ((uint32_t)0x0000F000) /*!< IC4Z[3:0] bits (Input Capture 4 select bits) */
S#define  RI_ICR_IC4Z_0                  ((uint32_t)0x00001000) /*!< Bit 0 */
S#define  RI_ICR_IC4Z_1                  ((uint32_t)0x00002000) /*!< Bit 1 */
S#define  RI_ICR_IC4Z_2                  ((uint32_t)0x00004000) /*!< Bit 2 */
S#define  RI_ICR_IC4Z_3                  ((uint32_t)0x00008000) /*!< Bit 3 */
S
S#define  RI_ICR_TIM                     ((uint32_t)0x00030000) /*!< TIM[3:0] bits (Timers select bits) */
S#define  RI_ICR_TIM_0                   ((uint32_t)0x00010000) /*!< Bit 0 */
S#define  RI_ICR_TIM_1                   ((uint32_t)0x00020000) /*!< Bit 1 */
S
S#define  RI_ICR_IC1                     ((uint32_t)0x00040000) /*!< Input capture 1 */
S#define  RI_ICR_IC2                     ((uint32_t)0x00080000) /*!< Input capture 2 */
S#define  RI_ICR_IC3                     ((uint32_t)0x00100000) /*!< Input capture 3 */
S#define  RI_ICR_IC4                     ((uint32_t)0x00200000) /*!< Input capture 4 */
S
S/********************  Bit definition for RI_ASCR1 register  ********************/
S#define  RI_ASCR1_CH                    ((uint32_t)0x03FCFFFF) /*!< AS_CH[25:18] & AS_CH[15:0] bits ( Analog switches selection bits) */
S#define  RI_ASCR1_CH_0                  ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_ASCR1_CH_1                  ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_ASCR1_CH_2                  ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_ASCR1_CH_3                  ((uint32_t)0x00000008) /*!< Bit 3 */
S#define  RI_ASCR1_CH_4                  ((uint32_t)0x00000010) /*!< Bit 4 */
S#define  RI_ASCR1_CH_5                  ((uint32_t)0x00000020) /*!< Bit 5 */
S#define  RI_ASCR1_CH_6                  ((uint32_t)0x00000040) /*!< Bit 6 */
S#define  RI_ASCR1_CH_7                  ((uint32_t)0x00000080) /*!< Bit 7 */
S#define  RI_ASCR1_CH_8                  ((uint32_t)0x00000100) /*!< Bit 8 */
S#define  RI_ASCR1_CH_9                  ((uint32_t)0x00000200) /*!< Bit 9 */
S#define  RI_ASCR1_CH_10                 ((uint32_t)0x00000400) /*!< Bit 10 */
S#define  RI_ASCR1_CH_11                 ((uint32_t)0x00000800) /*!< Bit 11 */
S#define  RI_ASCR1_CH_12                 ((uint32_t)0x00001000) /*!< Bit 12 */
S#define  RI_ASCR1_CH_13                 ((uint32_t)0x00002000) /*!< Bit 13 */
S#define  RI_ASCR1_CH_14                 ((uint32_t)0x00004000) /*!< Bit 14 */
S#define  RI_ASCR1_CH_15                 ((uint32_t)0x00008000) /*!< Bit 15 */
S#define  RI_ASCR1_CH_31                 ((uint32_t)0x00010000) /*!< Bit 16 */
S#define  RI_ASCR1_CH_18                 ((uint32_t)0x00040000) /*!< Bit 18 */
S#define  RI_ASCR1_CH_19                 ((uint32_t)0x00080000) /*!< Bit 19 */
S#define  RI_ASCR1_CH_20                 ((uint32_t)0x00100000) /*!< Bit 20 */
S#define  RI_ASCR1_CH_21                 ((uint32_t)0x00200000) /*!< Bit 21 */
S#define  RI_ASCR1_CH_22                 ((uint32_t)0x00400000) /*!< Bit 22 */
S#define  RI_ASCR1_CH_23                 ((uint32_t)0x00800000) /*!< Bit 23 */
S#define  RI_ASCR1_CH_24                 ((uint32_t)0x01000000) /*!< Bit 24 */
S#define  RI_ASCR1_CH_25                 ((uint32_t)0x02000000) /*!< Bit 25 */
S#define  RI_ASCR1_VCOMP                 ((uint32_t)0x04000000) /*!< ADC analog switch selection for internal node to COMP1 */
S#define  RI_ASCR1_CH_27                 ((uint32_t)0x00400000) /*!< Bit 27 */
S#define  RI_ASCR1_CH_28                 ((uint32_t)0x00800000) /*!< Bit 28 */
S#define  RI_ASCR1_CH_29                 ((uint32_t)0x01000000) /*!< Bit 29 */
S#define  RI_ASCR1_CH_30                 ((uint32_t)0x02000000) /*!< Bit 30 */
S#define  RI_ASCR1_SCM                   ((uint32_t)0x80000000) /*!< I/O Switch control mode */
S
S/********************  Bit definition for RI_ASCR2 register  ********************/
S#define  RI_ASCR2_GR10_1                ((uint32_t)0x00000001) /*!< GR10-1 selection bit */
S#define  RI_ASCR2_GR10_2                ((uint32_t)0x00000002) /*!< GR10-2 selection bit */
S#define  RI_ASCR2_GR10_3                ((uint32_t)0x00000004) /*!< GR10-3 selection bit */
S#define  RI_ASCR2_GR10_4                ((uint32_t)0x00000008) /*!< GR10-4 selection bit */
S#define  RI_ASCR2_GR6_1                 ((uint32_t)0x00000010) /*!< GR6-1 selection bit */
S#define  RI_ASCR2_GR6_2                 ((uint32_t)0x00000020) /*!< GR6-2 selection bit */
S#define  RI_ASCR2_GR5_1                 ((uint32_t)0x00000040) /*!< GR5-1 selection bit */
S#define  RI_ASCR2_GR5_2                 ((uint32_t)0x00000080) /*!< GR5-2 selection bit */
S#define  RI_ASCR2_GR5_3                 ((uint32_t)0x00000100) /*!< GR5-3 selection bit */
S#define  RI_ASCR2_GR4_1                 ((uint32_t)0x00000200) /*!< GR4-1 selection bit */
S#define  RI_ASCR2_GR4_2                 ((uint32_t)0x00000400) /*!< GR4-2 selection bit */
S#define  RI_ASCR2_GR4_3                 ((uint32_t)0x00000800) /*!< GR4-3 selection bit */
S#define  RI_ASCR2_GR4_4                 ((uint32_t)0x00008000) /*!< GR4-4 selection bit */
S#define  RI_ASCR2_CH0b                  ((uint32_t)0x00010000) /*!< CH0b selection bit */
S#define  RI_ASCR2_CH1b                  ((uint32_t)0x00020000) /*!< CH1b selection bit */
S#define  RI_ASCR2_CH2b                  ((uint32_t)0x00040000) /*!< CH2b selection bit */
S#define  RI_ASCR2_CH3b                  ((uint32_t)0x00080000) /*!< CH3b selection bit */
S#define  RI_ASCR2_CH6b                  ((uint32_t)0x00100000) /*!< CH6b selection bit */
S#define  RI_ASCR2_CH7b                  ((uint32_t)0x00200000) /*!< CH7b selection bit */
S#define  RI_ASCR2_CH8b                  ((uint32_t)0x00400000) /*!< CH8b selection bit */
S#define  RI_ASCR2_CH9b                  ((uint32_t)0x00800000) /*!< CH9b selection bit */
S#define  RI_ASCR2_CH10b                 ((uint32_t)0x01000000) /*!< CH10b selection bit */
S#define  RI_ASCR2_CH11b                 ((uint32_t)0x02000000) /*!< CH11b selection bit */
S#define  RI_ASCR2_CH12b                 ((uint32_t)0x04000000) /*!< CH12b selection bit */
S#define  RI_ASCR2_GR6_3                 ((uint32_t)0x08000000) /*!< GR6-3 selection bit */
S#define  RI_ASCR2_GR6_4                 ((uint32_t)0x10000000) /*!< GR6-4 selection bit */
S#define  RI_ASCR2_GR5_4                 ((uint32_t)0x20000000) /*!< GR5-4 selection bit */
S
S/********************  Bit definition for RI_HYSCR1 register  ********************/
S#define  RI_HYSCR1_PA                   ((uint32_t)0x0000FFFF) /*!< PA[15:0] Port A Hysteresis selection */
S#define  RI_HYSCR1_PA_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_HYSCR1_PA_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_HYSCR1_PA_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_HYSCR1_PA_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
S#define  RI_HYSCR1_PA_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
S#define  RI_HYSCR1_PA_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
S#define  RI_HYSCR1_PA_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
S#define  RI_HYSCR1_PA_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
S#define  RI_HYSCR1_PA_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
S#define  RI_HYSCR1_PA_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
S#define  RI_HYSCR1_PA_10                ((uint32_t)0x00000400) /*!< Bit 10 */
S#define  RI_HYSCR1_PA_11                ((uint32_t)0x00000800) /*!< Bit 11 */
S#define  RI_HYSCR1_PA_12                ((uint32_t)0x00001000) /*!< Bit 12 */
S#define  RI_HYSCR1_PA_13                ((uint32_t)0x00002000) /*!< Bit 13 */
S#define  RI_HYSCR1_PA_14                ((uint32_t)0x00004000) /*!< Bit 14 */
S#define  RI_HYSCR1_PA_15                ((uint32_t)0x00008000) /*!< Bit 15 */
S
S#define  RI_HYSCR1_PB                   ((uint32_t)0xFFFF0000) /*!< PB[15:0] Port B Hysteresis selection */
S#define  RI_HYSCR1_PB_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
S#define  RI_HYSCR1_PB_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
S#define  RI_HYSCR1_PB_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
S#define  RI_HYSCR1_PB_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
S#define  RI_HYSCR1_PB_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
S#define  RI_HYSCR1_PB_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
S#define  RI_HYSCR1_PB_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
S#define  RI_HYSCR1_PB_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
S#define  RI_HYSCR1_PB_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
S#define  RI_HYSCR1_PB_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
S#define  RI_HYSCR1_PB_10                ((uint32_t)0x04000000) /*!< Bit 10 */
S#define  RI_HYSCR1_PB_11                ((uint32_t)0x08000000) /*!< Bit 11 */
S#define  RI_HYSCR1_PB_12                ((uint32_t)0x10000000) /*!< Bit 12 */
S#define  RI_HYSCR1_PB_13                ((uint32_t)0x20000000) /*!< Bit 13 */
S#define  RI_HYSCR1_PB_14                ((uint32_t)0x40000000) /*!< Bit 14 */
S#define  RI_HYSCR1_PB_15                ((uint32_t)0x80000000) /*!< Bit 15 */
S
S/********************  Bit definition for RI_HYSCR2 register  ********************/
S#define  RI_HYSCR2_PC                   ((uint32_t)0x0000FFFF) /*!< PC[15:0] Port C Hysteresis selection */
S#define  RI_HYSCR2_PC_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_HYSCR2_PC_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_HYSCR2_PC_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_HYSCR2_PC_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
S#define  RI_HYSCR2_PC_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
S#define  RI_HYSCR2_PC_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
S#define  RI_HYSCR2_PC_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
S#define  RI_HYSCR2_PC_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
S#define  RI_HYSCR2_PC_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
S#define  RI_HYSCR2_PC_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
S#define  RI_HYSCR2_PC_10                ((uint32_t)0x00000400) /*!< Bit 10 */
S#define  RI_HYSCR2_PC_11                ((uint32_t)0x00000800) /*!< Bit 11 */
S#define  RI_HYSCR2_PC_12                ((uint32_t)0x00001000) /*!< Bit 12 */
S#define  RI_HYSCR2_PC_13                ((uint32_t)0x00002000) /*!< Bit 13 */
S#define  RI_HYSCR2_PC_14                ((uint32_t)0x00004000) /*!< Bit 14 */
S#define  RI_HYSCR2_PC_15                ((uint32_t)0x00008000) /*!< Bit 15 */
S
S#define  RI_HYSCR2_PD                   ((uint32_t)0xFFFF0000) /*!< PD[15:0] Port D Hysteresis selection */
S#define  RI_HYSCR2_PD_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
S#define  RI_HYSCR2_PD_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
S#define  RI_HYSCR2_PD_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
S#define  RI_HYSCR2_PD_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
S#define  RI_HYSCR2_PD_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
S#define  RI_HYSCR2_PD_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
S#define  RI_HYSCR2_PD_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
S#define  RI_HYSCR2_PD_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
S#define  RI_HYSCR2_PD_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
S#define  RI_HYSCR2_PD_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
S#define  RI_HYSCR2_PD_10                ((uint32_t)0x04000000) /*!< Bit 10 */
S#define  RI_HYSCR2_PD_11                ((uint32_t)0x08000000) /*!< Bit 11 */
S#define  RI_HYSCR2_PD_12                ((uint32_t)0x10000000) /*!< Bit 12 */
S#define  RI_HYSCR2_PD_13                ((uint32_t)0x20000000) /*!< Bit 13 */
S#define  RI_HYSCR2_PD_14                ((uint32_t)0x40000000) /*!< Bit 14 */
S#define  RI_HYSCR2_PD_15                ((uint32_t)0x80000000) /*!< Bit 15 */
S
S/********************  Bit definition for RI_HYSCR3 register  ********************/
S#define  RI_HYSCR2_PE                   ((uint32_t)0x0000FFFF) /*!< PE[15:0] Port E Hysteresis selection */
S#define  RI_HYSCR2_PE_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_HYSCR2_PE_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_HYSCR2_PE_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_HYSCR2_PE_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
S#define  RI_HYSCR2_PE_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
S#define  RI_HYSCR2_PE_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
S#define  RI_HYSCR2_PE_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
S#define  RI_HYSCR2_PE_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
S#define  RI_HYSCR2_PE_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
S#define  RI_HYSCR2_PE_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
S#define  RI_HYSCR2_PE_10                ((uint32_t)0x00000400) /*!< Bit 10 */
S#define  RI_HYSCR2_PE_11                ((uint32_t)0x00000800) /*!< Bit 11 */
S#define  RI_HYSCR2_PE_12                ((uint32_t)0x00001000) /*!< Bit 12 */
S#define  RI_HYSCR2_PE_13                ((uint32_t)0x00002000) /*!< Bit 13 */
S#define  RI_HYSCR2_PE_14                ((uint32_t)0x00004000) /*!< Bit 14 */
S#define  RI_HYSCR2_PE_15                ((uint32_t)0x00008000) /*!< Bit 15 */
S
S#define  RI_HYSCR3_PF                   ((uint32_t)0xFFFF0000) /*!< PF[15:0] Port F Hysteresis selection */
S#define  RI_HYSCR3_PF_0                 ((uint32_t)0x00010000) /*!< Bit 0 */
S#define  RI_HYSCR3_PF_1                 ((uint32_t)0x00020000) /*!< Bit 1 */
S#define  RI_HYSCR3_PF_2                 ((uint32_t)0x00040000) /*!< Bit 2 */
S#define  RI_HYSCR3_PF_3                 ((uint32_t)0x00080000) /*!< Bit 3 */
S#define  RI_HYSCR3_PF_4                 ((uint32_t)0x00100000) /*!< Bit 4 */
S#define  RI_HYSCR3_PF_5                 ((uint32_t)0x00200000) /*!< Bit 5 */
S#define  RI_HYSCR3_PF_6                 ((uint32_t)0x00400000) /*!< Bit 6 */
S#define  RI_HYSCR3_PF_7                 ((uint32_t)0x00800000) /*!< Bit 7 */
S#define  RI_HYSCR3_PF_8                 ((uint32_t)0x01000000) /*!< Bit 8 */
S#define  RI_HYSCR3_PF_9                 ((uint32_t)0x02000000) /*!< Bit 9 */
S#define  RI_HYSCR3_PF_10                ((uint32_t)0x04000000) /*!< Bit 10 */
S#define  RI_HYSCR3_PF_11                ((uint32_t)0x08000000) /*!< Bit 11 */
S#define  RI_HYSCR3_PF_12                ((uint32_t)0x10000000) /*!< Bit 12 */
S#define  RI_HYSCR3_PF_13                ((uint32_t)0x20000000) /*!< Bit 13 */
S#define  RI_HYSCR3_PF_14                ((uint32_t)0x40000000) /*!< Bit 14 */
S#define  RI_HYSCR3_PF_15                ((uint32_t)0x80000000) /*!< Bit 15 */
S
S/********************  Bit definition for RI_HYSCR4 register  ********************/
S#define  RI_HYSCR4_PG                   ((uint32_t)0x0000FFFF) /*!< PG[15:0] Port G Hysteresis selection */
S#define  RI_HYSCR4_PG_0                 ((uint32_t)0x00000001) /*!< Bit 0 */
S#define  RI_HYSCR4_PG_1                 ((uint32_t)0x00000002) /*!< Bit 1 */
S#define  RI_HYSCR4_PG_2                 ((uint32_t)0x00000004) /*!< Bit 2 */
S#define  RI_HYSCR4_PG_3                 ((uint32_t)0x00000008) /*!< Bit 3 */
S#define  RI_HYSCR4_PG_4                 ((uint32_t)0x00000010) /*!< Bit 4 */
S#define  RI_HYSCR4_PG_5                 ((uint32_t)0x00000020) /*!< Bit 5 */
S#define  RI_HYSCR4_PG_6                 ((uint32_t)0x00000040) /*!< Bit 6 */
S#define  RI_HYSCR4_PG_7                 ((uint32_t)0x00000080) /*!< Bit 7 */
S#define  RI_HYSCR4_PG_8                 ((uint32_t)0x00000100) /*!< Bit 8 */
S#define  RI_HYSCR4_PG_9                 ((uint32_t)0x00000200) /*!< Bit 9 */
S#define  RI_HYSCR4_PG_10                ((uint32_t)0x00000400) /*!< Bit 10 */
S#define  RI_HYSCR4_PG_11                ((uint32_t)0x00000800) /*!< Bit 11 */
S#define  RI_HYSCR4_PG_12                ((uint32_t)0x00001000) /*!< Bit 12 */
S#define  RI_HYSCR4_PG_13                ((uint32_t)0x00002000) /*!< Bit 13 */
S#define  RI_HYSCR4_PG_14                ((uint32_t)0x00004000) /*!< Bit 14 */
S#define  RI_HYSCR4_PG_15                ((uint32_t)0x00008000) /*!< Bit 15 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                               Timers (TIM)                                 */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for TIM_CR1 register  ********************/
S#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
S#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
S#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
S#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
S#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
S
S#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
S#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
S#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
S
S#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
S
S#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
S#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S
S/*******************  Bit definition for TIM_CR2 register  ********************/
S#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
S
S#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
S#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
S
S/*******************  Bit definition for TIM_SMCR register  *******************/
S#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
S#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S
S#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!<OCCS bits (OCref Clear Selection) */
S
S#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
S#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
S
S#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
S#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
S
S#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
S#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
S#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
S
S/*******************  Bit definition for TIM_DIER register  *******************/
S#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
S#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
S#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
S#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
S#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
S#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
S#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
S#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
S#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
S#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
S#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
S#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
S
S/********************  Bit definition for TIM_SR register  ********************/
S#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
S#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
S#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
S#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
S#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
S#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
S#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
S#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
S#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
S#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
S
S/*******************  Bit definition for TIM_EGR register  ********************/
S#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
S#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
S#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
S#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
S#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
S#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
S                   
S/******************  Bit definition for TIM_CCMR1 register  *******************/
S#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
S#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
S#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
S
S#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
S#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
S
S#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
S#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
S#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
S
S#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
S#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
S#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
S#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
S#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
S#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/******************  Bit definition for TIM_CCMR2 register  *******************/
S#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
S#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
S#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
S
S#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
S#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
S
S#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
S#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
S#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
S
S#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
S#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
S#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
S#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
S#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
S#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/*******************  Bit definition for TIM_CCER register  *******************/
S#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
S#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
S#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
S#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
S#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
S#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
S#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
S#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
S#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
S#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
S#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
S#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
S
S/*******************  Bit definition for TIM_CNT register  ********************/
S#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
S
S/*******************  Bit definition for TIM_PSC register  ********************/
S#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
S
S/*******************  Bit definition for TIM_ARR register  ********************/
S#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
S           
S/*******************  Bit definition for TIM_CCR1 register  *******************/
S#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
S
S/*******************  Bit definition for TIM_CCR2 register  *******************/
S#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
S
S/*******************  Bit definition for TIM_CCR3 register  *******************/
S#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
S
S/*******************  Bit definition for TIM_CCR4 register  *******************/
S#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
S
S/*******************  Bit definition for TIM_DCR register  ********************/
S#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
S#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
S
S#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
S#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
S#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
S
S/*******************  Bit definition for TIM_DMAR register  *******************/
S#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
S
S/*******************  Bit definition for TIM_OR register  *********************/
S#define  TIM_OR_TI1RMP                       ((uint16_t)0x0003)            /*!<Option register for TI1 Remapping */
S#define  TIM_OR_TI1RMP_0                     ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_OR_TI1RMP_1                     ((uint16_t)0x0002)            /*!<Bit 1 */
S
S/******************************************************************************/
S/*                                                                            */
S/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for USART_SR register  *******************/
S#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */
S#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */
S#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */
S#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */
S#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */
S#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */
S#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */
S#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */
S#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */
S#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */
S
S/*******************  Bit definition for USART_DR register  *******************/
S#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */
S
S/******************  Bit definition for USART_BRR register  *******************/
S#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */
S#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */
S
S/******************  Bit definition for USART_CR1 register  *******************/
S#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */
S#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */
S#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */
S#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */
S#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */
S#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */
S#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */
S#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */
S#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */
S#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */
S#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */
S#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */
S#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */
S#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */
S#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< Oversampling by 8-bit mode */
S
S/******************  Bit definition for USART_CR2 register  *******************/
S#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */
S#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */
S#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */
S#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */
S#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */
S#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */
S#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */
S
S#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */
S#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */
S#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */
S
S#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */
S
S/******************  Bit definition for USART_CR3 register  *******************/
S#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */
S#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */
S#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */
S#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */
S#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */
S#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */
S#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */
S#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */
S#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */
S#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */
S#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */
S#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One sample bit method enable */
S
S/******************  Bit definition for USART_GTPR register  ******************/
S#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */
S#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */
S#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */
S
S#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */
S
S/******************************************************************************/
S/*                                                                            */
S/*                     Universal Serial Bus (USB)                             */
S/*                                                                            */
S/******************************************************************************/
S
S/*!<Endpoint-specific registers */
S/*******************  Bit definition for USB_EP0R register  *******************/
S#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP1R register  *******************/
S#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP2R register  *******************/
S#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP3R register  *******************/
S#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP4R register  *******************/
S#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP5R register  *******************/
S#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP6R register  *******************/
S#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*******************  Bit definition for USB_EP7R register  *******************/
S#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!<Endpoint Address */
S
S#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!<STAT_TX[1:0] bits (Status bits, for transmission transfers) */
S#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!<Bit 1 */
S
S#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!<Data Toggle, for transmission transfers */
S#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!<Correct Transfer for transmission */
S#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!<Endpoint Kind */
S
S#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!<EP_TYPE[1:0] bits (Endpoint type) */
S#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!<Bit 0 */
S#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!<Bit 1 */
S
S#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!<Setup transaction completed */
S
S#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!<STAT_RX[1:0] bits (Status bits, for reception transfers) */
S#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!<Data Toggle, for reception transfers */
S#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!<Correct Transfer for reception */
S
S/*!<Common registers */
S/*******************  Bit definition for USB_CNTR register  *******************/
S#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!<Force USB Reset */
S#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!<Power down */
S#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!<Low-power mode */
S#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!<Force suspend */
S#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!<Resume request */
S#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!<Expected Start Of Frame Interrupt Mask */
S#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!<Start Of Frame Interrupt Mask */
S#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!<RESET Interrupt Mask */
S#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!<Suspend mode Interrupt Mask */
S#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!<Wakeup Interrupt Mask */
S#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!<Error Interrupt Mask */
S#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!<Packet Memory Area Over / Underrun Interrupt Mask */
S#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!<Correct Transfer Interrupt Mask */
S
S/*******************  Bit definition for USB_ISTR register  *******************/
S#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!<Endpoint Identifier */
S#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!<Direction of transaction */
S#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!<Expected Start Of Frame */
S#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!<Start Of Frame */
S#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!<USB RESET request */
S#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!<Suspend mode request */
S#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!<Wake up */
S#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!<Error */
S#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!<Packet Memory Area Over / Underrun */
S#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!<Correct Transfer */
S
S/*******************  Bit definition for USB_FNR register  ********************/
S#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!<Frame Number */
S#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!<Lost SOF */
S#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!<Locked */
S#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!<Receive Data - Line Status */
S#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!<Receive Data + Line Status */
S
S/******************  Bit definition for USB_DADDR register  *******************/
S#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!<ADD[6:0] bits (Device Address) */
S#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!<Bit 0 */
S#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!<Bit 1 */
S#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!<Bit 2 */
S#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!<Bit 3 */
S#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!<Bit 4 */
S#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!<Bit 5 */
S#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!<Bit 6 */
S
S#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!<Enable Function */
S
S/******************  Bit definition for USB_BTABLE register  ******************/    
S#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!<Buffer Table */
S
S/*!< Buffer descriptor table */
S/*****************  Bit definition for USB_ADDR0_TX register  *****************/
S#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */
S
S/*****************  Bit definition for USB_ADDR1_TX register  *****************/
S#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */
S
S/*****************  Bit definition for USB_ADDR2_TX register  *****************/
S#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */
S
S/*****************  Bit definition for USB_ADDR3_TX register  *****************/
S#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */
S
S/*****************  Bit definition for USB_ADDR4_TX register  *****************/
S#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */
S
S/*****************  Bit definition for USB_ADDR5_TX register  *****************/
S#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */
S
S/*****************  Bit definition for USB_ADDR6_TX register  *****************/
S#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */
S
S/*****************  Bit definition for USB_ADDR7_TX register  *****************/
S#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_COUNT0_TX register  ****************/
S#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */
S
S/*****************  Bit definition for USB_COUNT1_TX register  ****************/
S#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */
S
S/*****************  Bit definition for USB_COUNT2_TX register  ****************/
S#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */
S
S/*****************  Bit definition for USB_COUNT3_TX register  ****************/
S#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */
S
S/*****************  Bit definition for USB_COUNT4_TX register  ****************/
S#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */
S
S/*****************  Bit definition for USB_COUNT5_TX register  ****************/
S#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */
S
S/*****************  Bit definition for USB_COUNT6_TX register  ****************/
S#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */
S
S/*****************  Bit definition for USB_COUNT7_TX register  ****************/
S#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
S#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */
S
S/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
S#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */
S
S/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
S#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */
S
S/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
S#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */
S
S/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
S#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */
S
S/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
S#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */
S
S/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
S#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */
S
S/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
S#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */
S
S/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
S#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */
S
S/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
S#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */
S
S/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
S#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */
S
S/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
S#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */
S
S/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
S#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */
S
S/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
S#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */
S
S/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
S#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */
S
S/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
S#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_ADDR0_RX register  *****************/
S#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */
S
S/*****************  Bit definition for USB_ADDR1_RX register  *****************/
S#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */
S
S/*****************  Bit definition for USB_ADDR2_RX register  *****************/
S#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */
S
S/*****************  Bit definition for USB_ADDR3_RX register  *****************/
S#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */
S
S/*****************  Bit definition for USB_ADDR4_RX register  *****************/
S#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */
S
S/*****************  Bit definition for USB_ADDR5_RX register  *****************/
S#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */
S
S/*****************  Bit definition for USB_ADDR6_RX register  *****************/
S#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */
S
S/*****************  Bit definition for USB_ADDR7_RX register  *****************/
S#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */
S
S/*----------------------------------------------------------------------------*/
S
S/*****************  Bit definition for USB_COUNT0_RX register  ****************/
S#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT1_RX register  ****************/
S#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT2_RX register  ****************/
S#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT3_RX register  ****************/
S#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT4_RX register  ****************/
S#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT5_RX register  ****************/
S#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT6_RX register  ****************/
S#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*****************  Bit definition for USB_COUNT7_RX register  ****************/
S#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */
S
S#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
S#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */
S#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */
S#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */
S#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */
S#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */
S
S/*----------------------------------------------------------------------------*/
S
S/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
S#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
S#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
S#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
S#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
S#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
S#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
S#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
S#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
S#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
S#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
S#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
S#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
S#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
S#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
S#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */
S
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */
S
S/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
S#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */
S
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */
S#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */
S
S#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Window WATCHDOG (WWDG)                             */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for WWDG_CR register  ********************/
S#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
S#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
S#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
S#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
S#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
S#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
S#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
S#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
S
S#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
S
S/*******************  Bit definition for WWDG_CFR register  *******************/
S#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
S#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
S#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
S#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
S#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
S#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
S#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
S#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
S
S#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
S#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
S#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
S
S#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
S
S/*******************  Bit definition for WWDG_SR register  ********************/
S#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        SystemTick (SysTick)                                */
S/*                                                                            */
S/******************************************************************************/
S
S/*****************  Bit definition for SysTick_CTRL register  *****************/
S#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */
S#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */
S#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */
S#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */
S
S/*****************  Bit definition for SysTick_LOAD register  *****************/
S#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */
S
S/*****************  Bit definition for SysTick_VAL register  ******************/
S#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */
S
S/*****************  Bit definition for SysTick_CALIB register  ****************/
S#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */
S#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */
S#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */
S
S/******************************************************************************/
S/*                                                                            */
S/*               Nested Vectored Interrupt Controller (NVIC)                  */
S/*                                                                            */
S/******************************************************************************/
S
S/******************  Bit definition for NVIC_ISER register  *******************/
S#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */
S#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ICER register  *******************/
S#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */
S#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ISPR register  *******************/
S#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */
S#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_ICPR register  *******************/
S#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */
S#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_IABR register  *******************/
S#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */
S#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */
S#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */
S#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */
S#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */
S#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */
S#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */
S#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */
S#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */
S#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */
S#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */
S#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */
S#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */
S#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */
S#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */
S#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */
S#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */
S#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */
S#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */
S#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */
S#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */
S#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */
S#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */
S#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */
S#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */
S#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */
S#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */
S#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */
S#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */
S#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */
S#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */
S#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */
S#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */
S
S/******************  Bit definition for NVIC_PRI0 register  *******************/
S#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */
S#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */
S#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */
S#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */
S
S/******************  Bit definition for NVIC_PRI1 register  *******************/
S#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */
S#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */
S#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */
S#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */
S
S/******************  Bit definition for NVIC_PRI2 register  *******************/
S#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */
S#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */
S#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */
S#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */
S
S/******************  Bit definition for NVIC_PRI3 register  *******************/
S#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */
S#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */
S#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */
S#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */
S
S/******************  Bit definition for NVIC_PRI4 register  *******************/
S#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */
S#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */
S#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */
S#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */
S
S/******************  Bit definition for NVIC_PRI5 register  *******************/
S#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */
S#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */
S#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */
S#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */
S
S/******************  Bit definition for NVIC_PRI6 register  *******************/
S#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */
S#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */
S#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */
S#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */
S
S/******************  Bit definition for NVIC_PRI7 register  *******************/
S#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */
S#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */
S#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */
S#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */
S
S/******************  Bit definition for SCB_CPUID register  *******************/
S#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */
S#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */
S#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */
S#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */
S#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */
S
S/*******************  Bit definition for SCB_ICSR register  *******************/
S#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */
S#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */
S#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */
S#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */
S#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */
S#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */
S#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */
S#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */
S#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */
S#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */
S
S/*******************  Bit definition for SCB_VTOR register  *******************/
S#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */
S#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */
S
S/*!<*****************  Bit definition for SCB_AIRCR register  *******************/
S#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */
S#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */
S#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */
S
S#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */
S#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */
S
S/* prority group configuration */
S#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */
S#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */
S#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */
S
S#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */
S#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */
S
S/*******************  Bit definition for SCB_SCR register  ********************/
S#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */
S#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */
S#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */
S
S/********************  Bit definition for SCB_CCR register  *******************/
S#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */
S#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */
S#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */
S#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */
S#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */
S#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */
S
S/*******************  Bit definition for SCB_SHPR register ********************/
S#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */
S#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */
S#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */
S#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */
S
S/******************  Bit definition for SCB_SHCSR register  *******************/
S#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */
S#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */
S#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */
S#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */
S#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */
S#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */
S#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */
S#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */
S#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */
S#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */
S#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */
S#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */
S#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */
S#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */
S
S/*******************  Bit definition for SCB_CFSR register  *******************/
S/*!< MFSR */
S#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */
S#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */
S#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */
S#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */
S#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */
S/*!< BFSR */
S#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */
S#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */
S#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */
S#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */
S#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */
S#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */
S/*!< UFSR */
S#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to excecute an undefined instruction */
S#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */
S#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */
S#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */
S#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */
S#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */
S
S/*******************  Bit definition for SCB_HFSR register  *******************/
S#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occures because of vector table read on exception processing */
S#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */
S#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */
S
S/*******************  Bit definition for SCB_DFSR register  *******************/
S#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */
S#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */
S#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */
S#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */
S#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */
S
S/*******************  Bit definition for SCB_MMFAR register  ******************/
S#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */
S
S/*******************  Bit definition for SCB_BFAR register  *******************/
S#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */
S
S/*******************  Bit definition for SCB_afsr register  *******************/
S#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */
S/**
S  * @}
S  */
S
S /**
S  * @}
S  */ 
S
S#ifdef USE_STDPERIPH_DRIVER
S  #include "stm32l1xx_conf.h"
S#endif
S
S/** @addtogroup Exported_macro
S  * @{
S  */
S
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __STM32L1XX_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_aes.h" 2
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup AES
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/**
N  * @brief   AES Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t AES_Operation; /*!< Specifies the AES mode of operation.
N                               This parameter can be a value of @ref AES_possible_Operation_modes */
N  uint32_t AES_Chaining;  /*!< Specifies the AES Chaining modes: ECB, CBC or CTR.
N                               This parameter can be a value of @ref AES_possible_chaining_modes */
N  uint32_t AES_DataType;  /*!< Specifies the AES data swapping: 32-bit, 16-bit, 8-bit or 1-bit.
N                               This parameter can be a value of @ref AES_Data_Types */
N}AES_InitTypeDef;
N
N/** 
N  * @brief   AES Key(s) structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t AES_Key0;  /*!< Key[31:0]   */
N  uint32_t AES_Key1;  /*!< Key[63:32]  */
N  uint32_t AES_Key2;  /*!< Key[95:64]  */
N  uint32_t AES_Key3;  /*!< Key[127:96] */
N}AES_KeyInitTypeDef;
N
N/** 
N  * @brief   AES Initialization Vectors (IV) structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t AES_IV0;  /*!< Init Vector IV[31:0]   */
N  uint32_t AES_IV1;  /*!< Init Vector IV[63:32]  */
N  uint32_t AES_IV2;  /*!< Init Vector IV[95:64]  */
N  uint32_t AES_IV3;  /*!< Init Vector IV[127:96] */
N}AES_IVInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup AES_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup AES_possible_Operation_modes
N  * @{
N  */  
N#define AES_Operation_Encryp               ((uint32_t)0x00000000) /*!< AES in Encryption mode */
N#define AES_Operation_KeyDeriv             AES_CR_MODE_0          /*!< AES in Key Derivation mode */
N#define AES_Operation_Decryp               AES_CR_MODE_1          /*!< AES in Decryption mode */
N#define AES_Operation_KeyDerivAndDecryp    AES_CR_MODE            /*!< AES in Key Derivation and Decryption mode */
N
N#define IS_AES_MODE(OPERATION) (((OPERATION) == AES_Operation_Encryp)    || \
N                                ((OPERATION) == AES_Operation_KeyDeriv)  || \
N                                ((OPERATION) == AES_Operation_Decryp)    || \
N                                ((OPERATION) == AES_Operation_KeyDerivAndDecryp))
X#define IS_AES_MODE(OPERATION) (((OPERATION) == AES_Operation_Encryp)    ||                                 ((OPERATION) == AES_Operation_KeyDeriv)  ||                                 ((OPERATION) == AES_Operation_Decryp)    ||                                 ((OPERATION) == AES_Operation_KeyDerivAndDecryp))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup AES_possible_chaining_modes
N  * @{
N  */ 
N#define AES_Chaining_ECB                   ((uint32_t)0x00000000) /*!< AES in ECB chaining mode */
N#define AES_Chaining_CBC                   AES_CR_CHMOD_0         /*!< AES in CBC chaining mode */
N#define AES_Chaining_CTR                   AES_CR_CHMOD_1         /*!< AES in CTR chaining mode */
N
N#define IS_AES_CHAINING(CHAINING) (((CHAINING) == AES_Chaining_ECB) || \
N                                   ((CHAINING) == AES_Chaining_CBC) || \
N                                   ((CHAINING) == AES_Chaining_CTR))
X#define IS_AES_CHAINING(CHAINING) (((CHAINING) == AES_Chaining_ECB) ||                                    ((CHAINING) == AES_Chaining_CBC) ||                                    ((CHAINING) == AES_Chaining_CTR))
N/**
N  * @}
N  */
N
N/** @defgroup AES_Data_Types
N  * @{
N  */ 
N#define AES_DataType_32b                   ((uint32_t)0x00000000) /*!< 32-bit data. No swapping */
N#define AES_DataType_16b                   AES_CR_DATATYPE_0      /*!< 16-bit data. Each half word is swapped */
N#define AES_DataType_8b                    AES_CR_DATATYPE_1      /*!< 8-bit data. All bytes are swapped */
N#define AES_DataType_1b                    AES_CR_DATATYPE        /*!< 1-bit data. In the word all bits are swapped */
N
N#define IS_AES_DATATYPE(DATATYPE) (((DATATYPE) == AES_DataType_32b) || \
N                                    ((DATATYPE) == AES_DataType_16b)|| \
N                                    ((DATATYPE) == AES_DataType_8b) || \
N                                    ((DATATYPE) == AES_DataType_1b))
X#define IS_AES_DATATYPE(DATATYPE) (((DATATYPE) == AES_DataType_32b) ||                                     ((DATATYPE) == AES_DataType_16b)||                                     ((DATATYPE) == AES_DataType_8b) ||                                     ((DATATYPE) == AES_DataType_1b))
N/**
N  * @}
N  */
N
N/** @defgroup AES_Flags
N  * @{
N  */ 
N#define AES_FLAG_CCF                       AES_SR_CCF    /*!< Computation Complete Flag */
N#define AES_FLAG_RDERR                     AES_SR_RDERR  /*!< Read Error Flag           */
N#define AES_FLAG_WRERR                     AES_SR_WRERR  /*!< Write Error Flag          */
N
N#define IS_AES_FLAG(FLAG) (((FLAG) == AES_FLAG_CCF)    || \
N                           ((FLAG) == AES_FLAG_RDERR)  || \
N                           ((FLAG) == AES_FLAG_WRERR))
X#define IS_AES_FLAG(FLAG) (((FLAG) == AES_FLAG_CCF)    ||                            ((FLAG) == AES_FLAG_RDERR)  ||                            ((FLAG) == AES_FLAG_WRERR))
N/**
N  * @}
N  */ 
N
N/** @defgroup AES_Interrupts
N  * @{
N  */ 
N#define AES_IT_CC                          AES_CR_CCIE  /*!< Computation Complete interrupt */
N#define AES_IT_ERR                         AES_CR_ERRIE /*!< Error interrupt                */
N
N#define IS_AES_IT(IT) ((((IT) & (uint32_t)0xFFFFF9FF) == 0x00) && ((IT) != 0x00))
N#define IS_AES_GET_IT(IT) (((IT) == AES_IT_CC) || ((IT) == AES_IT_ERR))
N
N/**
N  * @}
N  */
N
N/** @defgroup AES_DMA_Transfer_modes
N  * @{
N  */ 
N#define AES_DMATransfer_In                 AES_CR_DMAINEN                     /*!< DMA requests enabled for input transfer phase */
N#define AES_DMATransfer_Out                AES_CR_DMAOUTEN                    /*!< DMA requests enabled for input transfer phase */
N#define AES_DMATransfer_InOut              (AES_CR_DMAINEN | AES_CR_DMAOUTEN) /*!< DMA requests enabled for both input and output phases */
N
N#define IS_AES_DMA_TRANSFER(TRANSFER)   (((TRANSFER) == AES_DMATransfer_In)  || \
N                                         ((TRANSFER) == AES_DMATransfer_Out)  || \
N                                         ((TRANSFER) == AES_DMATransfer_InOut))
X#define IS_AES_DMA_TRANSFER(TRANSFER)   (((TRANSFER) == AES_DMATransfer_In)  ||                                          ((TRANSFER) == AES_DMATransfer_Out)  ||                                          ((TRANSFER) == AES_DMATransfer_InOut))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Initialization and configuration functions *********************************/
Nvoid AES_DeInit(void);
Nvoid AES_Init(AES_InitTypeDef* AES_InitStruct);
Nvoid AES_KeyInit(AES_KeyInitTypeDef* AES_KeyInitStruct);
Nvoid AES_IVInit(AES_IVInitTypeDef* AES_IVInitStruct);
Nvoid AES_Cmd(FunctionalState NewState);
N
N/* Structures initialization functions ****************************************/
Nvoid AES_StructInit(AES_InitTypeDef* AES_InitStruct);
Nvoid AES_KeyStructInit(AES_KeyInitTypeDef* AES_KeyInitStruct);
Nvoid AES_IVStructInit(AES_IVInitTypeDef* AES_IVInitStruct);
N
N/* AES Read and Write functions **********************************************/  
Nvoid AES_WriteSubData(uint32_t Data);
Nuint32_t AES_ReadSubData(void);
Nvoid AES_ReadKey(AES_KeyInitTypeDef* AES_KeyInitStruct);
Nvoid AES_ReadIV(AES_IVInitTypeDef* AES_IVInitStruct);
N
N/* DMA transfers management function ******************************************/
Nvoid AES_DMAConfig(uint32_t AES_DMATransfer, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid AES_ITConfig(uint32_t AES_IT, FunctionalState NewState);
NFlagStatus AES_GetFlagStatus(uint32_t AES_FLAG);
Nvoid AES_ClearFlag(uint32_t AES_FLAG);
NITStatus AES_GetITStatus(uint32_t AES_IT);
Nvoid AES_ClearITPendingBit(uint32_t AES_IT);
N
N/* High Level AES functions **************************************************/
NErrorStatus AES_ECB_Encrypt(uint8_t* Key, uint8_t* Input, uint32_t Ilength, uint8_t* Output);
NErrorStatus AES_ECB_Decrypt(uint8_t* Key, uint8_t* Input, uint32_t Ilength, uint8_t* Output);
NErrorStatus AES_CBC_Encrypt(uint8_t* Key, uint8_t InitVectors[16], uint8_t* Input, uint32_t Ilength, uint8_t* Output);
NErrorStatus AES_CBC_Decrypt(uint8_t* Key, uint8_t InitVectors[16], uint8_t* Input, uint32_t Ilength, uint8_t* Output);
NErrorStatus AES_CTR_Encrypt(uint8_t* Key, uint8_t InitVectors[16], uint8_t* Input, uint32_t Ilength, uint8_t* Output);
NErrorStatus AES_CTR_Decrypt(uint8_t* Key, uint8_t InitVectors[16], uint8_t* Input, uint32_t Ilength, uint8_t* Output);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_AES_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 36 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_comp.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_comp.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_comp.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the COMP firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_COMP_H
N#define __STM32L1xx_COMP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup COMP
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  COMP Init structure definition  
N  */
N  
Ntypedef struct
N{
N  uint32_t COMP_Speed;               /*!< Defines the speed of comparator 2.
N                                          This parameter can be a value of @ref COMP_Speed */
N  uint32_t COMP_InvertingInput;      /*!< Selects the inverting input of the comparator 2.
N                                          This parameter can be a value of @ref COMP_InvertingInput */
N  uint32_t COMP_OutputSelect;        /*!< Selects the output redirection of the comparator 2.
N                                          This parameter can be a value of @ref COMP_OutputSelect */
N   
N}COMP_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N   
N/** @defgroup COMP_Exported_Constants
N  * @{
N  */ 
N
N#define COMP_OutputLevel_High                   ((uint32_t)0x00000001)
N#define COMP_OutputLevel_Low                    ((uint32_t)0x00000000)
N
N/** @defgroup COMP_Selection
N  * @{
N  */
N
N#define COMP_Selection_COMP1                    ((uint32_t)0x00000001)
N#define COMP_Selection_COMP2                    ((uint32_t)0x00000002)
N
N#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == COMP_Selection_COMP1) || \
N                                    ((PERIPH) == COMP_Selection_COMP2))
X#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == COMP_Selection_COMP1) ||                                     ((PERIPH) == COMP_Selection_COMP2))
N 
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_InvertingInput
N  * @{
N  */
N
N#define COMP_InvertingInput_None                ((uint32_t)0x00000000) /* COMP2 is disabled when this parameter is selected */
N#define COMP_InvertingInput_IO                  ((uint32_t)0x00040000)
N#define COMP_InvertingInput_VREFINT             ((uint32_t)0x00080000)
N#define COMP_InvertingInput_3_4VREFINT          ((uint32_t)0x000C0000)
N#define COMP_InvertingInput_1_2VREFINT          ((uint32_t)0x00100000)
N#define COMP_InvertingInput_1_4VREFINT          ((uint32_t)0x00140000)
N#define COMP_InvertingInput_DAC1                ((uint32_t)0x00180000)
N#define COMP_InvertingInput_DAC2                ((uint32_t)0x001C0000)
N
N#define IS_COMP_INVERTING_INPUT(INPUT) (((INPUT) == COMP_InvertingInput_None) || \
N                                        ((INPUT) == COMP_InvertingInput_IO) || \
N                                        ((INPUT) == COMP_InvertingInput_VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_3_4VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_1_2VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_1_4VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_DAC1) || \
N                                        ((INPUT) == COMP_InvertingInput_DAC2))
X#define IS_COMP_INVERTING_INPUT(INPUT) (((INPUT) == COMP_InvertingInput_None) ||                                         ((INPUT) == COMP_InvertingInput_IO) ||                                         ((INPUT) == COMP_InvertingInput_VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_3_4VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_1_2VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_1_4VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_DAC1) ||                                         ((INPUT) == COMP_InvertingInput_DAC2))
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_OutputSelect
N  * @{
N  */
N
N#define COMP_OutputSelect_TIM2IC4               ((uint32_t)0x00000000)
N#define COMP_OutputSelect_TIM2OCREFCLR          ((uint32_t)0x00200000)
N#define COMP_OutputSelect_TIM3IC4               ((uint32_t)0x00400000)
N#define COMP_OutputSelect_TIM3OCREFCLR          ((uint32_t)0x00600000)
N#define COMP_OutputSelect_TIM4IC4               ((uint32_t)0x00800000)
N#define COMP_OutputSelect_TIM4OCREFCLR          ((uint32_t)0x00A00000)
N#define COMP_OutputSelect_TIM10IC1              ((uint32_t)0x00C00000)
N#define COMP_OutputSelect_None                  ((uint32_t)0x00E00000)
N
N#define IS_COMP_OUTPUT(OUTPUT) (((OUTPUT) == COMP_OutputSelect_TIM2IC4) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM2OCREFCLR) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM3IC4) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM3OCREFCLR) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM4IC4) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM4OCREFCLR) || \
N                                ((OUTPUT) == COMP_OutputSelect_TIM10IC1) || \
N                                ((OUTPUT) == COMP_OutputSelect_None))
X#define IS_COMP_OUTPUT(OUTPUT) (((OUTPUT) == COMP_OutputSelect_TIM2IC4) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM2OCREFCLR) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM3IC4) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM3OCREFCLR) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM4IC4) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM4OCREFCLR) ||                                 ((OUTPUT) == COMP_OutputSelect_TIM10IC1) ||                                 ((OUTPUT) == COMP_OutputSelect_None))
N/**
N  * @}
N  */ 
N  
N/** @defgroup COMP_Speed
N  * @{
N  */
N
N#define COMP_Speed_Slow                         ((uint32_t)0x00000000)
N#define COMP_Speed_Fast                         ((uint32_t)0x00001000)
N
N#define IS_COMP_SPEED(SPEED)    (((SPEED) == COMP_Speed_Slow) || \
N                                 ((SPEED) == COMP_Speed_Fast))
X#define IS_COMP_SPEED(SPEED)    (((SPEED) == COMP_Speed_Slow) ||                                  ((SPEED) == COMP_Speed_Fast))
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the COMP configuration to the default reset state ****/
Nvoid COMP_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid COMP_Init(COMP_InitTypeDef* COMP_InitStruct);
Nvoid COMP_Cmd(FunctionalState NewState);
Nuint8_t COMP_GetOutputLevel(uint32_t COMP_Selection);
Nvoid COMP_SW1SwitchConfig(FunctionalState NewState);
N
N/* Window mode control function ***********************************************/
Nvoid COMP_WindowCmd(FunctionalState NewState);
N
N/* Internal Reference Voltage (VREFINT) output function ***********************/
Nvoid COMP_VrefintOutputCmd(FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_COMP_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 37 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_crc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_crc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the CRC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_CRC_H
N#define __STM32L1xx_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CRC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRC_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
Nvoid CRC_ResetDR(void);
Nuint32_t CRC_CalcCRC(uint32_t Data);
Nuint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t CRC_GetCRC(void);
Nvoid CRC_SetIDRegister(uint8_t IDValue);
Nuint8_t CRC_GetIDRegister(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_CRC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 38 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_dac.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_dac.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the DAC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_DAC_H
N#define __STM32L1xx_DAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N 
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DAC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DAC Init structure definition
N  */
N  
Ntypedef struct
N{
N  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
N                                                  This parameter can be a value of @ref DAC_trigger_selection */
N
N  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
N                                                  are generated, or whether no wave is generated.
N                                                  This parameter can be a value of @ref DAC_wave_generation */
N
N  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
N                                                  the maximum amplitude triangle generation for the DAC channel. 
N                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
N
N  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
N                                                  This parameter can be a value of @ref DAC_output_buffer */
N}DAC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DAC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup DAC_trigger_selection 
N  * @{
N  */
N  
N#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
N                                                                       has been loaded, and not by external trigger */
N#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T9_TRGO                ((uint32_t)0x0000001C) /*!< TIM9 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
N#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
N                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T9_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
N                                 ((TRIGGER) == DAC_Trigger_Software))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) ||                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T7_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T9_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T2_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T4_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) ||                                  ((TRIGGER) == DAC_Trigger_Software))
N                                 
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
N#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
N#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
N#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
N                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
N                                    ((WAVE) == DAC_WaveGeneration_Triangle))
X#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) ||                                     ((WAVE) == DAC_WaveGeneration_Noise) ||                                     ((WAVE) == DAC_WaveGeneration_Triangle))
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_lfsrunmask_triangleamplitude
N  * @{
N  */
N
N#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
N#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
N#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
N#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
N#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
N#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
N#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
N#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
N#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
N#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
N#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
N#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
N#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
N#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
N
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits2_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits3_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits4_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits5_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits6_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits7_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits8_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits9_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits10_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits11_0) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1) ||                                                       ((VALUE) == DAC_TriangleAmplitude_3) ||                                                       ((VALUE) == DAC_TriangleAmplitude_7) ||                                                       ((VALUE) == DAC_TriangleAmplitude_15) ||                                                       ((VALUE) == DAC_TriangleAmplitude_31) ||                                                       ((VALUE) == DAC_TriangleAmplitude_63) ||                                                       ((VALUE) == DAC_TriangleAmplitude_127) ||                                                       ((VALUE) == DAC_TriangleAmplitude_255) ||                                                       ((VALUE) == DAC_TriangleAmplitude_511) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1023) ||                                                       ((VALUE) == DAC_TriangleAmplitude_2047) ||                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_output_buffer 
N  * @{
N  */
N
N#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
N#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
N                                           ((STATE) == DAC_OutputBuffer_Disable))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) ||                                            ((STATE) == DAC_OutputBuffer_Disable))
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_Channel_selection 
N  * @{
N  */
N
N#define DAC_Channel_1                      ((uint32_t)0x00000000)
N#define DAC_Channel_2                      ((uint32_t)0x00000010)
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
N                                 ((CHANNEL) == DAC_Channel_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) ||                                  ((CHANNEL) == DAC_Channel_2))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data_alignment 
N  * @{
N  */
N
N#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
N#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
N#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
N                             ((ALIGN) == DAC_Align_12b_L) || \
N                             ((ALIGN) == DAC_Align_8b_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) ||                              ((ALIGN) == DAC_Align_12b_L) ||                              ((ALIGN) == DAC_Align_8b_R))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
N#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
N                           ((WAVE) == DAC_Wave_Triangle))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) ||                            ((WAVE) == DAC_Wave_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data 
N  * @{
N  */
N
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_interrupts_definition 
N  * @{
N  */ 
N  
N#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
N#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DAC_flags_definition 
N  * @{
N  */ 
N  
N#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)   
N  
N#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the DAC configuration to the default reset state *****/  
Nvoid DAC_DeInit(void);
N
N/*  DAC channels configuration: trigger, output buffer, data format functions */
Nvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
Nvoid DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
Nvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
Nuint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);
N
N/* DMA management functions ***************************************************/
Nvoid DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
NFlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
Nvoid DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
NITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
Nvoid DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_DAC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_dbgmcu.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_dbgmcu.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_dbgmcu.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the DBGMCU 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_DBGMCU_H
N#define __STM32L1xx_DBGMCU_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DBGMCU
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DBGMCU_Exported_Constants
N  * @{
N  */
N
N#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
N#define DBGMCU_STOP                  ((uint32_t)0x00000002)
N#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000001)
N#define DBGMCU_TIM3_STOP             ((uint32_t)0x00000002)
N#define DBGMCU_TIM4_STOP             ((uint32_t)0x00000004)
N#define DBGMCU_TIM5_STOP             ((uint32_t)0x00000008)
N#define DBGMCU_TIM6_STOP             ((uint32_t)0x00000010)
N#define DBGMCU_TIM7_STOP             ((uint32_t)0x00000020)
N#define DBGMCU_RTC_STOP              ((uint32_t)0x00000400)
N#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000800)
N#define DBGMCU_IWDG_STOP             ((uint32_t)0x00001000)
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)
N#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)
N#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xFF9FE3C0) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM9_STOP             ((uint32_t)0x00000004)
N#define DBGMCU_TIM10_STOP            ((uint32_t)0x00000008)
N#define DBGMCU_TIM11_STOP            ((uint32_t)0x00000010)
N#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFE3) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
Nuint32_t DBGMCU_GetREVID(void);
Nuint32_t DBGMCU_GetDEVID(void);
Nvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_DBGMCU_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 40 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_dma.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_dma.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the DMA firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_DMA_H
N#define __STM32L1xx_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DMA Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */
N
N  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */
N
N  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
N                                        This parameter can be a value of @ref DMA_data_transfer_direction */
N
N  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. 
N                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
N                                        or DMA_MemoryDataSize members depending in the transfer direction. */
N
N  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
N
N  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_memory_incremented_mode */
N
N  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
N                                        This parameter can be a value of @ref DMA_peripheral_data_size */
N
N  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
N                                        This parameter can be a value of @ref DMA_memory_data_size */
N
N  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_circular_normal_mode
N                                        @note: The circular buffer mode cannot be used if the memory-to-memory
N                                              data transfer is configured on the selected Channel */
N
N  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_priority_level */
N
N  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
N                                        This parameter can be a value of @ref DMA_memory_to_memory */
N}DMA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants
N  * @{
N  */
N
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
N                                   ((PERIPH) == DMA1_Channel2) || \
N                                   ((PERIPH) == DMA1_Channel3) || \
N                                   ((PERIPH) == DMA1_Channel4) || \
N                                   ((PERIPH) == DMA1_Channel5) || \
N                                   ((PERIPH) == DMA1_Channel6) || \
N                                   ((PERIPH) == DMA1_Channel7) || \
N                                   ((PERIPH) == DMA2_Channel1) || \
N                                   ((PERIPH) == DMA2_Channel2) || \
N                                   ((PERIPH) == DMA2_Channel3) || \
N                                   ((PERIPH) == DMA2_Channel4) || \
N                                   ((PERIPH) == DMA2_Channel5))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) ||                                    ((PERIPH) == DMA1_Channel2) ||                                    ((PERIPH) == DMA1_Channel3) ||                                    ((PERIPH) == DMA1_Channel4) ||                                    ((PERIPH) == DMA1_Channel5) ||                                    ((PERIPH) == DMA1_Channel6) ||                                    ((PERIPH) == DMA1_Channel7) ||                                    ((PERIPH) == DMA2_Channel1) ||                                    ((PERIPH) == DMA2_Channel2) ||                                    ((PERIPH) == DMA2_Channel3) ||                                    ((PERIPH) == DMA2_Channel4) ||                                    ((PERIPH) == DMA2_Channel5))
N
N/** @defgroup DMA_data_transfer_direction 
N  * @{
N  */
N
N#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)
N#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
N#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
N                         ((DIR) == DMA_DIR_PeripheralSRC))
X#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) ||                          ((DIR) == DMA_DIR_PeripheralSRC))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_incremented_mode 
N  * @{
N  */
N
N#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)
N#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
N                                            ((STATE) == DMA_PeripheralInc_Disable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) ||                                             ((STATE) == DMA_PeripheralInc_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_incremented_mode 
N  * @{
N  */
N
N#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)
N#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
N                                        ((STATE) == DMA_MemoryInc_Disable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) ||                                         ((STATE) == DMA_MemoryInc_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_data_size 
N  * @{
N  */
N
N#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
N#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)
N#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_data_size 
N  * @{
N  */
N
N#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
N#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)
N#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_circular_normal_mode 
N  * @{
N  */
N
N#define DMA_Mode_Circular                  ((uint32_t)0x00000020)
N#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_priority_level 
N  * @{
N  */
N
N#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)
N#define DMA_Priority_High                  ((uint32_t)0x00002000)
N#define DMA_Priority_Medium                ((uint32_t)0x00001000)
N#define DMA_Priority_Low                   ((uint32_t)0x00000000)
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
N                                   ((PRIORITY) == DMA_Priority_High) || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_Low))
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) ||                                    ((PRIORITY) == DMA_Priority_High) ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_Low))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_to_memory 
N  * @{
N  */
N
N#define DMA_M2M_Enable                     ((uint32_t)0x00004000)
N#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
N#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupts_definition 
N  * @{
N  */
N
N#define DMA_IT_TC                          ((uint32_t)0x00000002)
N#define DMA_IT_HT                          ((uint32_t)0x00000004)
N#define DMA_IT_TE                          ((uint32_t)0x00000008)
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
N
N#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
N#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
N#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
N#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
N#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
N#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
N#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
N#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
N#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
N#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
N#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
N#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
N#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
N#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
N#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
N#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
N#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
N#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
N#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
N#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
N#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
N#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
N#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
N#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
N#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
N#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
N#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
N#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
N
N#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
N#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
N#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
N#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
N#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
N#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
N#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
N#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
N#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
N#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
N#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
N#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
N#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
N#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
N#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
N#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
N#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
N#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
N#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
N#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
N
N#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
N                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
N                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
N                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
N                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
N                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
N                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
N                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
N                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
N                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
N                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
N                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
N                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
N                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
N                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
N                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
N                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
N                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
N                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
N                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
N                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
N                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
N                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
N                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) ||                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) ||                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) ||                            ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) ||                            ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) ||                            ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) ||                            ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) ||                            ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) ||                            ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) ||                            ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) ||                            ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) ||                            ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) ||                            ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) ||                            ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) ||                            ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) ||                            ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) ||                            ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) ||                            ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) ||                            ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) ||                            ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) ||                            ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) ||                            ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) ||                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) ||                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flags_definition 
N  * @{
N  */
N#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
N#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
N#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
N#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
N#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
N#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
N#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
N#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
N#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
N#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
N#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
N#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
N#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
N#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
N#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
N#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
N#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
N#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
N#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
N#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
N#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
N#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
N#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
N#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
N#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
N#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
N#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
N#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
N
N#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
N#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
N#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
N#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
N#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
N#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
N#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
N#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
N#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
N#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
N#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
N#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
N#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
N#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
N#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
N#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
N#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
N#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
N#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
N#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
N
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
N                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
N                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
N                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
N                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
N                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
N                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
N                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
N                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
N                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
N                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
N                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
N                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
N                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
N                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
N                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
N                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
N                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
N                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
N                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
N                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
N                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
N                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
N                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) ||                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) ||                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) ||                                ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) ||                                ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) ||                                ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) ||                                ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) ||                                ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) ||                                ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) ||                                ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) ||                                ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) ||                                ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) ||                                ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) ||                                ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) ||                                ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) ||                                ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) ||                                ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) ||                                ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) ||                                ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) ||                                ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) ||                                ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) ||                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) ||                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) ||                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Buffer_Size 
N  * @{
N  */
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the DMA configuration to the default reset state *****/ 
Nvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
N
N/* Data Counter functions *****************************************************/
Nvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);
Nuint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
NFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
Nvoid DMA_ClearFlag(uint32_t DMAy_FLAG);
NITStatus DMA_GetITStatus(uint32_t DMAy_IT);
Nvoid DMA_ClearITPendingBit(uint32_t DMAy_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_DMA_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 41 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_exti.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_exti.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the EXTI firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_EXTI_H
N#define __STM32L1xx_EXTI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup EXTI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  EXTI mode enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N
N/** 
N  * @brief  EXTI Trigger enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,  
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N/** 
N  * @brief  EXTI Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
N                                         This parameter can be any combination of @ref EXTI_Lines */
N   
N  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                         This parameter can be a value of @ref EXTITrigger_TypeDef */
N
N  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
N                                         This parameter can be set either to ENABLE or DISABLE */ 
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup EXTI_Exported_Constants
N  * @{
N  */
N
N/** @defgroup EXTI_Lines 
N  * @{
N  */
N
N#define EXTI_Line0       ((uint32_t)0x00000001)  /*!< External interrupt line 0 */
N#define EXTI_Line1       ((uint32_t)0x00000002)  /*!< External interrupt line 1 */
N#define EXTI_Line2       ((uint32_t)0x00000004)  /*!< External interrupt line 2 */
N#define EXTI_Line3       ((uint32_t)0x00000008)  /*!< External interrupt line 3 */
N#define EXTI_Line4       ((uint32_t)0x00000010)  /*!< External interrupt line 4 */
N#define EXTI_Line5       ((uint32_t)0x00000020)  /*!< External interrupt line 5 */
N#define EXTI_Line6       ((uint32_t)0x00000040)  /*!< External interrupt line 6 */
N#define EXTI_Line7       ((uint32_t)0x00000080)  /*!< External interrupt line 7 */
N#define EXTI_Line8       ((uint32_t)0x00000100)  /*!< External interrupt line 8 */
N#define EXTI_Line9       ((uint32_t)0x00000200)  /*!< External interrupt line 9 */
N#define EXTI_Line10      ((uint32_t)0x00000400)  /*!< External interrupt line 10 */
N#define EXTI_Line11      ((uint32_t)0x00000800)  /*!< External interrupt line 11 */
N#define EXTI_Line12      ((uint32_t)0x00001000)  /*!< External interrupt line 12 */
N#define EXTI_Line13      ((uint32_t)0x00002000)  /*!< External interrupt line 13 */
N#define EXTI_Line14      ((uint32_t)0x00004000)  /*!< External interrupt line 14 */
N#define EXTI_Line15      ((uint32_t)0x00008000)  /*!< External interrupt line 15 */
N#define EXTI_Line16      ((uint32_t)0x00010000)  /*!< External interrupt line 16 
N                                                      Connected to the PVD Output */
N#define EXTI_Line17      ((uint32_t)0x00020000)  /*!< External interrupt line 17 
N                                                      Connected to the RTC Alarm 
N                                                      event */
N#define EXTI_Line18      ((uint32_t)0x00040000)  /*!< External interrupt line 18 
N                                                      Connected to the USB Device 
N                                                      FS Wakeup from suspend event */
N#define EXTI_Line19      ((uint32_t)0x00080000)  /*!< External interrupt line 19 
N                                                      Connected to the RTC Tamper 
N                                                      and Time Stamp events */ 
N#define EXTI_Line20      ((uint32_t)0x00100000)  /*!< External interrupt line 20 
N                                                      Connected to the RTC Wakeup 
N                                                      event */
N#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< External interrupt line 21 
N                                                      Connected to the Comparator 1 
N                                                      event */
N
N#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< External interrupt line 22 
N                                                      Connected to the Comparator 2
N                                                      event */
N
N#define EXTI_Line23      ((uint32_t)0x00800000)  /*!< External interrupt line 23 
N                                                      Comparator channel acquisition event */
N
N#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFF000000) == 0x00) && ((LINE) != (uint16_t)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
N                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) || \
N                                ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                                 ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                                 ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                                 ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                                 ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                                 ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                                 ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                                 ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                                 ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                                 ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) ||                                 ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||                                 ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*  Function used to set the EXTI configuration to the default reset state *****/
Nvoid EXTI_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearFlag(uint32_t EXTI_Line);
NITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_EXTI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 42 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_flash.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_flash.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the FLASH 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_FLASH_H
N#define __STM32L1xx_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  FLASH Status  
N  */ 
Ntypedef enum
N{ 
N  FLASH_BUSY = 1,
N  FLASH_ERROR_WRP,
N  FLASH_ERROR_PROGRAM,
N  FLASH_COMPLETE,
N  FLASH_TIMEOUT
N}FLASH_Status;
N
N/* Exported constants --------------------------------------------------------*/
N  
N/** @defgroup FLASH_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup FLASH_Latency 
N  * @{
N  */ 
N#define FLASH_Latency_0                ((uint8_t)0x00)  /*!< FLASH Zero Latency cycle */
N#define FLASH_Latency_1                ((uint8_t)0x01)  /*!< FLASH One Latency cycle */
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Interrupts 
N  * @{
N  */
N   
N#define FLASH_IT_EOP               FLASH_PECR_EOPIE  /*!< End of programming interrupt source */
N#define FLASH_IT_ERR               FLASH_PECR_ERRIE  /*!< Error interrupt source */
N#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFCFFFF) == 0x00000000) && (((IT) != 0x00000000)))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Address 
N  * @{
N  */
N  
N#define IS_FLASH_DATA_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08080000) && ((ADDRESS) <= 0x08082FFF))
N#define IS_FLASH_PROGRAM_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0805FFFF))  
N
N/**
N  * @}
N  */ 
N
N/** @defgroup Option_Bytes_Write_Protection 
N  * @{
N  */
N  
N#define OB_WRP_Pages0to15              ((uint32_t)0x00000001) /* Write protection of Sector0 */
N#define OB_WRP_Pages16to31             ((uint32_t)0x00000002) /* Write protection of Sector1 */
N#define OB_WRP_Pages32to47             ((uint32_t)0x00000004) /* Write protection of Sector2 */
N#define OB_WRP_Pages48to63             ((uint32_t)0x00000008) /* Write protection of Sector3 */
N#define OB_WRP_Pages64to79             ((uint32_t)0x00000010) /* Write protection of Sector4 */
N#define OB_WRP_Pages80to95             ((uint32_t)0x00000020) /* Write protection of Sector5 */
N#define OB_WRP_Pages96to111            ((uint32_t)0x00000040) /* Write protection of Sector6 */
N#define OB_WRP_Pages112to127           ((uint32_t)0x00000080) /* Write protection of Sector7 */
N#define OB_WRP_Pages128to143           ((uint32_t)0x00000100) /* Write protection of Sector8 */
N#define OB_WRP_Pages144to159           ((uint32_t)0x00000200) /* Write protection of Sector9 */
N#define OB_WRP_Pages160to175           ((uint32_t)0x00000400) /* Write protection of Sector10 */
N#define OB_WRP_Pages176to191           ((uint32_t)0x00000800) /* Write protection of Sector11 */
N#define OB_WRP_Pages192to207           ((uint32_t)0x00001000) /* Write protection of Sector12 */
N#define OB_WRP_Pages208to223           ((uint32_t)0x00002000) /* Write protection of Sector13 */
N#define OB_WRP_Pages224to239           ((uint32_t)0x00004000) /* Write protection of Sector14 */
N#define OB_WRP_Pages240to255           ((uint32_t)0x00008000) /* Write protection of Sector15 */
N#define OB_WRP_Pages256to271           ((uint32_t)0x00010000) /* Write protection of Sector16 */
N#define OB_WRP_Pages272to287           ((uint32_t)0x00020000) /* Write protection of Sector17 */
N#define OB_WRP_Pages288to303           ((uint32_t)0x00040000) /* Write protection of Sector18 */
N#define OB_WRP_Pages304to319           ((uint32_t)0x00080000) /* Write protection of Sector19 */
N#define OB_WRP_Pages320to335           ((uint32_t)0x00100000) /* Write protection of Sector20 */
N#define OB_WRP_Pages336to351           ((uint32_t)0x00200000) /* Write protection of Sector21 */
N#define OB_WRP_Pages352to367           ((uint32_t)0x00400000) /* Write protection of Sector22 */
N#define OB_WRP_Pages368to383           ((uint32_t)0x00800000) /* Write protection of Sector23 */
N#define OB_WRP_Pages384to399           ((uint32_t)0x01000000) /* Write protection of Sector24 */
N#define OB_WRP_Pages400to415           ((uint32_t)0x02000000) /* Write protection of Sector25 */
N#define OB_WRP_Pages416to431           ((uint32_t)0x04000000) /* Write protection of Sector26 */
N#define OB_WRP_Pages432to447           ((uint32_t)0x08000000) /* Write protection of Sector27 */
N#define OB_WRP_Pages448to463           ((uint32_t)0x10000000) /* Write protection of Sector28 */
N#define OB_WRP_Pages464to479           ((uint32_t)0x20000000) /* Write protection of Sector29 */
N#define OB_WRP_Pages480to495           ((uint32_t)0x40000000) /* Write protection of Sector30 */
N#define OB_WRP_Pages496to511           ((uint32_t)0x80000000) /* Write protection of Sector31 */
N
N#define OB_WRP_AllPages                ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Sectors */
N
N#define OB_WRP1_Pages512to527          ((uint32_t)0x00000001) /* Write protection of Sector32 */
N#define OB_WRP1_Pages528to543          ((uint32_t)0x00000002) /* Write protection of Sector33 */
N#define OB_WRP1_Pages544to559          ((uint32_t)0x00000004) /* Write protection of Sector34 */
N#define OB_WRP1_Pages560to575          ((uint32_t)0x00000008) /* Write protection of Sector35 */
N#define OB_WRP1_Pages576to591          ((uint32_t)0x00000010) /* Write protection of Sector36 */
N#define OB_WRP1_Pages592to607          ((uint32_t)0x00000020) /* Write protection of Sector37 */
N#define OB_WRP1_Pages608to623          ((uint32_t)0x00000040) /* Write protection of Sector38 */
N#define OB_WRP1_Pages624to639          ((uint32_t)0x00000080) /* Write protection of Sector39 */
N#define OB_WRP1_Pages640to655          ((uint32_t)0x00000100) /* Write protection of Sector40 */
N#define OB_WRP1_Pages656to671          ((uint32_t)0x00000200) /* Write protection of Sector41 */
N#define OB_WRP1_Pages672to687          ((uint32_t)0x00000400) /* Write protection of Sector42 */
N#define OB_WRP1_Pages688to703          ((uint32_t)0x00000800) /* Write protection of Sector43 */
N#define OB_WRP1_Pages704to719          ((uint32_t)0x00001000) /* Write protection of Sector44 */
N#define OB_WRP1_Pages720to735          ((uint32_t)0x00002000) /* Write protection of Sector45 */
N#define OB_WRP1_Pages736to751          ((uint32_t)0x00004000) /* Write protection of Sector46 */
N#define OB_WRP1_Pages752to767          ((uint32_t)0x00008000) /* Write protection of Sector47 */
N#define OB_WRP1_Pages768to783          ((uint32_t)0x00010000) /* Write protection of Sector48 */
N#define OB_WRP1_Pages784to799          ((uint32_t)0x00020000) /* Write protection of Sector49 */
N#define OB_WRP1_Pages800to815          ((uint32_t)0x00040000) /* Write protection of Sector50 */
N#define OB_WRP1_Pages816to831          ((uint32_t)0x00080000) /* Write protection of Sector51 */
N#define OB_WRP1_Pages832to847          ((uint32_t)0x00100000) /* Write protection of Sector52 */
N#define OB_WRP1_Pages848to863          ((uint32_t)0x00200000) /* Write protection of Sector53 */
N#define OB_WRP1_Pages864to879          ((uint32_t)0x00400000) /* Write protection of Sector54 */
N#define OB_WRP1_Pages880to895          ((uint32_t)0x00800000) /* Write protection of Sector55 */
N#define OB_WRP1_Pages896to911          ((uint32_t)0x01000000) /* Write protection of Sector56 */
N#define OB_WRP1_Pages912to927          ((uint32_t)0x02000000) /* Write protection of Sector57 */
N#define OB_WRP1_Pages928to943          ((uint32_t)0x04000000) /* Write protection of Sector58 */
N#define OB_WRP1_Pages944to959          ((uint32_t)0x08000000) /* Write protection of Sector59 */
N#define OB_WRP1_Pages960to975          ((uint32_t)0x10000000) /* Write protection of Sector60 */
N#define OB_WRP1_Pages976to991          ((uint32_t)0x20000000) /* Write protection of Sector61 */
N#define OB_WRP1_Pages992to1007         ((uint32_t)0x40000000) /* Write protection of Sector62 */
N#define OB_WRP1_Pages1008to1023        ((uint32_t)0x80000000) /* Write protection of Sector63 */
N
N#define OB_WRP1_AllPages               ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Sectors */
N
N#define OB_WRP2_Pages1024to1039        ((uint32_t)0x00000001) /* Write protection of Sector64 */
N#define OB_WRP2_Pages1040to1055        ((uint32_t)0x00000002) /* Write protection of Sector65 */
N#define OB_WRP2_Pages1056to1071        ((uint32_t)0x00000004) /* Write protection of Sector66 */
N#define OB_WRP2_Pages1072to1087        ((uint32_t)0x00000008) /* Write protection of Sector67 */
N#define OB_WRP2_Pages1088to1103        ((uint32_t)0x00000010) /* Write protection of Sector68 */
N#define OB_WRP2_Pages1104to1119        ((uint32_t)0x00000020) /* Write protection of Sector69 */
N#define OB_WRP2_Pages1120to1135        ((uint32_t)0x00000040) /* Write protection of Sector70 */
N#define OB_WRP2_Pages1136to1151        ((uint32_t)0x00000080) /* Write protection of Sector71 */
N#define OB_WRP2_Pages1152to1167        ((uint32_t)0x00000100) /* Write protection of Sector72 */
N#define OB_WRP2_Pages1168to1183        ((uint32_t)0x00000200) /* Write protection of Sector73 */
N#define OB_WRP2_Pages1184to1199        ((uint32_t)0x00000400) /* Write protection of Sector74 */
N#define OB_WRP2_Pages1200to1215        ((uint32_t)0x00000800) /* Write protection of Sector75 */
N#define OB_WRP2_Pages1216to1231        ((uint32_t)0x00001000) /* Write protection of Sector76 */
N#define OB_WRP2_Pages1232to1247        ((uint32_t)0x00002000) /* Write protection of Sector77 */
N#define OB_WRP2_Pages1248to1263        ((uint32_t)0x00004000) /* Write protection of Sector78 */
N#define OB_WRP2_Pages1264to1279        ((uint32_t)0x00008000) /* Write protection of Sector79 */
N#define OB_WRP2_Pages1280to1295        ((uint32_t)0x00010000) /* Write protection of Sector80 */
N#define OB_WRP2_Pages1296to1311        ((uint32_t)0x00020000) /* Write protection of Sector81 */
N#define OB_WRP2_Pages1312to1327        ((uint32_t)0x00040000) /* Write protection of Sector82 */
N#define OB_WRP2_Pages1328to1343        ((uint32_t)0x00080000) /* Write protection of Sector83 */
N#define OB_WRP2_Pages1344to1359        ((uint32_t)0x00100000) /* Write protection of Sector84 */
N#define OB_WRP2_Pages1360to1375        ((uint32_t)0x00200000) /* Write protection of Sector85 */
N#define OB_WRP2_Pages1376to1391        ((uint32_t)0x00400000) /* Write protection of Sector86 */
N#define OB_WRP2_Pages1392to1407        ((uint32_t)0x00800000) /* Write protection of Sector87 */
N#define OB_WRP2_Pages1408to1423        ((uint32_t)0x01000000) /* Write protection of Sector88 */
N#define OB_WRP2_Pages1424to1439        ((uint32_t)0x02000000) /* Write protection of Sector89 */
N#define OB_WRP2_Pages1440to1455        ((uint32_t)0x04000000) /* Write protection of Sector90 */
N#define OB_WRP2_Pages1456to1471        ((uint32_t)0x08000000) /* Write protection of Sector91 */
N#define OB_WRP2_Pages1472to1487        ((uint32_t)0x10000000) /* Write protection of Sector92 */
N#define OB_WRP2_Pages1488to1503        ((uint32_t)0x20000000) /* Write protection of Sector93 */
N#define OB_WRP2_Pages1504to1519        ((uint32_t)0x40000000) /* Write protection of Sector94 */
N#define OB_WRP2_Pages1520to1535        ((uint32_t)0x80000000) /* Write protection of Sector95 */
N
N#define OB_WRP2_AllPages               ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Sectors */
N
N#define IS_OB_WRP(PAGE) (((PAGE) != 0x0000000))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup  Selection_Protection_Mode
N  * @{
N  */
N#define OB_PcROP_Enable     ((uint16_t)0x0100) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
N#define OB_PcROP_Disable    ((uint16_t)0x0000) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
N#define IS_OB_PCROP_SELECT(OB_PcROP) (((OB_PcROP) == OB_PcROP_Enable) || ((OB_PcROP) == OB_PcROP_Disable))
N/**
N  * @}
N  */
N
N
N/** @defgroup Option_Bytes_Read_Protection 
N  * @{
N  */ 
N
N/** 
N  * @brief  Read Protection Level  
N  */ 
N#define OB_RDP_Level_0   ((uint8_t)0xAA)
N#define OB_RDP_Level_1   ((uint8_t)0xBB)
N/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /* Warning: When enabling read protection level 2 
N                                                it's no more possible to go back to level 1 or 0 */
N
N#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
N                          ((LEVEL) == OB_RDP_Level_1))/*||\
N                          ((LEVEL) == OB_RDP_Level_2))*/
X#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||                          ((LEVEL) == OB_RDP_Level_1)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup Option_Bytes_IWatchdog 
N  * @{
N  */
N
N#define OB_IWDG_SW                     ((uint8_t)0x10)  /*!< Software WDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware WDG selected */
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_nRST_STOP 
N  * @{
N  */
N
N#define OB_STOP_NoRST                  ((uint8_t)0x20) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_nRST_STDBY 
N  * @{
N  */
N
N#define OB_STDBY_NoRST                 ((uint8_t)0x40) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_BOOT
N  * @{
N  */
N
N#define OB_BOOT_BANK2                  ((uint8_t)0x00) /*!< At startup, if boot pins are set in boot from user Flash position
N                                                            and this parameter is selected the device will boot from Bank 2 
N                                                            or Bank 1, depending on the activation of the bank */
N#define OB_BOOT_BANK1                  ((uint8_t)0x80) /*!< At startup, if boot pins are set in boot from user Flash position
N                                                            and this parameter is selected the device will boot from Bank1(Default) */
N#define IS_OB_BOOT_BANK(BANK) (((BANK) == OB_BOOT_BANK2) || ((BANK) == OB_BOOT_BANK1))
N
N/**
N  * @}
N  */
N
N/** @defgroup Option_Bytes_BOR_Level 
N  * @{
N  */
N
N#define OB_BOR_OFF       ((uint8_t)0x00) /*!< BOR is disabled at power down, the reset is asserted when the VDD 
N                                              power supply reaches the PDR(Power Down Reset) threshold (1.5V) */
N#define OB_BOR_LEVEL1    ((uint8_t)0x08) /*!< BOR Reset threshold levels for 1.7V - 1.8V VDD power supply    */
N#define OB_BOR_LEVEL2    ((uint8_t)0x09) /*!< BOR Reset threshold levels for 1.9V - 2.0V VDD power supply    */
N#define OB_BOR_LEVEL3    ((uint8_t)0x0A) /*!< BOR Reset threshold levels for 2.3V - 2.4V VDD power supply    */
N#define OB_BOR_LEVEL4    ((uint8_t)0x0B) /*!< BOR Reset threshold levels for 2.55V - 2.65V VDD power supply  */
N#define OB_BOR_LEVEL5    ((uint8_t)0x0C) /*!< BOR Reset threshold levels for 2.8V - 2.9V VDD power supply    */
N
N#define IS_OB_BOR_LEVEL(LEVEL)  (((LEVEL) == OB_BOR_OFF) || \
N                                 ((LEVEL) == OB_BOR_LEVEL1) || \
N                                 ((LEVEL) == OB_BOR_LEVEL2) || \
N                                 ((LEVEL) == OB_BOR_LEVEL3) || \
N                                 ((LEVEL) == OB_BOR_LEVEL4) || \
N                                 ((LEVEL) == OB_BOR_LEVEL5))
X#define IS_OB_BOR_LEVEL(LEVEL)  (((LEVEL) == OB_BOR_OFF) ||                                  ((LEVEL) == OB_BOR_LEVEL1) ||                                  ((LEVEL) == OB_BOR_LEVEL2) ||                                  ((LEVEL) == OB_BOR_LEVEL3) ||                                  ((LEVEL) == OB_BOR_LEVEL4) ||                                  ((LEVEL) == OB_BOR_LEVEL5))
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Flags 
N  * @{
N  */ 
N
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY        /*!< FLASH Busy flag */
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP        /*!< FLASH End of Programming flag */
N#define FLASH_FLAG_ENDHV               FLASH_SR_ENHV       /*!< FLASH End of High Voltage flag */
N#define FLASH_FLAG_READY               FLASH_SR_READY      /*!< FLASH Ready flag after low power mode */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR     /*!< FLASH Write protected error flag */
N#define FLASH_FLAG_PGAERR              FLASH_SR_PGAERR     /*!< FLASH Programming Alignment error flag */
N#define FLASH_FLAG_SIZERR              FLASH_SR_SIZERR     /*!< FLASH Size error flag  */
N#define FLASH_FLAG_OPTVERR             FLASH_SR_OPTVERR    /*!< FLASH Option Validity error flag  */
N#define FLASH_FLAG_OPTVERRUSR          FLASH_SR_OPTVERRUSR /*!< FLASH Option User Validity error flag  */
N#define FLASH_FLAG_RDERR               FLASH_SR_RDERR      /*!< FLASH Read protected error flag 
N                                                                (available only in STM32L1XX_MDP devices)  */
N    
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFC0FD) == 0x00000000) && ((FLAG) != 0x00000000))
N
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
N                                  ((FLAG) == FLASH_FLAG_ENDHV) || ((FLAG) == FLASH_FLAG_READY ) || \
N                                  ((FLAG) ==  FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR ) || \
N                                  ((FLAG) ==  FLASH_FLAG_SIZERR) || ((FLAG) == FLASH_FLAG_OPTVERR) || \
N                                  ((FLAG) ==  FLASH_FLAG_OPTVERRUSR) || ((FLAG) ==  FLASH_FLAG_RDERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) ||                                   ((FLAG) == FLASH_FLAG_ENDHV) || ((FLAG) == FLASH_FLAG_READY ) ||                                   ((FLAG) ==  FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR ) ||                                   ((FLAG) ==  FLASH_FLAG_SIZERR) || ((FLAG) == FLASH_FLAG_OPTVERR) ||                                   ((FLAG) ==  FLASH_FLAG_OPTVERRUSR) || ((FLAG) ==  FLASH_FLAG_RDERR))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys 
N  * @{
N  */ 
N
N#define FLASH_PDKEY1               ((uint32_t)0x04152637) /*!< Flash power down key1 */
N#define FLASH_PDKEY2               ((uint32_t)0xFAFBFCFD) /*!< Flash power down key2: used with FLASH_PDKEY1 
N                                                              to unlock the RUN_PD bit in FLASH_ACR */
N
N#define FLASH_PEKEY1               ((uint32_t)0x89ABCDEF) /*!< Flash program erase key1 */
N#define FLASH_PEKEY2               ((uint32_t)0x02030405) /*!< Flash program erase key: used with FLASH_PEKEY2
N                                                               to unlock the write access to the FLASH_PECR register and
N                                                               data EEPROM */
N
N#define FLASH_PRGKEY1              ((uint32_t)0x8C9DAEBF) /*!< Flash program memory key1 */
N#define FLASH_PRGKEY2              ((uint32_t)0x13141516) /*!< Flash program memory key2: used with FLASH_PRGKEY2
N                                                               to unlock the program memory */
N
N#define FLASH_OPTKEY1              ((uint32_t)0xFBEAD9C8) /*!< Flash option key1 */
N#define FLASH_OPTKEY2              ((uint32_t)0x24252627) /*!< Flash option key2: used with FLASH_OPTKEY1 to
N                                                              unlock the write access to the option byte block */
N/**
N  * @}
N  */
N  
N/** @defgroup Timeout_definition 
N  * @{
N  */ 
N#define FLASH_ER_PRG_TIMEOUT         ((uint32_t)0x8000)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup CMSIS_Legacy 
N  * @{
N  */
N#if defined ( __ICCARM__ )   
X#if 0L   
S#define InterruptType_ACTLR_DISMCYCINT_Msk         IntType_ACTLR_DISMCYCINT_Msk
N#endif
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N  
N/** 
N  * @brief  FLASH memory functions that can be executed from FLASH.  
N  */  
N/* FLASH Interface configuration functions ************************************/  
Nvoid FLASH_SetLatency(uint32_t FLASH_Latency);
Nvoid FLASH_PrefetchBufferCmd(FunctionalState NewState);
Nvoid FLASH_ReadAccess64Cmd(FunctionalState NewState);
Nvoid FLASH_SLEEPPowerDownCmd(FunctionalState NewState);
N
N/* FLASH Memory Programming functions *****************************************/   
Nvoid FLASH_Unlock(void);
Nvoid FLASH_Lock(void);
NFLASH_Status FLASH_ErasePage(uint32_t Page_Address);
NFLASH_Status FLASH_FastProgramWord(uint32_t Address, uint32_t Data);
N
N/* DATA EEPROM Programming functions ******************************************/  
Nvoid DATA_EEPROM_Unlock(void);
Nvoid DATA_EEPROM_Lock(void);
Nvoid DATA_EEPROM_FixedTimeProgramCmd(FunctionalState NewState);
NFLASH_Status DATA_EEPROM_EraseByte(uint32_t Address);
NFLASH_Status DATA_EEPROM_EraseHalfWord(uint32_t Address);
NFLASH_Status DATA_EEPROM_EraseWord(uint32_t Address);
NFLASH_Status DATA_EEPROM_FastProgramByte(uint32_t Address, uint8_t Data);
NFLASH_Status DATA_EEPROM_FastProgramHalfWord(uint32_t Address, uint16_t Data);
NFLASH_Status DATA_EEPROM_FastProgramWord(uint32_t Address, uint32_t Data);
NFLASH_Status DATA_EEPROM_ProgramByte(uint32_t Address, uint8_t Data);
NFLASH_Status DATA_EEPROM_ProgramHalfWord(uint32_t Address, uint16_t Data);
NFLASH_Status DATA_EEPROM_ProgramWord(uint32_t Address, uint32_t Data);
N
N/* Option Bytes Programming functions *****************************************/
Nvoid FLASH_OB_Unlock(void);
Nvoid FLASH_OB_Lock(void);
Nvoid FLASH_OB_Launch(void);
NFLASH_Status FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
NFLASH_Status FLASH_OB_WRP1Config(uint32_t OB_WRP1, FunctionalState NewState);
NFLASH_Status FLASH_OB_WRP2Config(uint32_t OB_WRP2, FunctionalState NewState);
NFLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP);
NFLASH_Status FLASH_OB_PCROPConfig(uint32_t OB_WRP, FunctionalState NewState);
NFLASH_Status FLASH_OB_PCROP1Config(uint32_t OB_WRP1, FunctionalState NewState);
NFLASH_Status FLASH_OB_PCROPSelectionConfig(uint16_t OB_PcROP);
NFLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
NFLASH_Status FLASH_OB_BORConfig(uint8_t OB_BOR);
NFLASH_Status FLASH_OB_BootConfig(uint8_t OB_BOOT);
Nuint8_t FLASH_OB_GetUser(void);
Nuint32_t FLASH_OB_GetWRP(void);
Nuint32_t FLASH_OB_GetWRP1(void);
Nuint32_t FLASH_OB_GetWRP2(void);
NFlagStatus FLASH_OB_GetRDP(void);
NFlagStatus FLASH_OB_GetSPRMOD(void);
Nuint8_t FLASH_OB_GetBOR(void);
N
N/* Interrupts and flags management functions **********************************/  
Nvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
NFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
Nvoid FLASH_ClearFlag(uint32_t FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
N
N/** 
N  * @brief  FLASH memory functions that should be executed from internal SRAM.
N  *         These functions are defined inside the "stm32l1xx_flash_ramfunc.c"
N  *         file.
N  */ 
N__RAM_FUNC FLASH_RUNPowerDownCmd(FunctionalState NewState);
XFLASH_Status FLASH_RUNPowerDownCmd(FunctionalState NewState);
N__RAM_FUNC FLASH_EraseParallelPage(uint32_t Page_Address1, uint32_t Page_Address2);
XFLASH_Status FLASH_EraseParallelPage(uint32_t Page_Address1, uint32_t Page_Address2);
N__RAM_FUNC FLASH_ProgramHalfPage(uint32_t Address, uint32_t* pBuffer);
XFLASH_Status FLASH_ProgramHalfPage(uint32_t Address, uint32_t* pBuffer);
N__RAM_FUNC FLASH_ProgramParallelHalfPage(uint32_t Address1, uint32_t* pBuffer1, uint32_t Address2, uint32_t* pBuffer2);
XFLASH_Status FLASH_ProgramParallelHalfPage(uint32_t Address1, uint32_t* pBuffer1, uint32_t Address2, uint32_t* pBuffer2);
N__RAM_FUNC DATA_EEPROM_EraseDoubleWord(uint32_t Address);
XFLASH_Status DATA_EEPROM_EraseDoubleWord(uint32_t Address);
N__RAM_FUNC DATA_EEPROM_ProgramDoubleWord(uint32_t Address, uint64_t Data);
XFLASH_Status DATA_EEPROM_ProgramDoubleWord(uint32_t Address, uint64_t Data);
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_FLASH_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 43 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_fsmc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_fsmc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_fsmc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the FSMC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_FSMC_H
N#define __STM32L1xx_FSMC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FSMC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  Timing parameters For NOR/SRAM Banks  
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address setup time. 
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note It is not used with synchronous NOR Flash memories. */
N
N  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the address hold time.
N                                             This parameter can be a value between 0 and 0xF. 
N                                             @note It is not used with synchronous NOR Flash memories.*/
N
N  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the data setup time.
N                                             This parameter can be a value between 0 and 0xFF.
N                                             @note It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
N                                             the duration of the bus turnaround.
N                                             This parameter can be a value between 0 and 0xF.
N                                             @note It is only used for multiplexed NOR Flash memories. */
N
N  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
N                                             This parameter can be a value between 1 and 0xF.
N                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */
N
N  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
N                                             to the memory before getting the first data.
N                                             The parameter value depends on the memory type as shown below:
N                                              - It must be set to 0 in case of a CRAM
N                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
N                                              - It may assume a value between 0 and 0xF in NOR Flash memories
N                                                with synchronous burst mode enable */
N
N  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
N                                             This parameter can be a value of @ref FSMC_Access_Mode */
N}FSMC_NORSRAMTimingInitTypeDef;
N
N/** 
N  * @brief  FSMC NOR/SRAM Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
N                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */
N
N  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
N                                          multiplexed on the databus or not. 
N                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */
N
N  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
N                                          the corresponding memory bank.
N                                          This parameter can be a value of @ref FSMC_Memory_Type */
N
N  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
N                                          This parameter can be a value of @ref FSMC_Data_Width */
N
N  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
N                                          valid only with synchronous burst Flash memories.
N                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */
N                                       
N  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
N                                          valid only with asynchronous Flash memories.
N                                          This parameter can be a value of @ref FSMC_AsynchronousWait */
N
N  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
N                                          the Flash memory in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */
N
N  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
N                                          memory, valid only when accessing Flash memories in burst mode.
N                                          This parameter can be a value of @ref FSMC_Wrap_Mode */
N
N  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
N                                          clock cycle before the wait state or during the wait state,
N                                          valid only when accessing memories in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Timing */
N
N  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
N                                          This parameter can be a value of @ref FSMC_Write_Operation */
N
N  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait-state insertion via wait
N                                          signal, valid for Flash memory access in burst mode. 
N                                          This parameter can be a value of @ref FSMC_Wait_Signal */
N
N  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
N                                          This parameter can be a value of @ref FSMC_Extended_Mode */
N
N  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
N                                          This parameter can be a value of @ref FSMC_Write_Burst */ 
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  ExtendedMode is not used*/  
N
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  ExtendedMode is used*/      
N}FSMC_NORSRAMInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FSMC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup FSMC_NORSRAM_Bank 
N  * @{
N  */
N#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)
N#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)
N#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)
N#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)
N
N#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM4))
X#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) ||                                     ((BANK) == FSMC_Bank1_NORSRAM2) ||                                     ((BANK) == FSMC_Bank1_NORSRAM3) ||                                     ((BANK) == FSMC_Bank1_NORSRAM4))
N/**
N  * @}
N  */
N
N/** @defgroup NOR_SRAM_Controller 
N  * @{
N  */
N
N/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
N  * @{
N  */
N
N#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)
N#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)
N#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
N                          ((MUX) == FSMC_DataAddressMux_Enable))
X#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) ||                           ((MUX) == FSMC_DataAddressMux_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Memory_Type 
N  * @{
N  */
N
N#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)
N#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)
N#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)
N#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
N                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
N                                ((MEMORY) == FSMC_MemoryType_NOR))
X#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) ||                                 ((MEMORY) == FSMC_MemoryType_PSRAM)||                                 ((MEMORY) == FSMC_MemoryType_NOR))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Width 
N  * @{
N  */
N
N#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)
N#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)
N#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
N                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
X#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) ||                                      ((WIDTH) == FSMC_MemoryDataWidth_16b))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Burst_Access_Mode 
N  * @{
N  */
N
N#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000) 
N#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)
N#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
N                                  ((STATE) == FSMC_BurstAccessMode_Enable))
X#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) ||                                   ((STATE) == FSMC_BurstAccessMode_Enable))
N/**
N  * @}
N  */
N  
N/** @defgroup FSMC_AsynchronousWait 
N  * @{
N  */
N#define FSMC_AsynchronousWait_Disable                   ((uint32_t)0x00000000)
N#define FSMC_AsynchronousWait_Enable                    ((uint32_t)0x00008000)
N#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
N                                 ((STATE) == FSMC_AsynchronousWait_Enable))
X#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) ||                                  ((STATE) == FSMC_AsynchronousWait_Enable))
N
N/**
N  * @}
N  */
N  
N/** @defgroup FSMC_Wait_Signal_Polarity 
N  * @{
N  */
N
N#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)
N#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)
N#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
N                                         ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
X#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) ||                                          ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wrap_Mode 
N  * @{
N  */
N
N#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)
N#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400) 
N#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
N                                 ((MODE) == FSMC_WrapMode_Enable))
X#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) ||                                  ((MODE) == FSMC_WrapMode_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Timing 
N  * @{
N  */
N
N#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)
N#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800) 
N#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
N                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
X#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) ||                                             ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Operation 
N  * @{
N  */
N
N#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
N#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
N#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
N                                            ((OPERATION) == FSMC_WriteOperation_Enable))
X#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) ||                                             ((OPERATION) == FSMC_WriteOperation_Enable))
N                              
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Wait_Signal 
N  * @{
N  */
N
N#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)
N#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000) 
N#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
N                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
X#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) ||                                       ((SIGNAL) == FSMC_WaitSignal_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Extended_Mode 
N  * @{
N  */
N
N#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)
N#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)
N
N#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
N                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
X#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) ||                                      ((MODE) == FSMC_ExtendedMode_Enable)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Write_Burst 
N  * @{
N  */
N
N#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)
N#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000) 
N#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
N                                    ((BURST) == FSMC_WriteBurst_Enable))
X#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) ||                                     ((BURST) == FSMC_WriteBurst_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Address_Hold_Time 
N  * @{
N  */
N
N#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Setup_Time 
N  * @{
N  */
N
N#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Bus_Turn_around_Duration 
N  * @{
N  */
N
N#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_CLK_Division 
N  * @{
N  */
N
N#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Data_Latency 
N  * @{
N  */
N
N#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
N
N/**
N  * @}
N  */
N
N/** @defgroup FSMC_Access_Mode 
N  * @{
N  */
N
N#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)
N#define FSMC_AccessMode_B                               ((uint32_t)0x10000000) 
N#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)
N#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)
N#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
N                                   ((MODE) == FSMC_AccessMode_B) || \
N                                   ((MODE) == FSMC_AccessMode_C) || \
N                                   ((MODE) == FSMC_AccessMode_D)) 
X#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) ||                                    ((MODE) == FSMC_AccessMode_B) ||                                    ((MODE) == FSMC_AccessMode_C) ||                                    ((MODE) == FSMC_AccessMode_D)) 
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N/* NOR/SRAM Controller functions **********************************************/
Nvoid FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
Nvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_FSMC_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 44 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_gpio.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_gpio.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the GPIO 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_GPIO_H
N#define __STM32L1xx_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC) || \
N                                    ((PERIPH) == GPIOD) || \
N                                    ((PERIPH) == GPIOE) || \
N                                    ((PERIPH) == GPIOH) || \
N                                    ((PERIPH) == GPIOF) || \
N                                    ((PERIPH) == GPIOG))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD) ||                                     ((PERIPH) == GPIOE) ||                                     ((PERIPH) == GPIOH) ||                                     ((PERIPH) == GPIOF) ||                                     ((PERIPH) == GPIOG))
N
N/** @defgroup Configuration_Mode_enumeration 
N  * @{
N  */ 
Ntypedef enum
N{ 
N  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode */
N  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode */
N  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
N  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog Mode */
N}GPIOMode_TypeDef;
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) || \
N                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) ||                             ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
N/**
N  * @}
N  */
N
N/** @defgroup Output_type_enumeration
N  * @{
N  */ 
Ntypedef enum
N{ GPIO_OType_PP = 0x00,
N  GPIO_OType_OD = 0x01
N}GPIOOType_TypeDef;
N#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))
N
N/**
N  * @}
N  */
N
N/** @defgroup Output_Maximum_frequency_enumeration 
N  * @{
N  */ 
Ntypedef enum
N{ 
N  GPIO_Speed_400KHz = 0x00, /*!< Very Low Speed */
N  GPIO_Speed_2MHz   = 0x01, /*!< Low Speed */
N  GPIO_Speed_10MHz  = 0x02, /*!< Medium Speed */
N  GPIO_Speed_40MHz  = 0x03  /*!< High Speed */
N}GPIOSpeed_TypeDef;
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_400KHz) || ((SPEED) == GPIO_Speed_2MHz) || \
N                              ((SPEED) == GPIO_Speed_10MHz)||  ((SPEED) == GPIO_Speed_40MHz))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_400KHz) || ((SPEED) == GPIO_Speed_2MHz) ||                               ((SPEED) == GPIO_Speed_10MHz)||  ((SPEED) == GPIO_Speed_40MHz))
N/**
N  * @}
N  */
N
N/** @defgroup Configuration_Pull-Up_Pull-Down_enumeration 
N  * @{
N  */ 
Ntypedef enum
N{ GPIO_PuPd_NOPULL = 0x00,
N  GPIO_PuPd_UP     = 0x01,
N  GPIO_PuPd_DOWN   = 0x02
N}GPIOPuPd_TypeDef;
N#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
N                            ((PUPD) == GPIO_PuPd_DOWN))
X#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) ||                             ((PUPD) == GPIO_PuPd_DOWN))
N/**
N  * @}
N  */
N
N/** @defgroup Bit_SET_and_Bit_RESET_enumeration
N  * @{
N  */
Ntypedef enum
N{ Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/**
N  * @}
N  */
N
N/** 
N  * @brief  GPIO Init structure definition
N  */ 
Ntypedef struct
N{
N  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
N                                       This parameter can be any value of @ref GPIO_pins_define */
N
N  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
N                                       This parameter can be a value of @ref GPIOMode_TypeDef */
N
N  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
N                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
N
N  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
N                                       This parameter can be a value of @ref GPIOOType_TypeDef */
N
N  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                                       This parameter can be a value of @ref GPIOPuPd_TypeDef */
N}GPIO_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants
N  * @{
N  */
N  
N/** @defgroup GPIO_pins_define 
N  * @{
N  */
N#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */
N#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
N#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */
N#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */
N#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */
N#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */
N#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */
N#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */
N#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */
N#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
N#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
N#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */
N#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */
N#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */
N#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */
N#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */
N#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((PIN) != (uint16_t)0x00)
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Pin_sources 
N  * @{
N  */ 
N#define GPIO_PinSource0            ((uint8_t)0x00)
N#define GPIO_PinSource1            ((uint8_t)0x01)
N#define GPIO_PinSource2            ((uint8_t)0x02)
N#define GPIO_PinSource3            ((uint8_t)0x03)
N#define GPIO_PinSource4            ((uint8_t)0x04)
N#define GPIO_PinSource5            ((uint8_t)0x05)
N#define GPIO_PinSource6            ((uint8_t)0x06)
N#define GPIO_PinSource7            ((uint8_t)0x07)
N#define GPIO_PinSource8            ((uint8_t)0x08)
N#define GPIO_PinSource9            ((uint8_t)0x09)
N#define GPIO_PinSource10           ((uint8_t)0x0A)
N#define GPIO_PinSource11           ((uint8_t)0x0B)
N#define GPIO_PinSource12           ((uint8_t)0x0C)
N#define GPIO_PinSource13           ((uint8_t)0x0D)
N#define GPIO_PinSource14           ((uint8_t)0x0E)
N#define GPIO_PinSource15           ((uint8_t)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Alternat_function_selection_define 
N  * @{
N  */
N
N/** 
N  * @brief  AF 0 selection  
N  */ 
N#define GPIO_AF_RTC_50Hz      ((uint8_t)0x00)  /*!< RTC 50/60 Hz Alternate Function mapping */
N#define GPIO_AF_MCO           ((uint8_t)0x00)  /*!< MCO Alternate Function mapping */
N#define GPIO_AF_RTC_AF1       ((uint8_t)0x00)  /*!< RTC_AF1 Alternate Function mapping */
N#define GPIO_AF_WKUP          ((uint8_t)0x00)  /*!< Wakeup (WKUP1, WKUP2 and WKUP3) Alternate Function mapping */
N#define GPIO_AF_SWJ           ((uint8_t)0x00)  /*!< SWJ (SW and JTAG) Alternate Function mapping */
N#define GPIO_AF_TRACE         ((uint8_t)0x00)  /*!< TRACE Alternate Function mapping */
N
N/** 
N  * @brief  AF 1 selection  
N  */ 
N#define GPIO_AF_TIM2          ((uint8_t)0x01)  /*!< TIM2 Alternate Function mapping */
N/** 
N  * @brief  AF 2 selection  
N  */ 
N#define GPIO_AF_TIM3          ((uint8_t)0x02)  /*!< TIM3 Alternate Function mapping */
N#define GPIO_AF_TIM4          ((uint8_t)0x02)  /*!< TIM4 Alternate Function mapping */
N#define GPIO_AF_TIM5          ((uint8_t)0x02)  /*!< TIM5 Alternate Function mapping */
N/** 
N  * @brief  AF 3 selection  
N  */ 
N#define GPIO_AF_TIM9           ((uint8_t)0x03)  /*!< TIM9 Alternate Function mapping */
N#define GPIO_AF_TIM10          ((uint8_t)0x03)  /*!< TIM10 Alternate Function mapping */
N#define GPIO_AF_TIM11          ((uint8_t)0x03)  /*!< TIM11 Alternate Function mapping */
N/** 
N  * @brief  AF 4 selection  
N  */ 
N#define GPIO_AF_I2C1          ((uint8_t)0x04)  /*!< I2C1 Alternate Function mapping */
N#define GPIO_AF_I2C2          ((uint8_t)0x04)  /*!< I2C2 Alternate Function mapping */
N/** 
N  * @brief  AF 5 selection  
N  */ 
N#define GPIO_AF_SPI1          ((uint8_t)0x05)  /*!< SPI1 Alternate Function mapping */
N#define GPIO_AF_SPI2          ((uint8_t)0x05)  /*!< SPI2 Alternate Function mapping */
N/** 
N  * @brief  AF 6 selection  
N  */ 
N#define GPIO_AF_SPI3          ((uint8_t)0x06)  /*!< SPI3 Alternate Function mapping */
N/** 
N  * @brief  AF 7 selection  
N  */ 
N#define GPIO_AF_USART1        ((uint8_t)0x07)  /*!< USART1 Alternate Function mapping */
N#define GPIO_AF_USART2        ((uint8_t)0x07)  /*!< USART2 Alternate Function mapping */
N#define GPIO_AF_USART3        ((uint8_t)0x07)  /*!< USART3 Alternate Function mapping */
N/** 
N  * @brief  AF 8 selection  
N  */ 
N#define GPIO_AF_UART4         ((uint8_t)0x08)  /*!< UART4 Alternate Function mapping */
N#define GPIO_AF_UART5         ((uint8_t)0x08)  /*!< UART5 Alternate Function mapping */
N/** 
N  * @brief  AF 10 selection  
N  */ 
N#define GPIO_AF_USB           ((uint8_t)0xA)  /*!< USB Full speed device  Alternate Function mapping */
N/** 
N  * @brief  AF 11 selection  
N  */ 
N#define GPIO_AF_LCD           ((uint8_t)0x0B)  /*!< LCD Alternate Function mapping */
N/** 
N  * @brief  AF 12 selection  
N  */ 
N#define GPIO_AF_FSMC           ((uint8_t)0x0C)  /*!< FSMC Alternate Function mapping */
N#define GPIO_AF_SDIO           ((uint8_t)0x0C)  /*!< SDIO Alternate Function mapping */
N/** 
N  * @brief  AF 14 selection  
N  */ 
N#define GPIO_AF_RI            ((uint8_t)0x0E)  /*!< RI Alternate Function mapping */
N
N/** 
N  * @brief  AF 15 selection  
N  */ 
N#define GPIO_AF_EVENTOUT      ((uint8_t)0x0F)  /*!< EVENTOUT Alternate Function mapping */
N
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz) || ((AF) == GPIO_AF_MCO)    || \
N                          ((AF) == GPIO_AF_RTC_AF1)  || ((AF) == GPIO_AF_WKUP)   || \
N                          ((AF) == GPIO_AF_SWJ)      || ((AF) == GPIO_AF_TRACE)  || \
N                          ((AF) == GPIO_AF_TIM2)     || ((AF)== GPIO_AF_TIM3)    || \
N                          ((AF) == GPIO_AF_TIM4)     || ((AF)== GPIO_AF_TIM9)    || \
N                          ((AF) == GPIO_AF_TIM10)    || ((AF)== GPIO_AF_TIM11)   || \
N                          ((AF) == GPIO_AF_I2C1)     || ((AF) == GPIO_AF_I2C2)   || \
N                          ((AF) == GPIO_AF_SPI1)     || ((AF) == GPIO_AF_SPI2)   || \
N                          ((AF) == GPIO_AF_USART1)   || ((AF) == GPIO_AF_USART2) || \
N                          ((AF) == GPIO_AF_USART3)   || ((AF) == GPIO_AF_USB)    || \
N                          ((AF) == GPIO_AF_LCD)      || ((AF) == GPIO_AF_RI)     || \
N                          ((AF) == GPIO_AF_TIM5)     || ((AF) == GPIO_AF_SPI3)   || \
N                          ((AF) == GPIO_AF_UART4)    || ((AF) == GPIO_AF_UART5)  || \
N                          ((AF) == GPIO_AF_FSMC)     || ((AF) == GPIO_AF_SDIO)   || \
N                          ((AF) == GPIO_AF_EVENTOUT))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz) || ((AF) == GPIO_AF_MCO)    ||                           ((AF) == GPIO_AF_RTC_AF1)  || ((AF) == GPIO_AF_WKUP)   ||                           ((AF) == GPIO_AF_SWJ)      || ((AF) == GPIO_AF_TRACE)  ||                           ((AF) == GPIO_AF_TIM2)     || ((AF)== GPIO_AF_TIM3)    ||                           ((AF) == GPIO_AF_TIM4)     || ((AF)== GPIO_AF_TIM9)    ||                           ((AF) == GPIO_AF_TIM10)    || ((AF)== GPIO_AF_TIM11)   ||                           ((AF) == GPIO_AF_I2C1)     || ((AF) == GPIO_AF_I2C2)   ||                           ((AF) == GPIO_AF_SPI1)     || ((AF) == GPIO_AF_SPI2)   ||                           ((AF) == GPIO_AF_USART1)   || ((AF) == GPIO_AF_USART2) ||                           ((AF) == GPIO_AF_USART3)   || ((AF) == GPIO_AF_USB)    ||                           ((AF) == GPIO_AF_LCD)      || ((AF) == GPIO_AF_RI)     ||                           ((AF) == GPIO_AF_TIM5)     || ((AF) == GPIO_AF_SPI3)   ||                           ((AF) == GPIO_AF_UART4)    || ((AF) == GPIO_AF_UART5)  ||                           ((AF) == GPIO_AF_FSMC)     || ((AF) == GPIO_AF_SDIO)   ||                           ((AF) == GPIO_AF_EVENTOUT))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Legacy 
N  * @{
N  */
N    
N#define GPIO_Mode_AIN GPIO_Mode_AN
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */  
N  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the GPIO configuration to the default reset state ****/
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Read and Write functions **********************************************/
Nuint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nuint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
Nvoid GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Alternate functions configuration functions ***************************/
Nvoid GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_GPIO_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 45 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_i2c.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_i2c.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the I2C firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_I2C_H
N#define __STM32L1xx_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  I2C Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
N                                         This parameter must be set to a value lower than 400kHz */
N
N  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
N                                         This parameter can be a value of @ref I2C_mode */
N
N  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
N                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */
N
N  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
N                                         This parameter can be a 7-bit or 10-bit address. */
N
N  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
N                                         This parameter can be a value of @ref I2C_acknowledgement */
N
N  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
N                                         This parameter can be a value of @ref I2C_acknowledged_address */
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N
N/** @defgroup I2C_Exported_Constants
N  * @{
N  */
N
N#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
N                                   ((PERIPH) == I2C2))
X#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) ||                                    ((PERIPH) == I2C2))
N/** @defgroup I2C_mode 
N  * @{
N  */
N
N#define I2C_Mode_I2C                    ((uint16_t)0x0000)
N#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
N#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
N#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
N                           ((MODE) == I2C_Mode_SMBusDevice) || \
N                           ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) ||                            ((MODE) == I2C_Mode_SMBusDevice) ||                            ((MODE) == I2C_Mode_SMBusHost))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_duty_cycle_in_fast_mode 
N  * @{
N  */
N
N#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
N#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
N                                  ((CYCLE) == I2C_DutyCycle_2))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) ||                                   ((CYCLE) == I2C_DutyCycle_2))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_acknowledgement
N  * @{
N  */
N
N#define I2C_Ack_Enable                  ((uint16_t)0x0400)
N#define I2C_Ack_Disable                 ((uint16_t)0x0000)
N#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
N                                 ((STATE) == I2C_Ack_Disable))
X#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) ||                                  ((STATE) == I2C_Ack_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_transfer_direction 
N  * @{
N  */
N
N#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
N#define  I2C_Direction_Receiver         ((uint8_t)0x01)
N#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                     ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) ||                                      ((DIRECTION) == I2C_Direction_Receiver))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledged_address 
N  * @{
N  */
N
N#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
N#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_registers 
N  * @{
N  */
N
N#define I2C_Register_CR1                ((uint8_t)0x00)
N#define I2C_Register_CR2                ((uint8_t)0x04)
N#define I2C_Register_OAR1               ((uint8_t)0x08)
N#define I2C_Register_OAR2               ((uint8_t)0x0C)
N#define I2C_Register_DR                 ((uint8_t)0x10)
N#define I2C_Register_SR1                ((uint8_t)0x14)
N#define I2C_Register_SR2                ((uint8_t)0x18)
N#define I2C_Register_CCR                ((uint8_t)0x1C)
N#define I2C_Register_TRISE              ((uint8_t)0x20)
N#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
N                                   ((REGISTER) == I2C_Register_CR2) || \
N                                   ((REGISTER) == I2C_Register_OAR1) || \
N                                   ((REGISTER) == I2C_Register_OAR2) || \
N                                   ((REGISTER) == I2C_Register_DR) || \
N                                   ((REGISTER) == I2C_Register_SR1) || \
N                                   ((REGISTER) == I2C_Register_SR2) || \
N                                   ((REGISTER) == I2C_Register_CCR) || \
N                                   ((REGISTER) == I2C_Register_TRISE))
X#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) ||                                    ((REGISTER) == I2C_Register_CR2) ||                                    ((REGISTER) == I2C_Register_OAR1) ||                                    ((REGISTER) == I2C_Register_OAR2) ||                                    ((REGISTER) == I2C_Register_DR) ||                                    ((REGISTER) == I2C_Register_SR1) ||                                    ((REGISTER) == I2C_Register_SR2) ||                                    ((REGISTER) == I2C_Register_CCR) ||                                    ((REGISTER) == I2C_Register_TRISE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_SMBus_alert_pin_level 
N  * @{
N  */
N
N#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
N#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
N#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
N                                   ((ALERT) == I2C_SMBusAlert_High))
X#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) ||                                    ((ALERT) == I2C_SMBusAlert_High))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_PEC_position 
N  * @{
N  */
N
N#define I2C_PECPosition_Next            ((uint16_t)0x0800)
N#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
N#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
N                                       ((POSITION) == I2C_PECPosition_Current))
X#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) ||                                        ((POSITION) == I2C_PECPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_NACK_position 
N  * @{
N  */
N
N#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
N#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
N#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
N                                         ((POSITION) == I2C_NACKPosition_Current))
X#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) ||                                          ((POSITION) == I2C_NACKPosition_Current))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_BUF                      ((uint16_t)0x0400)
N#define I2C_IT_EVT                      ((uint16_t)0x0200)
N#define I2C_IT_ERR                      ((uint16_t)0x0100)
N#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
N#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
N#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
N#define I2C_IT_OVR                      ((uint32_t)0x01000800)
N#define I2C_IT_AF                       ((uint32_t)0x01000400)
N#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
N#define I2C_IT_BERR                     ((uint32_t)0x01000100)
N#define I2C_IT_TXE                      ((uint32_t)0x06000080)
N#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
N#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
N#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
N#define I2C_IT_BTF                      ((uint32_t)0x02000004)
N#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
N#define I2C_IT_SB                       ((uint32_t)0x02000001)
N
N#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))
N
N#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
N                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
N                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                            ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) ||                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) ||                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_flags_definition 
N  * @{
N  */
N
N/** 
N  * @brief  SR2 register flags  
N  */
N
N#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
N#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
N#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
N#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
N#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
N#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
N#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)
N
N/** 
N  * @brief  SR1 register flags  
N  */
N
N#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
N#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
N#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
N#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
N#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
N#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
N#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
N#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
N#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
N#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
N#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
N#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
N#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
N#define I2C_FLAG_SB                     ((uint32_t)0x10000001)
N
N#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))
N
N#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
N                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
N                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
N                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
N                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
N                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
N                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
N                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
N                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
N                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
N                               ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) ||                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) ||                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) ||                                ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) ||                                ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) ||                                ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) ||                                ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) ||                                ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) ||                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) ||                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) ||                                ((FLAG) == I2C_FLAG_SB))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Events 
N  * @{
N  */
N
N/**
N ===============================================================================
N               I2C Master Events (Events grouped in order of communication)
N ===============================================================================
N */
N
N/** 
N  * @brief  Communication start
N  * 
N  * After sending the START condition (I2C_GenerateSTART() function) the master 
N  * has to wait for this event. It means that the Start condition has been correctly 
N  * released on the I2C bus (the bus is free, no other devices is communicating).
N  * 
N  */
N/* --EV5 */
N#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */
N
N/** 
N  * @brief  Address Acknowledge
N  * 
N  * After checking on EV5 (start condition correctly released on the bus), the 
N  * master sends the address of the slave(s) with which it will communicate 
N  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
N  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
N  * his address. If an acknowledge is sent on the bus, one of the following events will 
N  * be set:
N  * 
N  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
N  *     event is set.
N  *  
N  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
N  *     is set
N  *  
N  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
N  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
N  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
N  *  header has been correctly sent on the bus. Then master should send the second part of 
N  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
N  *  should wait for event EV6. 
N  *     
N  */
N
N/* --EV6 */
N#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
N#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
N/* --EV9 */
N#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */
N
N/** 
N  * @brief Communication events
N  * 
N  * If a communication is established (START condition generated and slave address 
N  * acknowledged) then the master has to check on one of the following events for 
N  * communication procedures:
N  *  
N  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
N  *    the data received from the slave (I2C_ReceiveData() function).
N  * 
N  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
N  *    function) then to wait on event EV8 or EV8_2.
N  *    These two events are similar: 
N  *     - EV8 means that the data has been written in the data register and is 
N  *       being shifted out.
N  *     - EV8_2 means that the data has been physically shifted out and output 
N  *       on the bus.
N  *     In most cases, using EV8 is sufficient for the application.
N  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
N  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
N  *     (before Stop condition generation).
N  *     
N  *  @note In case the  user software does not guarantee that this event EV7 is 
N  *  managed before the current byte end of transfer, then user may check on EV7 
N  *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  *  In this case the communication may be slower.
N  * 
N  */
N
N/* Master RECEIVER mode -----------------------------*/ 
N/* --EV7 */
N#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */
N
N/* Master TRANSMITTER mode --------------------------*/
N/* --EV8 */
N#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
N/* --EV8_2 */
N#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
N
N
N/**
N ===============================================================================
N               I2C Slave Events (Events grouped in order of communication)
N ===============================================================================
N */
N
N
N/** 
N  * @brief  Communication start events
N  * 
N  * Wait on one of these events at the start of the communication. It means that 
N  * the I2C peripheral detected a Start condition on the bus (generated by master 
N  * device) followed by the peripheral address. The peripheral generates an ACK 
N  * condition on the bus (if the acknowledge feature is enabled through function 
N  * I2C_AcknowledgeConfig()) and the events listed above are set :
N  *  
N  * 1) In normal case (only one address managed by the slave), when the address 
N  *   sent by the master matches the own address of the peripheral (configured by 
N  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
N  *   (where XXX could be TRANSMITTER or RECEIVER).
N  *    
N  * 2) In case the address sent by the master matches the second address of the 
N  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
N  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
N  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
N  *   
N  * 3) In case the address sent by the master is General Call (address 0x00) and 
N  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
N  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
N  * 
N  */
N
N/* --EV1  (all the events below are variants of EV1) */   
N/* 1) Case of One Single Address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
N
N/* 2) Case of Dual address managed by the slave */
N#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
N
N/* 3) Case of General Call enabled for the slave */
N#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */
N
N/** 
N  * @brief  Communication events
N  * 
N  * Wait on one of these events when EV1 has already been checked and: 
N  * 
N  * - Slave RECEIVER mode:
N  *     - EV2: When the application is expecting a data byte to be received. 
N  *     - EV4: When the application is expecting the end of the communication: master 
N  *       sends a stop condition and data transmission is stopped.
N  *    
N  * - Slave Transmitter mode:
N  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
N  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
N  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
N  *      used when the user software doesn't guarantee the EV3 is managed before the
N  *      current byte end of transfer.
N  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
N  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
N  *      data bytes and expect a Stop condition on the bus.
N  *      
N  *  @note In case the  user software does not guarantee that the event EV2 is 
N  *  managed before the current byte end of transfer, then user may check on EV2 
N  *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
N  *  In this case the communication may be slower.
N  *
N  */
N
N/* Slave RECEIVER mode --------------------------*/ 
N/* --EV2 */
N#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
N/* --EV4  */
N#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */
N
N/* Slave TRANSMITTER mode -----------------------*/
N/* --EV3 */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
N/* --EV3_2 */
N#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */
N
N/*
N ===============================================================================
N                          End of Events Description
N ===============================================================================
N */
N
N#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
N                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
X#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) ||                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) ||                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_own_address1 
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_clock_speed 
N  * @{
N  */
N
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the I2C configuration to the default reset state *****/
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
Nvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
Nvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
N
N/* Data transfers functions ***************************************************/ 
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
Nuint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
Nvoid I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
N
N/* PEC management functions ***************************************************/ 
Nvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
N
N/* DMA transfers management functions *****************************************/
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
N
N
N/* Interrupts, events and flags management functions **************************/
Nuint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);
N
N/*
N
N ===============================================================================
N                          I2C State Monitoring Functions
N ===============================================================================
N  This I2C driver provides three different ways for I2C state monitoring
N  depending on the application requirements and constraints:
N         
N   
N     1. Basic state monitoring (Using I2C_CheckEvent() function)
N     -----------------------------------------------------------
N        It compares the status registers (SR1 and SR2) content to a given event
N        (can be the combination of one or more flags).
N        It returns SUCCESS if the current status includes the given flags 
N        and returns ERROR if one or more flags are missing in the current status.
N
N          - When to use
N             - This function is suitable for most applications as well as for startup 
N               activity since the events are fully described in the product reference 
N               manual (RM0038).
N             - It is also suitable for users who need to define their own events.
N
N          - Limitations
N             - If an error occurs (ie. error flags are set besides to the monitored 
N               flags), the I2C_CheckEvent() function may return SUCCESS despite 
N               the communication hold or corrupted real state. 
N               In this case, it is advised to use error interrupts to monitor 
N               the error events and handle them in the interrupt IRQ handler.
N         
N     Note
N         For error management, it is advised to use the following functions:
N           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
N           - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
N             Where x is the peripheral instance (I2C1, I2C2 ...)
N           - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
N             I2Cx_ER_IRQHandler() function in order to determine which error occurred.
N           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
N             and/or I2C_GenerateStop() in order to clear the error flag and source 
N             and return to correct  communciation status.
N             
N 
N     2. Advanced state monitoring (Using the function I2C_GetLastEvent())
N     -------------------------------------------------------------------- 
N        Using the function I2C_GetLastEvent() which returns the image of both status 
N        registers in a single word (uint32_t) (Status Register 2 value is shifted left 
N        by 16 bits and concatenated to Status Register 1).
N
N          - When to use
N             - This function is suitable for the same applications above but it 
N               allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
N               function.
N             - The returned value could be compared to events already defined in 
N               the library (stm32l1xx_i2c.h) or to custom values defined by user.
N               This function is suitable when multiple flags are monitored at the 
N               same time.
N             - At the opposite of I2C_CheckEvent() function, this function allows 
N               user to choose when an event is accepted (when all events flags are 
N               set and no other flags are set or just when the needed flags are set 
N               like I2C_CheckEvent() function.
N
N          - Limitations
N             - User may need to define his own events.
N             - Same remark concerning the error management is applicable for this 
N               function if user decides to check only regular communication flags 
N               (and ignores error flags).
N      
N 
N     3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
N     -----------------------------------------------------------------------
N     
N      Using the function I2C_GetFlagStatus() which simply returns the status of 
N      one single flag (ie. I2C_FLAG_RXNE ...). 
N
N          - When to use
N             - This function could be used for specific applications or in debug 
N               phase.
N             - It is suitable when only one flag checking is needed (most I2C 
N               events are monitored through multiple flags).
N          - Limitations: 
N             - When calling this function, the Status register is accessed. 
N               Some flags are cleared when the status register is accessed. 
N               So checking the status of one Flag, may clear other ones.
N             - Function may need to be called twice or more in order to monitor 
N               one single event.
N
N   For detailed description of Events, please refer to section I2C_Events in 
N   stm32l1xx_i2c.h file.
N
N*/
N
N/*
N ===============================================================================
N                          1. Basic state monitoring
N ===============================================================================
N */
NErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
N/*
N ===============================================================================
N                          2. Advanced state monitoring
N ===============================================================================
N */
Nuint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
N/*
N ===============================================================================
N                          3. Flag-based state monitoring
N ===============================================================================
N */
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
N
N
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_I2C_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_iwdg.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_iwdg.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the IWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_IWDG_H
N#define __STM32L1xx_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup IWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup IWDG_Exported_Constants
N  * @{
N  */
N
N/** @defgroup IWDG_WriteAccess
N  * @{
N  */
N
N#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
N#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_prescaler 
N  * @{
N  */
N
N#define IWDG_Prescaler_4            ((uint8_t)0x00)
N#define IWDG_Prescaler_8            ((uint8_t)0x01)
N#define IWDG_Prescaler_16           ((uint8_t)0x02)
N#define IWDG_Prescaler_32           ((uint8_t)0x03)
N#define IWDG_Prescaler_64           ((uint8_t)0x04)
N#define IWDG_Prescaler_128          ((uint8_t)0x05)
N#define IWDG_Prescaler_256          ((uint8_t)0x06)
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Flag 
N  * @{
N  */
N
N#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
N#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Prescaler and Counter configuration functions ******************************/
Nvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
Nvoid IWDG_SetReload(uint16_t Reload);
Nvoid IWDG_ReloadCounter(void);
N
N/* IWDG activation function ***************************************************/
Nvoid IWDG_Enable(void);
N
N/* Flag management function ***************************************************/
NFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_IWDG_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_lcd.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_lcd.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_lcd.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the LCD firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_LCD_H
N#define __STM32L1xx_LCD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup LCD
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N 
N/** 
N  * @brief  LCD Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t LCD_Prescaler;     /*!< Configures the LCD Prescaler. 
N                                   This parameter can be one value of @ref LCD_Prescaler */
N  uint32_t LCD_Divider;       /*!< Configures the LCD Divider.
N                                  This parameter can be one value of @ref LCD_Divider */
N  uint32_t LCD_Duty;          /*!< Configures the LCD Duty.
N                                  This parameter can be one value of @ref LCD_Duty */
N  uint32_t LCD_Bias;          /*!< Configures the LCD Bias.
N                                  This parameter can be one value of @ref LCD_Bias */ 
N  uint32_t LCD_VoltageSource; /*!< Selects the LCD Voltage source.
N                                  This parameter can be one value of @ref LCD_Voltage_Source */
N}LCD_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup LCD_Exported_Constants
N  * @{
N  */
N
N/** @defgroup LCD_Prescaler 
N  * @{
N  */
N
N#define LCD_Prescaler_1        ((uint32_t)0x00000000)  /*!< CLKPS = LCDCLK        */
N#define LCD_Prescaler_2        ((uint32_t)0x00400000)  /*!< CLKPS = LCDCLK/2      */
N#define LCD_Prescaler_4        ((uint32_t)0x00800000)  /*!< CLKPS = LCDCLK/4      */
N#define LCD_Prescaler_8        ((uint32_t)0x00C00000)  /*!< CLKPS = LCDCLK/8      */
N#define LCD_Prescaler_16       ((uint32_t)0x01000000)  /*!< CLKPS = LCDCLK/16     */
N#define LCD_Prescaler_32       ((uint32_t)0x01400000)  /*!< CLKPS = LCDCLK/32     */
N#define LCD_Prescaler_64       ((uint32_t)0x01800000)  /*!< CLKPS = LCDCLK/64     */
N#define LCD_Prescaler_128      ((uint32_t)0x01C00000)  /*!< CLKPS = LCDCLK/128    */
N#define LCD_Prescaler_256      ((uint32_t)0x02000000)  /*!< CLKPS = LCDCLK/256    */
N#define LCD_Prescaler_512      ((uint32_t)0x02400000)  /*!< CLKPS = LCDCLK/512    */
N#define LCD_Prescaler_1024     ((uint32_t)0x02800000)  /*!< CLKPS = LCDCLK/1024   */
N#define LCD_Prescaler_2048     ((uint32_t)0x02C00000)  /*!< CLKPS = LCDCLK/2048   */
N#define LCD_Prescaler_4096     ((uint32_t)0x03000000)  /*!< CLKPS = LCDCLK/4096   */
N#define LCD_Prescaler_8192     ((uint32_t)0x03400000)  /*!< CLKPS = LCDCLK/8192   */
N#define LCD_Prescaler_16384    ((uint32_t)0x03800000)  /*!< CLKPS = LCDCLK/16384  */
N#define LCD_Prescaler_32768    ((uint32_t)0x03C00000)  /*!< CLKPS = LCDCLK/32768  */
N
N#define IS_LCD_PRESCALER(PRESCALER)    (((PRESCALER) == LCD_Prescaler_1) || \
N                                        ((PRESCALER) == LCD_Prescaler_2) || \
N                                        ((PRESCALER) == LCD_Prescaler_4) || \
N                                        ((PRESCALER) == LCD_Prescaler_8) || \
N                                        ((PRESCALER) == LCD_Prescaler_16) || \
N                                        ((PRESCALER) == LCD_Prescaler_32) || \
N                                        ((PRESCALER) == LCD_Prescaler_64) || \
N                                        ((PRESCALER) == LCD_Prescaler_128) || \
N                                        ((PRESCALER) == LCD_Prescaler_256) || \
N                                        ((PRESCALER) == LCD_Prescaler_512) || \
N                                        ((PRESCALER) == LCD_Prescaler_1024) || \
N                                        ((PRESCALER) == LCD_Prescaler_2048) || \
N                                        ((PRESCALER) == LCD_Prescaler_4096) || \
N                                        ((PRESCALER) == LCD_Prescaler_8192) || \
N                                        ((PRESCALER) == LCD_Prescaler_16384) || \
N                                        ((PRESCALER) == LCD_Prescaler_32768))
X#define IS_LCD_PRESCALER(PRESCALER)    (((PRESCALER) == LCD_Prescaler_1) ||                                         ((PRESCALER) == LCD_Prescaler_2) ||                                         ((PRESCALER) == LCD_Prescaler_4) ||                                         ((PRESCALER) == LCD_Prescaler_8) ||                                         ((PRESCALER) == LCD_Prescaler_16) ||                                         ((PRESCALER) == LCD_Prescaler_32) ||                                         ((PRESCALER) == LCD_Prescaler_64) ||                                         ((PRESCALER) == LCD_Prescaler_128) ||                                         ((PRESCALER) == LCD_Prescaler_256) ||                                         ((PRESCALER) == LCD_Prescaler_512) ||                                         ((PRESCALER) == LCD_Prescaler_1024) ||                                         ((PRESCALER) == LCD_Prescaler_2048) ||                                         ((PRESCALER) == LCD_Prescaler_4096) ||                                         ((PRESCALER) == LCD_Prescaler_8192) ||                                         ((PRESCALER) == LCD_Prescaler_16384) ||                                         ((PRESCALER) == LCD_Prescaler_32768))
N
N/**
N  * @}
N  */
N  
N/** @defgroup LCD_Divider 
N  * @{
N  */
N
N#define LCD_Divider_16    ((uint32_t)0x00000000)  /*!< LCD frequency = CLKPS/16 */
N#define LCD_Divider_17    ((uint32_t)0x00040000)  /*!< LCD frequency = CLKPS/17 */
N#define LCD_Divider_18    ((uint32_t)0x00080000)  /*!< LCD frequency = CLKPS/18 */
N#define LCD_Divider_19    ((uint32_t)0x000C0000)  /*!< LCD frequency = CLKPS/19 */
N#define LCD_Divider_20    ((uint32_t)0x00100000)  /*!< LCD frequency = CLKPS/20 */
N#define LCD_Divider_21    ((uint32_t)0x00140000)  /*!< LCD frequency = CLKPS/21 */
N#define LCD_Divider_22    ((uint32_t)0x00180000)  /*!< LCD frequency = CLKPS/22 */
N#define LCD_Divider_23    ((uint32_t)0x001C0000)  /*!< LCD frequency = CLKPS/23 */
N#define LCD_Divider_24    ((uint32_t)0x00200000)  /*!< LCD frequency = CLKPS/24 */
N#define LCD_Divider_25    ((uint32_t)0x00240000)  /*!< LCD frequency = CLKPS/25 */
N#define LCD_Divider_26    ((uint32_t)0x00280000)  /*!< LCD frequency = CLKPS/26 */
N#define LCD_Divider_27    ((uint32_t)0x002C0000)  /*!< LCD frequency = CLKPS/27 */
N#define LCD_Divider_28    ((uint32_t)0x00300000)  /*!< LCD frequency = CLKPS/28 */
N#define LCD_Divider_29    ((uint32_t)0x00340000)  /*!< LCD frequency = CLKPS/29 */
N#define LCD_Divider_30    ((uint32_t)0x00380000)  /*!< LCD frequency = CLKPS/30 */
N#define LCD_Divider_31    ((uint32_t)0x003C0000)  /*!< LCD frequency = CLKPS/31 */
N
N#define IS_LCD_DIVIDER(DIVIDER)    (((DIVIDER) == LCD_Divider_16) || \
N                                    ((DIVIDER) == LCD_Divider_17) || \
N                                    ((DIVIDER) == LCD_Divider_18) || \
N                                    ((DIVIDER) == LCD_Divider_19) || \
N                                    ((DIVIDER) == LCD_Divider_20) || \
N                                    ((DIVIDER) == LCD_Divider_21) || \
N                                    ((DIVIDER) == LCD_Divider_22) || \
N                                    ((DIVIDER) == LCD_Divider_23) || \
N                                    ((DIVIDER) == LCD_Divider_24) || \
N                                    ((DIVIDER) == LCD_Divider_25) || \
N                                    ((DIVIDER) == LCD_Divider_26) || \
N                                    ((DIVIDER) == LCD_Divider_27) || \
N                                    ((DIVIDER) == LCD_Divider_28) || \
N                                    ((DIVIDER) == LCD_Divider_29) || \
N                                    ((DIVIDER) == LCD_Divider_30) || \
N                                    ((DIVIDER) == LCD_Divider_31))
X#define IS_LCD_DIVIDER(DIVIDER)    (((DIVIDER) == LCD_Divider_16) ||                                     ((DIVIDER) == LCD_Divider_17) ||                                     ((DIVIDER) == LCD_Divider_18) ||                                     ((DIVIDER) == LCD_Divider_19) ||                                     ((DIVIDER) == LCD_Divider_20) ||                                     ((DIVIDER) == LCD_Divider_21) ||                                     ((DIVIDER) == LCD_Divider_22) ||                                     ((DIVIDER) == LCD_Divider_23) ||                                     ((DIVIDER) == LCD_Divider_24) ||                                     ((DIVIDER) == LCD_Divider_25) ||                                     ((DIVIDER) == LCD_Divider_26) ||                                     ((DIVIDER) == LCD_Divider_27) ||                                     ((DIVIDER) == LCD_Divider_28) ||                                     ((DIVIDER) == LCD_Divider_29) ||                                     ((DIVIDER) == LCD_Divider_30) ||                                     ((DIVIDER) == LCD_Divider_31))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup LCD_Duty 
N  * @{
N  */
N  
N#define LCD_Duty_Static                 ((uint32_t)0x00000000) /*!< Static duty */
N#define LCD_Duty_1_2                    ((uint32_t)0x00000004) /*!< 1/2 duty    */
N#define LCD_Duty_1_3                    ((uint32_t)0x00000008) /*!< 1/3 duty    */
N#define LCD_Duty_1_4                    ((uint32_t)0x0000000C) /*!< 1/4 duty    */
N#define LCD_Duty_1_8                    ((uint32_t)0x00000010) /*!< 1/4 duty    */
N
N#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_Static) || \
N                           ((DUTY) == LCD_Duty_1_2) || \
N                           ((DUTY) == LCD_Duty_1_3) || \
N                           ((DUTY) == LCD_Duty_1_4) || \
N                           ((DUTY) == LCD_Duty_1_8))
X#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_Static) ||                            ((DUTY) == LCD_Duty_1_2) ||                            ((DUTY) == LCD_Duty_1_3) ||                            ((DUTY) == LCD_Duty_1_4) ||                            ((DUTY) == LCD_Duty_1_8))
N
N/**
N  * @}
N  */ 
N  
N
N/** @defgroup LCD_Bias 
N  * @{
N  */
N  
N#define LCD_Bias_1_4                    ((uint32_t)0x00000000)  /*!< 1/4 Bias */
N#define LCD_Bias_1_2                    LCD_CR_BIAS_0           /*!< 1/2 Bias */
N#define LCD_Bias_1_3                    LCD_CR_BIAS_1           /*!< 1/3 Bias */
N
N#define IS_LCD_BIAS(BIAS) (((BIAS) == LCD_Bias_1_4) || \
N                           ((BIAS) == LCD_Bias_1_2) || \
N                           ((BIAS) == LCD_Bias_1_3))
X#define IS_LCD_BIAS(BIAS) (((BIAS) == LCD_Bias_1_4) ||                            ((BIAS) == LCD_Bias_1_2) ||                            ((BIAS) == LCD_Bias_1_3))
N/**
N  * @}
N  */ 
N    
N/** @defgroup LCD_Voltage_Source 
N  * @{
N  */
N  
N#define LCD_VoltageSource_Internal      ((uint32_t)0x00000000)  /*!< Internal voltage source for the LCD */
N#define LCD_VoltageSource_External      LCD_CR_VSEL             /*!< External voltage source for the LCD */
N
N#define IS_LCD_VOLTAGE_SOURCE(SOURCE) (((SOURCE) == LCD_VoltageSource_Internal) || \
N                                       ((SOURCE) == LCD_VoltageSource_External))
X#define IS_LCD_VOLTAGE_SOURCE(SOURCE) (((SOURCE) == LCD_VoltageSource_Internal) ||                                        ((SOURCE) == LCD_VoltageSource_External))
N                           
N/**
N  * @}
N  */  
N
N/** @defgroup LCD_Interrupts 
N  * @{
N  */
N#define LCD_IT_SOF                      LCD_FCR_SOFIE
N#define LCD_IT_UDD                      LCD_FCR_UDDIE
N
N#define IS_LCD_IT(IT) ((((IT) & (uint32_t)0xFFFFFFF5) == 0x00) && ((IT) != 0x00))
N
N#define IS_LCD_GET_IT(IT) (((IT) == LCD_IT_SOF) || ((IT) == LCD_IT_UDD))
N 
N/**
N  * @}
N  */
N
N/** @defgroup LCD_PulseOnDuration 
N  * @{
N  */
N
N#define LCD_PulseOnDuration_0           ((uint32_t)0x00000000) /*!< Pulse ON duration = 0 pulse   */
N#define LCD_PulseOnDuration_1           ((uint32_t)0x00000010) /*!< Pulse ON duration = 1/CK_PS  */
N#define LCD_PulseOnDuration_2           ((uint32_t)0x00000020) /*!< Pulse ON duration = 2/CK_PS  */
N#define LCD_PulseOnDuration_3           ((uint32_t)0x00000030) /*!< Pulse ON duration = 3/CK_PS  */
N#define LCD_PulseOnDuration_4           ((uint32_t)0x00000040) /*!< Pulse ON duration = 4/CK_PS  */
N#define LCD_PulseOnDuration_5           ((uint32_t)0x00000050) /*!< Pulse ON duration = 5/CK_PS  */
N#define LCD_PulseOnDuration_6           ((uint32_t)0x00000060) /*!< Pulse ON duration = 6/CK_PS  */
N#define LCD_PulseOnDuration_7           ((uint32_t)0x00000070) /*!< Pulse ON duration = 7/CK_PS  */
N
N#define IS_LCD_PULSE_ON_DURATION(DURATION) (((DURATION) == LCD_PulseOnDuration_0) || \
N                                            ((DURATION) == LCD_PulseOnDuration_1) || \
N                                            ((DURATION) == LCD_PulseOnDuration_2) || \
N                                            ((DURATION) == LCD_PulseOnDuration_3) || \
N                                            ((DURATION) == LCD_PulseOnDuration_4) || \
N                                            ((DURATION) == LCD_PulseOnDuration_5) || \
N                                            ((DURATION) == LCD_PulseOnDuration_6) || \
N                                            ((DURATION) == LCD_PulseOnDuration_7))
X#define IS_LCD_PULSE_ON_DURATION(DURATION) (((DURATION) == LCD_PulseOnDuration_0) ||                                             ((DURATION) == LCD_PulseOnDuration_1) ||                                             ((DURATION) == LCD_PulseOnDuration_2) ||                                             ((DURATION) == LCD_PulseOnDuration_3) ||                                             ((DURATION) == LCD_PulseOnDuration_4) ||                                             ((DURATION) == LCD_PulseOnDuration_5) ||                                             ((DURATION) == LCD_PulseOnDuration_6) ||                                             ((DURATION) == LCD_PulseOnDuration_7))
N/**
N  * @}
N  */
N
N
N/** @defgroup LCD_DeadTime 
N  * @{
N  */
N
N#define LCD_DeadTime_0                  ((uint32_t)0x00000000) /*!< No dead Time  */
N#define LCD_DeadTime_1                  ((uint32_t)0x00000080) /*!< One Phase between different couple of Frame   */
N#define LCD_DeadTime_2                  ((uint32_t)0x00000100) /*!< Two Phase between different couple of Frame   */
N#define LCD_DeadTime_3                  ((uint32_t)0x00000180) /*!< Three Phase between different couple of Frame */
N#define LCD_DeadTime_4                  ((uint32_t)0x00000200) /*!< Four Phase between different couple of Frame  */
N#define LCD_DeadTime_5                  ((uint32_t)0x00000280) /*!< Five Phase between different couple of Frame  */
N#define LCD_DeadTime_6                  ((uint32_t)0x00000300) /*!< Six Phase between different couple of Frame   */
N#define LCD_DeadTime_7                  ((uint32_t)0x00000380) /*!< Seven Phase between different couple of Frame */
N
N#define IS_LCD_DEAD_TIME(TIME) (((TIME) == LCD_DeadTime_0) || \
N                                ((TIME) == LCD_DeadTime_1) || \
N                                ((TIME) == LCD_DeadTime_2) || \
N                                ((TIME) == LCD_DeadTime_3) || \
N                                ((TIME) == LCD_DeadTime_4) || \
N                                ((TIME) == LCD_DeadTime_5) || \
N                                ((TIME) == LCD_DeadTime_6) || \
N                                ((TIME) == LCD_DeadTime_7))
X#define IS_LCD_DEAD_TIME(TIME) (((TIME) == LCD_DeadTime_0) ||                                 ((TIME) == LCD_DeadTime_1) ||                                 ((TIME) == LCD_DeadTime_2) ||                                 ((TIME) == LCD_DeadTime_3) ||                                 ((TIME) == LCD_DeadTime_4) ||                                 ((TIME) == LCD_DeadTime_5) ||                                 ((TIME) == LCD_DeadTime_6) ||                                 ((TIME) == LCD_DeadTime_7))
N/**
N  * @}
N  */
N
N/** @defgroup LCD_BlinkMode 
N  * @{
N  */
N
N#define LCD_BlinkMode_Off               ((uint32_t)0x00000000) /*!< Blink disabled            */
N#define LCD_BlinkMode_SEG0_COM0         ((uint32_t)0x00010000) /*!< Blink enabled on SEG[0], COM[0] (1 pixel)   */
N#define LCD_BlinkMode_SEG0_AllCOM       ((uint32_t)0x00020000) /*!< Blink enabled on SEG[0], all COM (up to 
N                                                                    8 pixels according to the programmed duty)  */
N#define LCD_BlinkMode_AllSEG_AllCOM     ((uint32_t)0x00030000) /*!< Blink enabled on all SEG and all COM (all pixels)  */
N
N#define IS_LCD_BLINK_MODE(MODE) (((MODE) == LCD_BlinkMode_Off) || \
N                                 ((MODE) == LCD_BlinkMode_SEG0_COM0) || \
N                                 ((MODE) == LCD_BlinkMode_SEG0_AllCOM) || \
N                                 ((MODE) == LCD_BlinkMode_AllSEG_AllCOM))
X#define IS_LCD_BLINK_MODE(MODE) (((MODE) == LCD_BlinkMode_Off) ||                                  ((MODE) == LCD_BlinkMode_SEG0_COM0) ||                                  ((MODE) == LCD_BlinkMode_SEG0_AllCOM) ||                                  ((MODE) == LCD_BlinkMode_AllSEG_AllCOM))
N/**
N  * @}
N  */    
N
N/** @defgroup LCD_BlinkFrequency 
N  * @{
N  */
N
N#define LCD_BlinkFrequency_Div8         ((uint32_t)0x00000000) /*!< The Blink frequency = fLCD/8    */
N#define LCD_BlinkFrequency_Div16        ((uint32_t)0x00002000) /*!< The Blink frequency = fLCD/16   */
N#define LCD_BlinkFrequency_Div32        ((uint32_t)0x00004000) /*!< The Blink frequency = fLCD/32   */
N#define LCD_BlinkFrequency_Div64        ((uint32_t)0x00006000) /*!< The Blink frequency = fLCD/64   */
N#define LCD_BlinkFrequency_Div128       ((uint32_t)0x00008000) /*!< The Blink frequency = fLCD/128  */
N#define LCD_BlinkFrequency_Div256       ((uint32_t)0x0000A000) /*!< The Blink frequency = fLCD/256  */
N#define LCD_BlinkFrequency_Div512       ((uint32_t)0x0000C000) /*!< The Blink frequency = fLCD/512  */
N#define LCD_BlinkFrequency_Div1024      ((uint32_t)0x0000E000) /*!< The Blink frequency = fLCD/1024 */
N
N#define IS_LCD_BLINK_FREQUENCY(FREQUENCY) (((FREQUENCY) == LCD_BlinkFrequency_Div8) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div16) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div32) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div64) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div128) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div256) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div512) || \
N                                           ((FREQUENCY) == LCD_BlinkFrequency_Div1024))
X#define IS_LCD_BLINK_FREQUENCY(FREQUENCY) (((FREQUENCY) == LCD_BlinkFrequency_Div8) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div16) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div32) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div64) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div128) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div256) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div512) ||                                            ((FREQUENCY) == LCD_BlinkFrequency_Div1024))
N/**
N  * @}
N  */
N
N/** @defgroup LCD_Contrast 
N  * @{
N  */
N
N#define LCD_Contrast_Level_0               ((uint32_t)0x00000000) /*!< Maximum Voltage = 2.60V    */
N#define LCD_Contrast_Level_1               ((uint32_t)0x00000400) /*!< Maximum Voltage = 2.73V    */
N#define LCD_Contrast_Level_2               ((uint32_t)0x00000800) /*!< Maximum Voltage = 2.86V    */
N#define LCD_Contrast_Level_3               ((uint32_t)0x00000C00) /*!< Maximum Voltage = 2.99V    */
N#define LCD_Contrast_Level_4               ((uint32_t)0x00001000) /*!< Maximum Voltage = 3.12V    */
N#define LCD_Contrast_Level_5               ((uint32_t)0x00001400) /*!< Maximum Voltage = 3.25V    */
N#define LCD_Contrast_Level_6               ((uint32_t)0x00001800) /*!< Maximum Voltage = 3.38V    */
N#define LCD_Contrast_Level_7               ((uint32_t)0x00001C00) /*!< Maximum Voltage = 3.51V    */
N
N#define IS_LCD_CONTRAST(CONTRAST) (((CONTRAST) == LCD_Contrast_Level_0) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_1) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_2) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_3) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_4) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_5) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_6) || \
N                                   ((CONTRAST) == LCD_Contrast_Level_7))
X#define IS_LCD_CONTRAST(CONTRAST) (((CONTRAST) == LCD_Contrast_Level_0) ||                                    ((CONTRAST) == LCD_Contrast_Level_1) ||                                    ((CONTRAST) == LCD_Contrast_Level_2) ||                                    ((CONTRAST) == LCD_Contrast_Level_3) ||                                    ((CONTRAST) == LCD_Contrast_Level_4) ||                                    ((CONTRAST) == LCD_Contrast_Level_5) ||                                    ((CONTRAST) == LCD_Contrast_Level_6) ||                                    ((CONTRAST) == LCD_Contrast_Level_7))
N/**
N  * @}
N  */
N      
N/** @defgroup LCD_Flag 
N  * @{
N  */
N
N#define LCD_FLAG_ENS                    LCD_SR_ENS
N#define LCD_FLAG_SOF                    LCD_SR_SOF
N#define LCD_FLAG_UDR                    LCD_SR_UDR
N#define LCD_FLAG_UDD                    LCD_SR_UDD
N#define LCD_FLAG_RDY                    LCD_SR_RDY
N#define LCD_FLAG_FCRSF                  LCD_SR_FCRSR
N
N#define IS_LCD_GET_FLAG(FLAG) (((FLAG) == LCD_FLAG_ENS) || ((FLAG) == LCD_FLAG_SOF) || \
N                               ((FLAG) == LCD_FLAG_UDR) || ((FLAG) == LCD_FLAG_UDD) || \
N                               ((FLAG) == LCD_FLAG_RDY) || ((FLAG) == LCD_FLAG_FCRSF))
X#define IS_LCD_GET_FLAG(FLAG) (((FLAG) == LCD_FLAG_ENS) || ((FLAG) == LCD_FLAG_SOF) ||                                ((FLAG) == LCD_FLAG_UDR) || ((FLAG) == LCD_FLAG_UDD) ||                                ((FLAG) == LCD_FLAG_RDY) || ((FLAG) == LCD_FLAG_FCRSF))
N
N#define IS_LCD_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF5) == 0x00) && ((FLAG) != 0x00))
N/**
N  * @}
N  */   
N
N/** @defgroup LCD_RAMRegister 
N  * @{
N  */
N
N#define LCD_RAMRegister_0               ((uint32_t)0x00000000) /*!< LCD RAM Register 0  */
N#define LCD_RAMRegister_1               ((uint32_t)0x00000001) /*!< LCD RAM Register 1  */
N#define LCD_RAMRegister_2               ((uint32_t)0x00000002) /*!< LCD RAM Register 2  */
N#define LCD_RAMRegister_3               ((uint32_t)0x00000003) /*!< LCD RAM Register 3  */
N#define LCD_RAMRegister_4               ((uint32_t)0x00000004) /*!< LCD RAM Register 4  */
N#define LCD_RAMRegister_5               ((uint32_t)0x00000005) /*!< LCD RAM Register 5  */
N#define LCD_RAMRegister_6               ((uint32_t)0x00000006) /*!< LCD RAM Register 6  */
N#define LCD_RAMRegister_7               ((uint32_t)0x00000007) /*!< LCD RAM Register 7  */
N#define LCD_RAMRegister_8               ((uint32_t)0x00000008) /*!< LCD RAM Register 8  */
N#define LCD_RAMRegister_9               ((uint32_t)0x00000009) /*!< LCD RAM Register 9  */
N#define LCD_RAMRegister_10              ((uint32_t)0x0000000A) /*!< LCD RAM Register 10 */
N#define LCD_RAMRegister_11              ((uint32_t)0x0000000B) /*!< LCD RAM Register 11 */
N#define LCD_RAMRegister_12              ((uint32_t)0x0000000C) /*!< LCD RAM Register 12 */
N#define LCD_RAMRegister_13              ((uint32_t)0x0000000D) /*!< LCD RAM Register 13 */
N#define LCD_RAMRegister_14              ((uint32_t)0x0000000E) /*!< LCD RAM Register 14 */
N#define LCD_RAMRegister_15              ((uint32_t)0x0000000F) /*!< LCD RAM Register 15 */
N
N#define IS_LCD_RAM_REGISTER(REGISTER) (((REGISTER) == LCD_RAMRegister_0) || \
N                                       ((REGISTER) == LCD_RAMRegister_1) || \
N                                       ((REGISTER) == LCD_RAMRegister_2) || \
N                                       ((REGISTER) == LCD_RAMRegister_3) || \
N                                       ((REGISTER) == LCD_RAMRegister_4) || \
N                                       ((REGISTER) == LCD_RAMRegister_5) || \
N                                       ((REGISTER) == LCD_RAMRegister_6) || \
N                                       ((REGISTER) == LCD_RAMRegister_7) || \
N                                       ((REGISTER) == LCD_RAMRegister_8) || \
N                                       ((REGISTER) == LCD_RAMRegister_9) || \
N                                       ((REGISTER) == LCD_RAMRegister_10) || \
N                                       ((REGISTER) == LCD_RAMRegister_11) || \
N                                       ((REGISTER) == LCD_RAMRegister_12) || \
N                                       ((REGISTER) == LCD_RAMRegister_13) || \
N                                       ((REGISTER) == LCD_RAMRegister_14) || \
N                                       ((REGISTER) == LCD_RAMRegister_15))
X#define IS_LCD_RAM_REGISTER(REGISTER) (((REGISTER) == LCD_RAMRegister_0) ||                                        ((REGISTER) == LCD_RAMRegister_1) ||                                        ((REGISTER) == LCD_RAMRegister_2) ||                                        ((REGISTER) == LCD_RAMRegister_3) ||                                        ((REGISTER) == LCD_RAMRegister_4) ||                                        ((REGISTER) == LCD_RAMRegister_5) ||                                        ((REGISTER) == LCD_RAMRegister_6) ||                                        ((REGISTER) == LCD_RAMRegister_7) ||                                        ((REGISTER) == LCD_RAMRegister_8) ||                                        ((REGISTER) == LCD_RAMRegister_9) ||                                        ((REGISTER) == LCD_RAMRegister_10) ||                                        ((REGISTER) == LCD_RAMRegister_11) ||                                        ((REGISTER) == LCD_RAMRegister_12) ||                                        ((REGISTER) == LCD_RAMRegister_13) ||                                        ((REGISTER) == LCD_RAMRegister_14) ||                                        ((REGISTER) == LCD_RAMRegister_15))
N
N/**
N  * @}
N  */  
N   
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the LCD configuration to the default reset state *****/
Nvoid LCD_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid LCD_Init(LCD_InitTypeDef* LCD_InitStruct);
Nvoid LCD_StructInit(LCD_InitTypeDef* LCD_InitStruct);
Nvoid LCD_Cmd(FunctionalState NewState);
Nvoid LCD_WaitForSynchro(void);
Nvoid LCD_HighDriveCmd(FunctionalState NewState);
Nvoid LCD_MuxSegmentCmd(FunctionalState NewState);
Nvoid LCD_PulseOnDurationConfig(uint32_t LCD_PulseOnDuration);
Nvoid LCD_DeadTimeConfig(uint32_t LCD_DeadTime);
Nvoid LCD_BlinkConfig(uint32_t LCD_BlinkMode, uint32_t LCD_BlinkFrequency);
Nvoid LCD_ContrastConfig(uint32_t LCD_Contrast);
N
N/* LCD RAM memory write functions *********************************************/
Nvoid LCD_Write(uint32_t LCD_RAMRegister, uint32_t LCD_Data);
Nvoid LCD_UpdateDisplayRequest(void);
N
N/* Interrupts and flags management functions **********************************/
Nvoid LCD_ITConfig(uint32_t LCD_IT, FunctionalState NewState);
NFlagStatus LCD_GetFlagStatus(uint32_t LCD_FLAG);
Nvoid LCD_ClearFlag(uint32_t LCD_FLAG);
NITStatus LCD_GetITStatus(uint32_t LCD_IT);
Nvoid LCD_ClearITPendingBit(uint32_t LCD_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_LCD_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_opamp.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_opamp.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_opamp.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the operational
N  *          amplifiers (opamp) firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_OPAMP_H
N#define __STM32L1xx_OPAMP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup OPAMP
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup OPAMP_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup OPAMP_Selection
N  * @{
N  */
N
N#define OPAMP_Selection_OPAMP1                    OPAMP_CSR_OPA1PD
N#define OPAMP_Selection_OPAMP2                    OPAMP_CSR_OPA2PD
N#define OPAMP_Selection_OPAMP3                    OPAMP_CSR_OPA3PD
N
N#define IS_OPAMP_ALL_PERIPH(PERIPH) (((PERIPH) == OPAMP_Selection_OPAMP1) || \
N                                     ((PERIPH) == OPAMP_Selection_OPAMP2) || \
N                                     ((PERIPH) == OPAMP_Selection_OPAMP3))
X#define IS_OPAMP_ALL_PERIPH(PERIPH) (((PERIPH) == OPAMP_Selection_OPAMP1) ||                                      ((PERIPH) == OPAMP_Selection_OPAMP2) ||                                      ((PERIPH) == OPAMP_Selection_OPAMP3))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPAMP_Switches
N  * @{
N  */
N
N/* OPAMP1 Switches */
N#define OPAMP_OPAMP1Switch3           OPAMP_CSR_S3SEL1 /*!< OPAMP1 Switch 3 */
N#define OPAMP_OPAMP1Switch4           OPAMP_CSR_S4SEL1 /*!< OPAMP1 Switch 4 */
N#define OPAMP_OPAMP1Switch5           OPAMP_CSR_S5SEL1 /*!< OPAMP1 Switch 5 */
N#define OPAMP_OPAMP1Switch6           OPAMP_CSR_S6SEL1 /*!< OPAMP1 Switch 6 */
N#define OPAMP_OPAMP1SwitchANA         OPAMP_CSR_ANAWSEL1 /*!< OPAMP1 Switch ANA */
N
N/* OPAMP2 Switches */
N#define OPAMP_OPAMP2Switch3           OPAMP_CSR_S3SEL2 /*!< OPAMP2 Switch 3 */
N#define OPAMP_OPAMP2Switch4           OPAMP_CSR_S4SEL2 /*!< OPAMP2 Switch 4 */
N#define OPAMP_OPAMP2Switch5           OPAMP_CSR_S5SEL2 /*!< OPAMP2 Switch 5 */
N#define OPAMP_OPAMP2Switch6           OPAMP_CSR_S6SEL2 /*!< OPAMP2 Switch 6 */
N#define OPAMP_OPAMP2Switch7           OPAMP_CSR_S7SEL2 /*!< OPAMP2 Switch 7 */
N#define OPAMP_OPAMP2SwitchANA         OPAMP_CSR_ANAWSEL2 /*!< OPAMP2 Switch ANA */
N
N/* OPAMP3 Switches */
N#define OPAMP_OPAMP3Switch3           OPAMP_CSR_S3SEL3 /*!< OPAMP3 Switch 3 */
N#define OPAMP_OPAMP3Switch4           OPAMP_CSR_S4SEL3 /*!< OPAMP3 Switch 4 */
N#define OPAMP_OPAMP3Switch5           OPAMP_CSR_S5SEL3 /*!< OPAMP3 Switch 5 */
N#define OPAMP_OPAMP3Switch6           OPAMP_CSR_S6SEL3 /*!< OPAMP3 Switch 6 */
N#define OPAMP_OPAMP3SwitchANA         OPAMP_CSR_ANAWSEL3 /*!< OPAMP3 Switch ANA */
N
N#define IS_OPAMP_SWITCH(SWITCH) ((((SWITCH) & (uint32_t)0xF0E1E1E1) == 0x00) && ((SWITCH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPAMP_Trimming
N  * @{
N  */
N
N#define OPAMP_Trimming_Factory        ((uint32_t)0x00000000) /*!< Factory trimming */
N#define OPAMP_Trimming_User           OPAMP_OTR_OT_USER /*!< User trimming */
N
N#define IS_OPAMP_TRIMMING(TRIMMING) (((TRIMMING) == OPAMP_Trimming_Factory) || \
N                                     ((TRIMMING) == OPAMP_Trimming_User))
X#define IS_OPAMP_TRIMMING(TRIMMING) (((TRIMMING) == OPAMP_Trimming_Factory) ||                                      ((TRIMMING) == OPAMP_Trimming_User))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPAMP_Input
N  * @{
N  */
N
N#define OPAMP_Input_NMOS              OPAMP_CSR_OPA1CAL_H /*!< NMOS input */
N#define OPAMP_Input_PMOS              OPAMP_CSR_OPA1CAL_L /*!< PMOS input */
N
N#define IS_OPAMP_INPUT(INPUT) (((INPUT) == OPAMP_Input_NMOS) || \
N                               ((INPUT) == OPAMP_Input_PMOS))
X#define IS_OPAMP_INPUT(INPUT) (((INPUT) == OPAMP_Input_NMOS) ||                                ((INPUT) == OPAMP_Input_PMOS))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPAMP_TrimValue
N  * @{
N  */
N
N#define IS_OPAMP_TRIMMINGVALUE(VALUE) ((VALUE) <= 0x0000001F) /*!< Trimming value */
N
N/**
N  * @}
N  */
N
N/** @defgroup OPAMP_PowerRange
N  * @{
N  */
N
N#define OPAMP_PowerRange_Low          ((uint32_t)0x00000000) /*!< Low power range is selected (VDDA is lower than 2.4V) */
N#define OPAMP_PowerRange_High         OPAMP_CSR_AOP_RANGE    /*!< High power range is selected (VDDA is higher than 2.4V) */
N
N#define IS_OPAMP_RANGE(RANGE) (((RANGE) == OPAMP_PowerRange_Low) || \
N                               ((RANGE) == OPAMP_PowerRange_High))
X#define IS_OPAMP_RANGE(RANGE) (((RANGE) == OPAMP_PowerRange_Low) ||                                ((RANGE) == OPAMP_PowerRange_High))
N
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Initialization and Configuration functions *********************************/
Nvoid OPAMP_DeInit(void);
Nvoid OPAMP_SwitchCmd(uint32_t OPAMP_OPAMPxSwitchy, FunctionalState NewState);
Nvoid OPAMP_Cmd(uint32_t OPAMP_Selection, FunctionalState NewState);
Nvoid OPAMP_LowPowerCmd(uint32_t OPAMP_Selection, FunctionalState NewState);
Nvoid OPAMP_PowerRangeSelect(uint32_t OPAMP_PowerRange);
N
N/* Calibration functions ******************************************************/
Nvoid OPAMP_OffsetTrimmingModeSelect(uint32_t OPAMP_Trimming);
Nvoid OPAMP_OffsetTrimConfig(uint32_t OPAMP_Selection, uint32_t OPAMP_Input, uint32_t OPAMP_TrimValue);
Nvoid OPAMP_OffsetTrimLowPowerConfig(uint32_t OPAMP_Selection, uint32_t OPAMP_Input, uint32_t OPAMP_TrimValue);
NFlagStatus OPAMP_GetFlagStatus(uint32_t OPAMP_Selection);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_OPAMP_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_pwr.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_pwr.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the PWR firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_PWR_H
N#define __STM32L1xx_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup PWR_PVD_detection_level 
N  * @{
N  */ 
N
N#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7 /* External input analog voltage 
N                                                          (Compare internally to VREFINT) */
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)||                                  ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)||                                  ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)||                                  ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_WakeUp_Pins 
N  * @{
N  */
N
N#define PWR_WakeUpPin_1                 ((uint32_t)0x00000000)
N#define PWR_WakeUpPin_2                 ((uint32_t)0x00000004)
N#define PWR_WakeUpPin_3                 ((uint32_t)0x00000008)
N#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) || \
N                                ((PIN) == PWR_WakeUpPin_2) || \
N                                ((PIN) == PWR_WakeUpPin_3))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) ||                                 ((PIN) == PWR_WakeUpPin_2) ||                                 ((PIN) == PWR_WakeUpPin_3))
N/**
N  * @}
N  */
N
N  
N/** @defgroup PWR_Voltage_Scaling_Ranges
N  * @{
N  */
N
N#define PWR_VoltageScaling_Range1       PWR_CR_VOS_0
N#define PWR_VoltageScaling_Range2       PWR_CR_VOS_1
N#define PWR_VoltageScaling_Range3       PWR_CR_VOS
N
N#define IS_PWR_VOLTAGE_SCALING_RANGE(RANGE) (((RANGE) == PWR_VoltageScaling_Range1) || \
N                                             ((RANGE) == PWR_VoltageScaling_Range2) || \
N                                             ((RANGE) == PWR_VoltageScaling_Range3))
X#define IS_PWR_VOLTAGE_SCALING_RANGE(RANGE) (((RANGE) == PWR_VoltageScaling_Range1) ||                                              ((RANGE) == PWR_VoltageScaling_Range2) ||                                              ((RANGE) == PWR_VoltageScaling_Range3))
N/**
N  * @}
N  */    
N  
N/** @defgroup PWR_Regulator_state_is_Sleep_STOP_mode 
N  * @{
N  */
N
N#define PWR_Regulator_ON                ((uint32_t)0x00000000)
N#define PWR_Regulator_LowPower          PWR_CR_LPSDSR
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_SLEEP_mode_entry 
N  * @{
N  */
N
N#define PWR_SLEEPEntry_WFI              ((uint8_t)0x01)
N#define PWR_SLEEPEntry_WFE              ((uint8_t)0x02)
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPEntry_WFI) || ((ENTRY) == PWR_SLEEPEntry_WFE))
N 
N/**
N  * @}
N  */
N  
N/** @defgroup PWR_STOP_mode_entry 
N  * @{
N  */
N
N#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
N#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag 
N  * @{
N  */
N
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_VREFINTRDY             PWR_CSR_VREFINTRDYF
N#define PWR_FLAG_VOS                    PWR_CSR_VOSF
N#define PWR_FLAG_REGLP                  PWR_CSR_REGLPF
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY) || \
N                               ((FLAG) == PWR_FLAG_VOS) || ((FLAG) == PWR_FLAG_REGLP))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY) ||                                ((FLAG) == PWR_FLAG_VOS) || ((FLAG) == PWR_FLAG_REGLP))
N
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the PWR configuration to the default reset state ******/ 
Nvoid PWR_DeInit(void);
N
N/* RTC Domain Access function *************************************************/ 
Nvoid PWR_RTCAccessCmd(FunctionalState NewState);
N
N/* PVD configuration functions ************************************************/ 
Nvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
Nvoid PWR_PVDCmd(FunctionalState NewState);
N
N/* WakeUp pins configuration functions ****************************************/ 
Nvoid PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState);
N
N/* Ultra Low Power mode configuration functions *******************************/ 
Nvoid PWR_FastWakeUpCmd(FunctionalState NewState);
Nvoid PWR_UltraLowPowerCmd(FunctionalState NewState);
N
N/* Voltage Scaling configuration functions ************************************/ 
Nvoid PWR_VoltageScalingConfig(uint32_t PWR_VoltageScaling);
N
N/* Low Power modes configuration functions ************************************/ 
Nvoid PWR_EnterLowPowerRunMode(FunctionalState NewState);
Nvoid PWR_EnterSleepMode(uint32_t PWR_Regulator, uint8_t PWR_SLEEPEntry);
Nvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
N
N/* Flags management functions *************************************************/ 
NFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
Nvoid PWR_ClearFlag(uint32_t PWR_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_PWR_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 50 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_rcc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_rcc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the RCC 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_RCC_H
N#define __STM32L1xx_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;
N  uint32_t HCLK_Frequency;
N  uint32_t PCLK1_Frequency;
N  uint32_t PCLK2_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup RCC_HSE_configuration 
N  * @{
N  */
N
N#define RCC_HSE_OFF                      ((uint8_t)0x00)
N#define RCC_HSE_ON                       ((uint8_t)0x01)
N#define RCC_HSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_MSI_Clock_Range 
N  * @{
N  */
N
N#define RCC_MSIRange_0                   RCC_ICSCR_MSIRANGE_0 /*!< MSI = 65.536 KHz  */
N#define RCC_MSIRange_1                   RCC_ICSCR_MSIRANGE_1 /*!< MSI = 131.072 KHz */
N#define RCC_MSIRange_2                   RCC_ICSCR_MSIRANGE_2 /*!< MSI = 262.144 KHz */
N#define RCC_MSIRange_3                   RCC_ICSCR_MSIRANGE_3 /*!< MSI = 524.288 KHz */
N#define RCC_MSIRange_4                   RCC_ICSCR_MSIRANGE_4 /*!< MSI = 1.048 MHz   */
N#define RCC_MSIRange_5                   RCC_ICSCR_MSIRANGE_5 /*!< MSI = 2.097 MHz   */
N#define RCC_MSIRange_6                   RCC_ICSCR_MSIRANGE_6 /*!< MSI = 4.194 MHz   */
N
N#define IS_RCC_MSI_CLOCK_RANGE(RANGE) (((RANGE) == RCC_MSIRange_0) || \
N                                       ((RANGE) == RCC_MSIRange_1) || \
N                                       ((RANGE) == RCC_MSIRange_2) || \
N                                       ((RANGE) == RCC_MSIRange_3) || \
N                                       ((RANGE) == RCC_MSIRange_4) || \
N                                       ((RANGE) == RCC_MSIRange_5) || \
N                                       ((RANGE) == RCC_MSIRange_6))
X#define IS_RCC_MSI_CLOCK_RANGE(RANGE) (((RANGE) == RCC_MSIRange_0) ||                                        ((RANGE) == RCC_MSIRange_1) ||                                        ((RANGE) == RCC_MSIRange_2) ||                                        ((RANGE) == RCC_MSIRange_3) ||                                        ((RANGE) == RCC_MSIRange_4) ||                                        ((RANGE) == RCC_MSIRange_5) ||                                        ((RANGE) == RCC_MSIRange_6))
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup RCC_PLL_Clock_Source 
N  * @{
N  */
N
N#define RCC_PLLSource_HSI                ((uint8_t)0x00)
N#define RCC_PLLSource_HSE                ((uint8_t)0x01)
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) ||                                    ((SOURCE) == RCC_PLLSource_HSE))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_PLL_Multiplication_Factor 
N  * @{
N  */
N
N#define RCC_PLLMul_3                     ((uint8_t)0x00)
N#define RCC_PLLMul_4                     ((uint8_t)0x04)
N#define RCC_PLLMul_6                     ((uint8_t)0x08)
N#define RCC_PLLMul_8                     ((uint8_t)0x0C)
N#define RCC_PLLMul_12                    ((uint8_t)0x10)
N#define RCC_PLLMul_16                    ((uint8_t)0x14)
N#define RCC_PLLMul_24                    ((uint8_t)0x18)
N#define RCC_PLLMul_32                    ((uint8_t)0x1C)
N#define RCC_PLLMul_48                    ((uint8_t)0x20)
N
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_3) || ((MUL) == RCC_PLLMul_4) || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_8) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_16) || \
N                             ((MUL) == RCC_PLLMul_24) || ((MUL) == RCC_PLLMul_32) || \
N                             ((MUL) == RCC_PLLMul_48))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_3) || ((MUL) == RCC_PLLMul_4) ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_8) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_16) ||                              ((MUL) == RCC_PLLMul_24) || ((MUL) == RCC_PLLMul_32) ||                              ((MUL) == RCC_PLLMul_48))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PLL_Divider_Factor 
N  * @{
N  */
N
N#define RCC_PLLDiv_2                     ((uint8_t)0x40)
N#define RCC_PLLDiv_3                     ((uint8_t)0x80)
N#define RCC_PLLDiv_4                     ((uint8_t)0xC0)
N
N
N#define IS_RCC_PLL_DIV(DIV) (((DIV) == RCC_PLLDiv_2) || ((DIV) == RCC_PLLDiv_3) || \
N                             ((DIV) == RCC_PLLDiv_4))
X#define IS_RCC_PLL_DIV(DIV) (((DIV) == RCC_PLLDiv_2) || ((DIV) == RCC_PLLDiv_3) ||                              ((DIV) == RCC_PLLDiv_4))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_System_Clock_Source 
N  * @{
N  */
N
N#define RCC_SYSCLKSource_MSI             RCC_CFGR_SW_MSI
N#define RCC_SYSCLKSource_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSource_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSource_PLLCLK          RCC_CFGR_SW_PLL
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_MSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_MSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source
N  * @{
N  */
N
N#define RCC_SYSCLK_Div1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_Div2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_Div4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_Div8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_Div16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_Div64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_Div128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_Div256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_Div512                RCC_CFGR_HPRE_DIV512
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_APB2_Clock_Source
N  * @{
N  */
N
N#define RCC_HCLK_Div1                    RCC_CFGR_PPRE1_DIV1
N#define RCC_HCLK_Div2                    RCC_CFGR_PPRE1_DIV2
N#define RCC_HCLK_Div4                    RCC_CFGR_PPRE1_DIV4
N#define RCC_HCLK_Div8                    RCC_CFGR_PPRE1_DIV8
N#define RCC_HCLK_Div16                   RCC_CFGR_PPRE1_DIV16
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */
N  
N
N/** @defgroup RCC_Interrupt_Source 
N  * @{
N  */
N
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_MSIRDY                    ((uint8_t)0x20)
N#define RCC_IT_LSECSS                    ((uint8_t)0x40)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
N
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_MSIRDY) || \
N                           ((IT) == RCC_IT_CSS)  || ((IT) == RCC_IT_LSECSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_MSIRDY) ||                            ((IT) == RCC_IT_CSS)  || ((IT) == RCC_IT_LSECSS))
N
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x00) == 0x00) && ((IT) != 0x00))
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_LSE_Configuration 
N  * @{
N  */
N
N#define RCC_LSE_OFF                      ((uint8_t)0x00)
N#define RCC_LSE_ON                       ((uint8_t)0x01)
N#define RCC_LSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source
N  * @{
N  */
N
N#define RCC_RTCCLKSource_LSE             RCC_CSR_RTCSEL_LSE
N#define RCC_RTCCLKSource_LSI             RCC_CSR_RTCSEL_LSI
N#define RCC_RTCCLKSource_HSE_Div2        RCC_CSR_RTCSEL_HSE
N#define RCC_RTCCLKSource_HSE_Div4        ((uint32_t)RCC_CSR_RTCSEL_HSE | RCC_CR_RTCPRE_0)
N#define RCC_RTCCLKSource_HSE_Div8        ((uint32_t)RCC_CSR_RTCSEL_HSE | RCC_CR_RTCPRE_1)
N#define RCC_RTCCLKSource_HSE_Div16       ((uint32_t)RCC_CSR_RTCSEL_HSE | RCC_CR_RTCPRE)
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div16))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Peripherals 
N  * @{
N  */
N
N#define RCC_AHBPeriph_GPIOA               RCC_AHBENR_GPIOAEN
N#define RCC_AHBPeriph_GPIOB               RCC_AHBENR_GPIOBEN
N#define RCC_AHBPeriph_GPIOC               RCC_AHBENR_GPIOCEN
N#define RCC_AHBPeriph_GPIOD               RCC_AHBENR_GPIODEN
N#define RCC_AHBPeriph_GPIOE               RCC_AHBENR_GPIOEEN
N#define RCC_AHBPeriph_GPIOH               RCC_AHBENR_GPIOHEN
N#define RCC_AHBPeriph_GPIOF               RCC_AHBENR_GPIOFEN
N#define RCC_AHBPeriph_GPIOG               RCC_AHBENR_GPIOGEN
N#define RCC_AHBPeriph_CRC                 RCC_AHBENR_CRCEN
N#define RCC_AHBPeriph_FLITF               RCC_AHBENR_FLITFEN
N#define RCC_AHBPeriph_SRAM                RCC_AHBLPENR_SRAMLPEN
N#define RCC_AHBPeriph_DMA1                RCC_AHBENR_DMA1EN
N#define RCC_AHBPeriph_DMA2                RCC_AHBENR_DMA2EN
N#define RCC_AHBPeriph_AES                 RCC_AHBENR_AESEN
N#define RCC_AHBPeriph_FSMC                RCC_AHBENR_FSMCEN
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xB4FF6F00) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB_LPMODE_PERIPH(PERIPH) ((((PERIPH) & 0xB4FF6F00) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripherals 
N  * @{
N  */
N
N#define RCC_APB2Periph_SYSCFG            RCC_APB2ENR_SYSCFGEN
N#define RCC_APB2Periph_TIM9              RCC_APB2ENR_TIM9EN
N#define RCC_APB2Periph_TIM10             RCC_APB2ENR_TIM10EN
N#define RCC_APB2Periph_TIM11             RCC_APB2ENR_TIM11EN
N#define RCC_APB2Periph_ADC1              RCC_APB2ENR_ADC1EN
N#define RCC_APB2Periph_SDIO              RCC_APB2ENR_SDIOEN
N#define RCC_APB2Periph_SPI1              RCC_APB2ENR_SPI1EN
N#define RCC_APB2Periph_USART1            RCC_APB2ENR_USART1EN
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFA5E2) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_Peripherals 
N  * @{
N  */
N
N#define RCC_APB1Periph_TIM2              RCC_APB1ENR_TIM2EN
N#define RCC_APB1Periph_TIM3              RCC_APB1ENR_TIM3EN
N#define RCC_APB1Periph_TIM4              RCC_APB1ENR_TIM4EN
N#define RCC_APB1Periph_TIM5              RCC_APB1ENR_TIM5EN
N#define RCC_APB1Periph_TIM6              RCC_APB1ENR_TIM6EN
N#define RCC_APB1Periph_TIM7              RCC_APB1ENR_TIM7EN
N#define RCC_APB1Periph_LCD               RCC_APB1ENR_LCDEN
N#define RCC_APB1Periph_WWDG              RCC_APB1ENR_WWDGEN
N#define RCC_APB1Periph_SPI2              RCC_APB1ENR_SPI2EN
N#define RCC_APB1Periph_SPI3              RCC_APB1ENR_SPI3EN
N#define RCC_APB1Periph_USART2            RCC_APB1ENR_USART2EN
N#define RCC_APB1Periph_USART3            RCC_APB1ENR_USART3EN
N#define RCC_APB1Periph_UART4             RCC_APB1ENR_UART4EN
N#define RCC_APB1Periph_UART5             RCC_APB1ENR_UART5EN
N#define RCC_APB1Periph_I2C1              RCC_APB1ENR_I2C1EN
N#define RCC_APB1Periph_I2C2              RCC_APB1ENR_I2C2EN
N#define RCC_APB1Periph_USB               RCC_APB1ENR_USBEN
N#define RCC_APB1Periph_PWR               RCC_APB1ENR_PWREN
N#define RCC_APB1Periph_DAC               RCC_APB1ENR_DACEN
N#define RCC_APB1Periph_COMP              RCC_APB1ENR_COMPEN
N
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x4F0135C0) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Clock_Source
N  * @{
N  */
N
N#define RCC_MCOSource_NoClock            ((uint8_t)0x00)
N#define RCC_MCOSource_SYSCLK             ((uint8_t)0x01)
N#define RCC_MCOSource_HSI                ((uint8_t)0x02)
N#define RCC_MCOSource_MSI                ((uint8_t)0x03)
N#define RCC_MCOSource_HSE                ((uint8_t)0x04)
N#define RCC_MCOSource_PLLCLK             ((uint8_t)0x05)
N#define RCC_MCOSource_LSI                ((uint8_t)0x06)
N#define RCC_MCOSource_LSE                ((uint8_t)0x07)
N
N#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_SYSCLK) || \
N                                   ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_MSI) || \
N                                   ((SOURCE) == RCC_MCOSource_HSE)  || ((SOURCE) == RCC_MCOSource_PLLCLK) || \
N                                   ((SOURCE) == RCC_MCOSource_LSI) || ((SOURCE) == RCC_MCOSource_LSE))
X#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_SYSCLK) ||                                    ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_MSI) ||                                    ((SOURCE) == RCC_MCOSource_HSE)  || ((SOURCE) == RCC_MCOSource_PLLCLK) ||                                    ((SOURCE) == RCC_MCOSource_LSI) || ((SOURCE) == RCC_MCOSource_LSE))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Output_Divider 
N  * @{
N  */
N
N#define RCC_MCODiv_1                     ((uint8_t)0x00)
N#define RCC_MCODiv_2                     ((uint8_t)0x10)
N#define RCC_MCODiv_4                     ((uint8_t)0x20)
N#define RCC_MCODiv_8                     ((uint8_t)0x30)
N#define RCC_MCODiv_16                    ((uint8_t)0x40)
N
N#define IS_RCC_MCO_DIV(DIV) (((DIV) == RCC_MCODiv_1) || ((DIV) == RCC_MCODiv_2) || \
N                             ((DIV) == RCC_MCODiv_4)  || ((DIV) == RCC_MCODiv_8) || \
N                             ((DIV) == RCC_MCODiv_16))
X#define IS_RCC_MCO_DIV(DIV) (((DIV) == RCC_MCODiv_1) || ((DIV) == RCC_MCODiv_2) ||                              ((DIV) == RCC_MCODiv_4)  || ((DIV) == RCC_MCODiv_8) ||                              ((DIV) == RCC_MCODiv_16))
N/**
N  * @}
N  */  
N
N/** @defgroup RCC_Flag 
N  * @{
N  */
N
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
N#define RCC_FLAG_MSIRDY                  ((uint8_t)0x29)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x49)
N#define RCC_FLAG_LSECSS                  ((uint8_t)0x4A)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x41)
N#define RCC_FLAG_OBLRST                  ((uint8_t)0x59)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x5A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x5B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x5C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x5D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x5E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x5F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_MSIRDY) || ((FLAG) == RCC_FLAG_PLLRDY) || \
N                           ((FLAG) == RCC_FLAG_LSERDY) || ((FLAG) == RCC_FLAG_LSIRDY) || \
N                           ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) || \
N                           ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)|| \
N                           ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LSECSS))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_MSIRDY) || ((FLAG) == RCC_FLAG_PLLRDY) ||                            ((FLAG) == RCC_FLAG_LSERDY) || ((FLAG) == RCC_FLAG_LSIRDY) ||                            ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) ||                            ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)||                            ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)||                            ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LSECSS))
N
N#define IS_RCC_HSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N#define IS_RCC_MSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x3F)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the RCC clock configuration to the default reset state */
Nvoid RCC_DeInit(void);
N
N/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Nvoid RCC_HSEConfig(uint8_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_MSIRangeConfig(uint32_t RCC_MSIRange);
Nvoid RCC_AdjustMSICalibrationValue(uint8_t MSICalibrationValue);
Nvoid RCC_MSICmd(FunctionalState NewState);
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_LSEConfig(uint8_t RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(uint8_t RCC_PLLSource, uint8_t RCC_PLLMul, uint8_t RCC_PLLDiv);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_LSEClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(uint8_t RCC_MCOSource, uint8_t RCC_MCODiv);
N
N/* System, AHB and APB busses clocks configuration functions ******************/
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid RCC_PCLK1Config(uint32_t RCC_HCLK);
Nvoid RCC_PCLK2Config(uint32_t RCC_HCLK);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
N
N/* Peripheral clocks configuration functions **********************************/
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_RTCResetCmd(FunctionalState NewState);
N
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
Nvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
Nvoid RCC_AHBPeriphClockLPModeCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(uint8_t RCC_IT);
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_RCC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 51 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_rtc.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_rtc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the RTC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_RTC_H
N#define __STM32L1xx_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  RTC Init structures definition  
N  */ 
Ntypedef struct
N{
N  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
N                             This parameter can be a value of @ref RTC_Hour_Formats */
N  
N  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7F */
N  
N  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7FFF */ 
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
N                        This parameter must be set to a value in the 0-12 range
N                        if the RTC_HourFormat_12 is selected or 0-23 range if
N                        the RTC_HourFormat_24 is selected. */
N
N  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
N                        This parameter must be set to a value in the 0-59 range. */
N  
N  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
N                        This parameter must be set to a value in the 0-59 range. */
N
N  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
N                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
N}RTC_TimeTypeDef; 
N
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
N                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month (in BCD format).
N                        This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
N                        This parameter must be set to a value in the 1-31 range. */
N  
N  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
N                        This parameter must be set to a value in the 0-99 range. */
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */
N
N  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N
N  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                     If the Alarm Date is selected, this parameter
N                                     must be set to a value in the 1-31 range.
N                                     If the Alarm WeekDay is selected, this 
N                                     parameter can be a value of @ref RTC_WeekDay_Definitions */
N}RTC_AlarmTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RTC_Exported_Constants
N  * @{
N  */ 
N
N
N/** @defgroup RTC_Hour_Formats 
N  * @{
N  */ 
N#define RTC_HourFormat_24              ((uint32_t)0x00000000)
N#define RTC_HourFormat_12              ((uint32_t)0x00000040)
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
N                                        ((FORMAT) == RTC_HourFormat_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) ||                                         ((FORMAT) == RTC_HourFormat_24))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Asynchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
N 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Synchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Definitions 
N  * @{
N  */ 
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AM_PM_Definitions 
N  * @{
N  */ 
N#define RTC_H12_AM                     ((uint8_t)0x00)
N#define RTC_H12_PM                     ((uint8_t)0x40)
N#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Year_Date_Definitions 
N  * @{
N  */ 
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Month_Date_Definitions 
N  * @{
N  */ 
N
N/* Coded in BCD format */
N#define RTC_Month_January              ((uint8_t)0x01)
N#define RTC_Month_February             ((uint8_t)0x02)
N#define RTC_Month_March                ((uint8_t)0x03)
N#define RTC_Month_April                ((uint8_t)0x04)
N#define RTC_Month_May                  ((uint8_t)0x05)
N#define RTC_Month_June                 ((uint8_t)0x06)
N#define RTC_Month_July                 ((uint8_t)0x07)
N#define RTC_Month_August               ((uint8_t)0x08)
N#define RTC_Month_September            ((uint8_t)0x09)
N#define RTC_Month_October              ((uint8_t)0x10)
N#define RTC_Month_November             ((uint8_t)0x11)
N#define RTC_Month_December             ((uint8_t)0x12)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions 
N  * @{
N  */ 
N  
N#define RTC_Weekday_Monday             ((uint8_t)0x01)
N#define RTC_Weekday_Tuesday            ((uint8_t)0x02)
N#define RTC_Weekday_Wednesday          ((uint8_t)0x03)
N#define RTC_Weekday_Thursday           ((uint8_t)0x04)
N#define RTC_Weekday_Friday             ((uint8_t)0x05)
N#define RTC_Weekday_Saturday           ((uint8_t)0x06)
N#define RTC_Weekday_Sunday             ((uint8_t)0x07)
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                  ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                  ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                  ((WEEKDAY) == RTC_Weekday_Thursday) ||                                  ((WEEKDAY) == RTC_Weekday_Friday) ||                                  ((WEEKDAY) == RTC_Weekday_Saturday) ||                                  ((WEEKDAY) == RTC_Weekday_Sunday))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Alarm_Definitions 
N  * @{
N  */ 
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                                     ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Thursday) ||                                                     ((WEEKDAY) == RTC_Weekday_Friday) ||                                                     ((WEEKDAY) == RTC_Weekday_Saturday) ||                                                     ((WEEKDAY) == RTC_Weekday_Sunday))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)  
N#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)  
N
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
N                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) ||                                             ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmMask_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
N#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)  
N#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
N#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
N#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
N#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
N#define IS_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions 
N  * @{
N  */ 
N#define RTC_Alarm_A                       ((uint32_t)0x00000100)
N#define RTC_Alarm_B                       ((uint32_t)0x00000200)
N#define IS_RTC_ALARM(ALARM)     (((ALARM) == RTC_Alarm_A) || ((ALARM) == RTC_Alarm_B))
N#define IS_RTC_CMD_ALARM(ALARM) (((ALARM) & (RTC_Alarm_A | RTC_Alarm_B)) != (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions
N  * @{
N  */ 
N#define RTC_AlarmSubSecondMask_All         ((uint32_t)0x00000000) /*!< All Alarm SS fields are masked. 
N                                                                       There is no comparison on sub seconds 
N                                                                       for Alarm */
N#define RTC_AlarmSubSecondMask_SS14_1      ((uint32_t)0x01000000) /*!< SS[14:1] are don't care in Alarm 
N                                                                       comparison. Only SS[0] is compared. */
N#define RTC_AlarmSubSecondMask_SS14_2      ((uint32_t)0x02000000) /*!< SS[14:2] are don't care in Alarm 
N                                                                       comparison. Only SS[1:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_3      ((uint32_t)0x03000000) /*!< SS[14:3] are don't care in Alarm 
N                                                                       comparison. Only SS[2:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_4      ((uint32_t)0x04000000) /*!< SS[14:4] are don't care in Alarm 
N                                                                       comparison. Only SS[3:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_5      ((uint32_t)0x05000000) /*!< SS[14:5] are don't care in Alarm 
N                                                                       comparison. Only SS[4:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_6      ((uint32_t)0x06000000) /*!< SS[14:6] are don't care in Alarm 
N                                                                       comparison. Only SS[5:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_7      ((uint32_t)0x07000000) /*!< SS[14:7] are don't care in Alarm 
N                                                                       comparison. Only SS[6:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_8      ((uint32_t)0x08000000) /*!< SS[14:8] are don't care in Alarm 
N                                                                       comparison. Only SS[7:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_9      ((uint32_t)0x09000000) /*!< SS[14:9] are don't care in Alarm 
N                                                                       comparison. Only SS[8:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_10     ((uint32_t)0x0A000000) /*!< SS[14:10] are don't care in Alarm 
N                                                                       comparison. Only SS[9:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_11     ((uint32_t)0x0B000000) /*!< SS[14:11] are don't care in Alarm 
N                                                                       comparison. Only SS[10:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_12     ((uint32_t)0x0C000000) /*!< SS[14:12] are don't care in Alarm 
N                                                                       comparison.Only SS[11:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_13     ((uint32_t)0x0D000000) /*!< SS[14:13] are don't care in Alarm 
N                                                                       comparison. Only SS[12:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14        ((uint32_t)0x0E000000) /*!< SS[14] is don't care in Alarm 
N                                                                       comparison.Only SS[13:0] are compared */
N#define RTC_AlarmSubSecondMask_None        ((uint32_t)0x0F000000) /*!< SS[14:0] are compared and must match 
N                                                                       to activate alarm. */
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_None))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_1) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_2) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_3) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_4) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_5) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_6) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_7) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_8) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_9) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_10) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_11) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_12) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_13) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14) ||                                               ((MASK) == RTC_AlarmSubSecondMask_None))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Value
N  * @{
N  */ 
N
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Wakeup_Timer_Definitions 
N  * @{
N  */
N#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
N#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
N#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
N#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
N#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
N#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
N#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
X#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
N#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFF)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Stamp_Edges_definitions 
N  * @{
N  */ 
N#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
N#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
N#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
N                                     ((EDGE) == RTC_TimeStampEdge_Falling))
X#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) ||                                      ((EDGE) == RTC_TimeStampEdge_Falling))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_Output_Disable             ((uint32_t)0x00000000)
N#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
N#define RTC_Output_AlarmB              ((uint32_t)0x00400000)
N#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
N 
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
N                               ((OUTPUT) == RTC_Output_AlarmA) || \
N                               ((OUTPUT) == RTC_Output_AlarmB) || \
N                               ((OUTPUT) == RTC_Output_WakeUp))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) ||                                ((OUTPUT) == RTC_Output_AlarmA) ||                                ((OUTPUT) == RTC_Output_AlarmB) ||                                ((OUTPUT) == RTC_Output_WakeUp))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Polarity_Definitions 
N  * @{
N  */ 
N#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
N#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
N                                ((POL) == RTC_OutputPolarity_Low))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) ||                                 ((POL) == RTC_OutputPolarity_Low))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Coarse_Calibration_Definitions 
N  * @{
N  */ 
N#define RTC_CalibSign_Positive            ((uint32_t)0x00000000) 
N#define RTC_CalibSign_Negative            ((uint32_t)0x00000080)
N#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) || \
N                                 ((SIGN) == RTC_CalibSign_Negative))
X#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) ||                                  ((SIGN) == RTC_CalibSign_Negative))
N#define IS_RTC_CALIB_VALUE(VALUE) ((VALUE) < 0x20)
N
N/**
N  * @}
N  */ 
N
N /** @defgroup RTC_Calib_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
N#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
N                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) ||                                       ((OUTPUT) == RTC_CalibOutput_1Hz))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_period_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
N                                                             period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 8s, else 2exp18 RTCCLK seconds */
N#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
X#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_16sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
N                                          
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
N                                                                during a X -second window = Y - CALM[8:0]. 
N                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
N                                                                 during a 32-second window =   CALM[8:0]. */
N#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
N                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
X#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) ||                                          ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
N  * @{
N  */ 
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_DayLightSaving_Definitions 
N  * @{
N  */ 
N#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
N#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
N#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) || \
N                                      ((SAVE) == RTC_DayLightSaving_ADD1H))
X#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) ||                                       ((SAVE) == RTC_DayLightSaving_ADD1H))
N
N#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
N#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
N                                           ((OPERATION) == RTC_StoreOperation_Set))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) ||                                            ((OPERATION) == RTC_StoreOperation_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Trigger_Definitions 
N  * @{
N  */ 
N#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
N#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_FallingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_LowLevel) ||                                         ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Filter_Definitions 
N  * @{
N  */ 
N#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */
N
N#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
N                                                          consecutive samples at the active leve. */
N#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
N                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_8Sample))
X#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) ||                                       ((FILTER) == RTC_TamperFilter_2Sample) ||                                       ((FILTER) == RTC_TamperFilter_4Sample) ||                                       ((FILTER) == RTC_TamperFilter_8Sample))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
N  * @{
N  */ 
N#define RTC_TamperSamplingFreq_RTCCLK_Div32768  ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 32768 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div16384  ((uint32_t)0x000000100) /*!< Each of the tamper inputs are sampled
N                                                                            with a frequency =  RTCCLK / 16384 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div8192   ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 8192  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div4096   ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 4096  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div2048   ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 2048  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div1024   ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 1024  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div512    ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 512   */
N#define RTC_TamperSamplingFreq_RTCCLK_Div256    ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
N                                                                           with a frequency =  RTCCLK / 256   */
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
N
N/**
N  * @}
N  */
N
N  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
N  * @{
N  */ 
N#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Tamper_Pins_Definitions 
N  * @{
N  */ 
N#define RTC_Tamper_1            RTC_TAFCR_TAMP1E /*!< Tamper detection enable for 
N                                                      input tamper 1 */
N#define RTC_Tamper_2            RTC_TAFCR_TAMP2E /*!< Tamper detection enable for 
N                                                      input tamper 2 */
N#define RTC_Tamper_3            RTC_TAFCR_TAMP3E /*!< Tamper detection enable for 
N                                                      input tamper 3 */
N
N#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & (uint32_t)0xFFFFFFD6) == 0x00) && ((TAMPER) != (uint32_t)RESET))
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_Type_ALARM_OUT 
N  * @{
N  */ 
N#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
N#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
N                                  ((TYPE) == RTC_OutputType_PushPull))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) ||                                   ((TYPE) == RTC_OutputType_PushPull))
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Add_1_Second_Parameter_Definitions
N  * @{
N  */ 
N#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
N#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
N                                 ((SEL) == RTC_ShiftAdd1S_Set))
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) ||                                  ((SEL) == RTC_ShiftAdd1S_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Substract_Fraction_Of_Second_Value
N  * @{
N  */ 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)
N
N/**
N  * @}
N  */
N  
N/** @defgroup RTC_Backup_Registers_Definitions 
N  * @{
N  */
N
N#define RTC_BKP_DR0                       ((uint32_t)0x00000000)
N#define RTC_BKP_DR1                       ((uint32_t)0x00000001)
N#define RTC_BKP_DR2                       ((uint32_t)0x00000002)
N#define RTC_BKP_DR3                       ((uint32_t)0x00000003)
N#define RTC_BKP_DR4                       ((uint32_t)0x00000004)
N#define RTC_BKP_DR5                       ((uint32_t)0x00000005)
N#define RTC_BKP_DR6                       ((uint32_t)0x00000006)
N#define RTC_BKP_DR7                       ((uint32_t)0x00000007)
N#define RTC_BKP_DR8                       ((uint32_t)0x00000008)
N#define RTC_BKP_DR9                       ((uint32_t)0x00000009)
N#define RTC_BKP_DR10                      ((uint32_t)0x0000000A)
N#define RTC_BKP_DR11                      ((uint32_t)0x0000000B)
N#define RTC_BKP_DR12                      ((uint32_t)0x0000000C)
N#define RTC_BKP_DR13                      ((uint32_t)0x0000000D)
N#define RTC_BKP_DR14                      ((uint32_t)0x0000000E)
N#define RTC_BKP_DR15                      ((uint32_t)0x0000000F)
N#define RTC_BKP_DR16                      ((uint32_t)0x00000010)
N#define RTC_BKP_DR17                      ((uint32_t)0x00000011)
N#define RTC_BKP_DR18                      ((uint32_t)0x00000012)
N#define RTC_BKP_DR19                      ((uint32_t)0x00000013)
N#define RTC_BKP_DR20                      ((uint32_t)0x00000014)
N#define RTC_BKP_DR21                      ((uint32_t)0x00000015)
N#define RTC_BKP_DR22                      ((uint32_t)0x00000016)
N#define RTC_BKP_DR23                      ((uint32_t)0x00000017)
N#define RTC_BKP_DR24                      ((uint32_t)0x00000018)
N#define RTC_BKP_DR25                      ((uint32_t)0x00000019)
N#define RTC_BKP_DR26                      ((uint32_t)0x0000001A)
N#define RTC_BKP_DR27                      ((uint32_t)0x0000001B)
N#define RTC_BKP_DR28                      ((uint32_t)0x0000001C)
N#define RTC_BKP_DR29                      ((uint32_t)0x0000001D)
N#define RTC_BKP_DR30                      ((uint32_t)0x0000001E)
N#define RTC_BKP_DR31                      ((uint32_t)0x0000001F)
N#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) || \
N                                           ((BKP) == RTC_BKP_DR1) || \
N                                           ((BKP) == RTC_BKP_DR2) || \
N                                           ((BKP) == RTC_BKP_DR3) || \
N                                           ((BKP) == RTC_BKP_DR4) || \
N                                           ((BKP) == RTC_BKP_DR5) || \
N                                           ((BKP) == RTC_BKP_DR6) || \
N                                           ((BKP) == RTC_BKP_DR7) || \
N                                           ((BKP) == RTC_BKP_DR8) || \
N                                           ((BKP) == RTC_BKP_DR9) || \
N                                           ((BKP) == RTC_BKP_DR10) || \
N                                           ((BKP) == RTC_BKP_DR11) || \
N                                           ((BKP) == RTC_BKP_DR12) || \
N                                           ((BKP) == RTC_BKP_DR13) || \
N                                           ((BKP) == RTC_BKP_DR14) || \
N                                           ((BKP) == RTC_BKP_DR15) || \
N                                           ((BKP) == RTC_BKP_DR16) || \
N                                           ((BKP) == RTC_BKP_DR17) || \
N                                           ((BKP) == RTC_BKP_DR18) || \
N                                           ((BKP) == RTC_BKP_DR19) || \
N                                           ((BKP) == RTC_BKP_DR20) || \
N                                           ((BKP) == RTC_BKP_DR21) || \
N                                           ((BKP) == RTC_BKP_DR22) || \
N                                           ((BKP) == RTC_BKP_DR23) || \
N                                           ((BKP) == RTC_BKP_DR24) || \
N                                           ((BKP) == RTC_BKP_DR25) || \
N                                           ((BKP) == RTC_BKP_DR26) || \
N                                           ((BKP) == RTC_BKP_DR27) || \
N                                           ((BKP) == RTC_BKP_DR28) || \
N                                           ((BKP) == RTC_BKP_DR29) || \
N                                           ((BKP) == RTC_BKP_DR30) || \
N                                           ((BKP) == RTC_BKP_DR31))
X#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) ||                                            ((BKP) == RTC_BKP_DR1) ||                                            ((BKP) == RTC_BKP_DR2) ||                                            ((BKP) == RTC_BKP_DR3) ||                                            ((BKP) == RTC_BKP_DR4) ||                                            ((BKP) == RTC_BKP_DR5) ||                                            ((BKP) == RTC_BKP_DR6) ||                                            ((BKP) == RTC_BKP_DR7) ||                                            ((BKP) == RTC_BKP_DR8) ||                                            ((BKP) == RTC_BKP_DR9) ||                                            ((BKP) == RTC_BKP_DR10) ||                                            ((BKP) == RTC_BKP_DR11) ||                                            ((BKP) == RTC_BKP_DR12) ||                                            ((BKP) == RTC_BKP_DR13) ||                                            ((BKP) == RTC_BKP_DR14) ||                                            ((BKP) == RTC_BKP_DR15) ||                                            ((BKP) == RTC_BKP_DR16) ||                                            ((BKP) == RTC_BKP_DR17) ||                                            ((BKP) == RTC_BKP_DR18) ||                                            ((BKP) == RTC_BKP_DR19) ||                                            ((BKP) == RTC_BKP_DR20) ||                                            ((BKP) == RTC_BKP_DR21) ||                                            ((BKP) == RTC_BKP_DR22) ||                                            ((BKP) == RTC_BKP_DR23) ||                                            ((BKP) == RTC_BKP_DR24) ||                                            ((BKP) == RTC_BKP_DR25) ||                                            ((BKP) == RTC_BKP_DR26) ||                                            ((BKP) == RTC_BKP_DR27) ||                                            ((BKP) == RTC_BKP_DR28) ||                                            ((BKP) == RTC_BKP_DR29) ||                                            ((BKP) == RTC_BKP_DR30) ||                                            ((BKP) == RTC_BKP_DR31))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Input_parameter_format_definitions 
N  * @{
N  */ 
N#define RTC_Format_BIN                    ((uint32_t)0x000000000)
N#define RTC_Format_BCD                    ((uint32_t)0x000000001)
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Flags_Definitions 
N  * @{
N  */ 
N#define RTC_FLAG_RECALPF                  ((uint32_t)0x00010000)
N#define RTC_FLAG_TAMP3F                   ((uint32_t)0x00008000)
N#define RTC_FLAG_TAMP2F                   ((uint32_t)0x00004000)
N#define RTC_FLAG_TAMP1F                   ((uint32_t)0x00002000)
N#define RTC_FLAG_TSOVF                    ((uint32_t)0x00001000)
N#define RTC_FLAG_TSF                      ((uint32_t)0x00000800)
N#define RTC_FLAG_WUTF                     ((uint32_t)0x00000400)
N#define RTC_FLAG_ALRBF                    ((uint32_t)0x00000200)
N#define RTC_FLAG_ALRAF                    ((uint32_t)0x00000100)
N#define RTC_FLAG_INITF                    ((uint32_t)0x00000040)
N#define RTC_FLAG_RSF                      ((uint32_t)0x00000020)
N#define RTC_FLAG_INITS                    ((uint32_t)0x00000010)
N#define RTC_FLAG_SHPF                     ((uint32_t)0x00000008)
N#define RTC_FLAG_WUTWF                    ((uint32_t)0x00000004)
N#define RTC_FLAG_ALRBWF                   ((uint32_t)0x00000002)
N#define RTC_FLAG_ALRAWF                   ((uint32_t)0x00000001)
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) || \
N                               ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) || \
N                               ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) || \
N                               ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) || \
N                               ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) || \
N                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F) || \
N                                ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) || \
N                                ((FLAG) == RTC_FLAG_SHPF))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) ||                                ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) ||                                ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) ||                                ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) ||                                ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) ||                                ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F) ||                                 ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) ||                                 ((FLAG) == RTC_FLAG_SHPF))
N#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Interrupts_Definitions 
N  * @{
N  */ 
N#define RTC_IT_TS                         ((uint32_t)0x00008000)
N#define RTC_IT_WUT                        ((uint32_t)0x00004000)
N#define RTC_IT_ALRB                       ((uint32_t)0x00002000)
N#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
N#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)
N#define RTC_IT_TAMP2                      ((uint32_t)0x00040000)
N#define RTC_IT_TAMP3                      ((uint32_t)0x00080000)
N
N
N#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_WUT) || \
N                           ((IT) == RTC_IT_ALRB)  || ((IT) == RTC_IT_ALRA) || \
N                           ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2) || \
N                           ((IT) == RTC_IT_TAMP3))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_WUT) ||                            ((IT) == RTC_IT_ALRB)  || ((IT) == RTC_IT_ALRA) ||                            ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2) ||                            ((IT) == RTC_IT_TAMP3))
N#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFF10FFF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Legacy 
N  * @{
N  */ 
N#define RTC_DigitalCalibConfig  RTC_CoarseCalibConfig
N#define RTC_DigitalCalibCmd     RTC_CoarseCalibCmd
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the RTC configuration to the default reset state *****/ 
NErrorStatus RTC_DeInit(void);
N
N
N/* Initialization and Configuration functions *********************************/ 
NErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_WriteProtectionCmd(FunctionalState NewState);
NErrorStatus RTC_EnterInitMode(void);
Nvoid RTC_ExitInitMode(void);
NErrorStatus RTC_WaitForSynchro(void);
NErrorStatus RTC_RefClockCmd(FunctionalState NewState);
Nvoid RTC_BypassShadowCmd(FunctionalState NewState);
N
N/* Time and Date configuration functions **************************************/ 
NErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nuint32_t RTC_GetSubSecond(void);
NErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
N
N/* Alarms (Alarm A and Alarm B) configuration functions  **********************/ 
Nvoid RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
NErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
Nvoid RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask);
Nuint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);
N
N/* WakeUp Timer configuration functions ***************************************/ 
Nvoid RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
Nvoid RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
Nuint32_t RTC_GetWakeUpCounter(void);
NErrorStatus RTC_WakeUpCmd(FunctionalState NewState);
N
N/* Daylight Saving configuration functions ************************************/ 
Nvoid RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
Nuint32_t RTC_GetStoreOperation(void);
N
N/* Output pin Configuration function ******************************************/ 
Nvoid RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);
N
N/* Coarse and Smooth Calibration configuration functions **********************/
NErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value);
NErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
NErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
N                                  uint32_t RTC_SmoothCalibPlusPulses,
N                                  uint32_t RTC_SmouthCalibMinusPulsesValue);
N
N/* TimeStamp configuration functions ******************************************/ 
Nvoid RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
Nvoid RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
N                                      RTC_DateTypeDef* RTC_StampDateStruct);
Nuint32_t RTC_GetTimeStampSubSecond(void);
N
N/* Tampers configuration functions ********************************************/ 
Nvoid RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
Nvoid RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
Nvoid RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
Nvoid RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
Nvoid RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
Nvoid RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
Nvoid RTC_TamperPullUpCmd(FunctionalState NewState);
N
N/* Backup Data Registers configuration functions ******************************/ 
Nvoid RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
Nuint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR);
N
N/* Output Type Config configuration functions *********************************/ 
Nvoid RTC_OutputTypeConfig(uint32_t RTC_OutputType);
N
N/* RTC_Shift_control_synchonisation_functions *********************************/
NErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);
N
N/* Interrupts and flags management functions **********************************/ 
Nvoid RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
NFlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
Nvoid RTC_ClearFlag(uint32_t RTC_FLAG);
NITStatus RTC_GetITStatus(uint32_t RTC_IT);
Nvoid RTC_ClearITPendingBit(uint32_t RTC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_RTC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 52 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_sdio.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_sdio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_sdio.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the SDIO firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_SDIO_H
N#define __STM32L1xx_SDIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SDIO
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
N                                           This parameter can be a value of @ref SDIO_Clock_Edge */
N
N  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
N                                           enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Clock_Bypass */
N
N  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
N                                           disabled when the bus is idle.
N                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */
N
N  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
N                                           This parameter can be a value of @ref SDIO_Bus_Wide */
N
N  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
N                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */
N
N  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
N                                           This parameter can be a value between 0x00 and 0xFF. */
N
N} SDIO_InitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
N                                to a card as part of a command message. If a command
N                                contains an argument, it must be loaded into this register
N                                before writing the command to the command register */
N
N  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */
N
N  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
N                                This parameter can be a value of @ref SDIO_Response_Type */
N
N  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait-for-interrupt request is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */
N
N  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
N                                is enabled or disabled.
N                                This parameter can be a value of @ref SDIO_CPSM_State */
N} SDIO_CmdInitTypeDef;
N
Ntypedef struct
N{
N  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */
N
N  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
N 
N  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
N                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
N 
N  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
N                                     is a read or write.
N                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
N 
N  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
N                                     This parameter can be a value of @ref SDIO_Transfer_Type */
N 
N  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
N                                     is enabled or disabled.
N                                     This parameter can be a value of @ref SDIO_DPSM_State */
N} SDIO_DataInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SDIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup SDIO_Clock_Edge 
N  * @{
N  */
N
N#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
N#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
N#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
N                                  ((EDGE) == SDIO_ClockEdge_Falling))
X#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) ||                                   ((EDGE) == SDIO_ClockEdge_Falling))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Clock_Bypass 
N  * @{
N  */
N
N#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
N#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
N#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
N                                     ((BYPASS) == SDIO_ClockBypass_Enable))
X#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) ||                                      ((BYPASS) == SDIO_ClockBypass_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Clock_Power_Save 
N  * @{
N  */
N
N#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
N#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
N#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
N                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
X#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) ||                                         ((SAVE) == SDIO_ClockPowerSave_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Bus_Wide 
N  * @{
N  */
N
N#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
N#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
N#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
N#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
N                                ((WIDE) == SDIO_BusWide_8b))
X#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) ||                                 ((WIDE) == SDIO_BusWide_8b))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Hardware_Flow_Control 
N  * @{
N  */
N
N#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
N#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
N#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
N                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
X#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) ||                                                 ((CONTROL) == SDIO_HardwareFlowControl_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Power_State 
N  * @{
N  */
N
N#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
N#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
N#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON)) 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SDIO_Interrupt_soucres 
N  * @{
N  */
N
N#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
N#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
N#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
N#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
N#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
N#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
N#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
N#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
N#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
N#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
N#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
N#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
N#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
N#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
N#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
N#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
N#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
N#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
N#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
N#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
N#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
N#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
N#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
N#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
N#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Command_Index
N  * @{
N  */
N
N#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Response_Type 
N  * @{
N  */
N
N#define SDIO_Response_No                    ((uint32_t)0x00000000)
N#define SDIO_Response_Short                 ((uint32_t)0x00000040)
N#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
N#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
N                                    ((RESPONSE) == SDIO_Response_Short) || \
N                                    ((RESPONSE) == SDIO_Response_Long))
X#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) ||                                     ((RESPONSE) == SDIO_Response_Short) ||                                     ((RESPONSE) == SDIO_Response_Long))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Wait_Interrupt_State 
N  * @{
N  */
N
N#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
N#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
N#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
N#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
N                            ((WAIT) == SDIO_Wait_Pend))
X#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) ||                             ((WAIT) == SDIO_Wait_Pend))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_CPSM_State 
N  * @{
N  */
N
N#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
N#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDIO_Response_Registers 
N  * @{
N  */
N
N#define SDIO_RESP1                          ((uint32_t)0x00000000)
N#define SDIO_RESP2                          ((uint32_t)0x00000004)
N#define SDIO_RESP3                          ((uint32_t)0x00000008)
N#define SDIO_RESP4                          ((uint32_t)0x0000000C)
N#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
N                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
X#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) ||                             ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Length 
N  * @{
N  */
N
N#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Data_Block_Size 
N  * @{
N  */
N
N#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
N#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
N#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
N#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
N#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
N#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
N#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
N#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
N#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
N#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
N#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
N#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
N#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
N#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
N#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
N#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
X#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) ||                                   ((SIZE) == SDIO_DataBlockSize_2b) ||                                   ((SIZE) == SDIO_DataBlockSize_4b) ||                                   ((SIZE) == SDIO_DataBlockSize_8b) ||                                   ((SIZE) == SDIO_DataBlockSize_16b) ||                                   ((SIZE) == SDIO_DataBlockSize_32b) ||                                   ((SIZE) == SDIO_DataBlockSize_64b) ||                                   ((SIZE) == SDIO_DataBlockSize_128b) ||                                   ((SIZE) == SDIO_DataBlockSize_256b) ||                                   ((SIZE) == SDIO_DataBlockSize_512b) ||                                   ((SIZE) == SDIO_DataBlockSize_1024b) ||                                   ((SIZE) == SDIO_DataBlockSize_2048b) ||                                   ((SIZE) == SDIO_DataBlockSize_4096b) ||                                   ((SIZE) == SDIO_DataBlockSize_8192b) ||                                   ((SIZE) == SDIO_DataBlockSize_16384b)) 
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Direction 
N  * @{
N  */
N
N#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
N#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
N#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
N                                   ((DIR) == SDIO_TransferDir_ToSDIO))
X#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) ||                                    ((DIR) == SDIO_TransferDir_ToSDIO))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Transfer_Type 
N  * @{
N  */
N
N#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
N#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
N#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
N                                     ((MODE) == SDIO_TransferMode_Block))
X#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) ||                                      ((MODE) == SDIO_TransferMode_Block))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_DPSM_State 
N  * @{
N  */
N
N#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
N#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
N#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Flags 
N  * @{
N  */
N
N#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
N#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
N#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
N#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
N#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
N#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
N#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
N#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
N#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
N#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
N#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
N#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
N#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
N#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
N#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
N#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
N#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
N#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
N#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
N#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
N#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
N#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
N#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
N#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
N#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
N                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
N                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
N                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
N                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
N                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXACT) || \
N                            ((FLAG)  == SDIO_FLAG_RXACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
N                            ((FLAG)  == SDIO_FLAG_CEATAEND))
X#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_DCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_CTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_DTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_TXUNDERR) ||                             ((FLAG)  == SDIO_FLAG_RXOVERR) ||                             ((FLAG)  == SDIO_FLAG_CMDREND) ||                             ((FLAG)  == SDIO_FLAG_CMDSENT) ||                             ((FLAG)  == SDIO_FLAG_DATAEND) ||                             ((FLAG)  == SDIO_FLAG_STBITERR) ||                             ((FLAG)  == SDIO_FLAG_DBCKEND) ||                             ((FLAG)  == SDIO_FLAG_CMDACT) ||                             ((FLAG)  == SDIO_FLAG_TXACT) ||                             ((FLAG)  == SDIO_FLAG_RXACT) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOHE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOHF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_TXDAVL) ||                             ((FLAG)  == SDIO_FLAG_RXDAVL) ||                             ((FLAG)  == SDIO_FLAG_SDIOIT) ||                             ((FLAG)  == SDIO_FLAG_CEATAEND))
N
N#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))
N
N#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
N                            ((IT)  == SDIO_IT_DCRCFAIL) || \
N                            ((IT)  == SDIO_IT_CTIMEOUT) || \
N                            ((IT)  == SDIO_IT_DTIMEOUT) || \
N                            ((IT)  == SDIO_IT_TXUNDERR) || \
N                            ((IT)  == SDIO_IT_RXOVERR) || \
N                            ((IT)  == SDIO_IT_CMDREND) || \
N                            ((IT)  == SDIO_IT_CMDSENT) || \
N                            ((IT)  == SDIO_IT_DATAEND) || \
N                            ((IT)  == SDIO_IT_STBITERR) || \
N                            ((IT)  == SDIO_IT_DBCKEND) || \
N                            ((IT)  == SDIO_IT_CMDACT) || \
N                            ((IT)  == SDIO_IT_TXACT) || \
N                            ((IT)  == SDIO_IT_RXACT) || \
N                            ((IT)  == SDIO_IT_TXFIFOHE) || \
N                            ((IT)  == SDIO_IT_RXFIFOHF) || \
N                            ((IT)  == SDIO_IT_TXFIFOF) || \
N                            ((IT)  == SDIO_IT_RXFIFOF) || \
N                            ((IT)  == SDIO_IT_TXFIFOE) || \
N                            ((IT)  == SDIO_IT_RXFIFOE) || \
N                            ((IT)  == SDIO_IT_TXDAVL) || \
N                            ((IT)  == SDIO_IT_RXDAVL) || \
N                            ((IT)  == SDIO_IT_SDIOIT) || \
N                            ((IT)  == SDIO_IT_CEATAEND))
X#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) ||                             ((IT)  == SDIO_IT_DCRCFAIL) ||                             ((IT)  == SDIO_IT_CTIMEOUT) ||                             ((IT)  == SDIO_IT_DTIMEOUT) ||                             ((IT)  == SDIO_IT_TXUNDERR) ||                             ((IT)  == SDIO_IT_RXOVERR) ||                             ((IT)  == SDIO_IT_CMDREND) ||                             ((IT)  == SDIO_IT_CMDSENT) ||                             ((IT)  == SDIO_IT_DATAEND) ||                             ((IT)  == SDIO_IT_STBITERR) ||                             ((IT)  == SDIO_IT_DBCKEND) ||                             ((IT)  == SDIO_IT_CMDACT) ||                             ((IT)  == SDIO_IT_TXACT) ||                             ((IT)  == SDIO_IT_RXACT) ||                             ((IT)  == SDIO_IT_TXFIFOHE) ||                             ((IT)  == SDIO_IT_RXFIFOHF) ||                             ((IT)  == SDIO_IT_TXFIFOF) ||                             ((IT)  == SDIO_IT_RXFIFOF) ||                             ((IT)  == SDIO_IT_TXFIFOE) ||                             ((IT)  == SDIO_IT_RXFIFOE) ||                             ((IT)  == SDIO_IT_TXDAVL) ||                             ((IT)  == SDIO_IT_RXDAVL) ||                             ((IT)  == SDIO_IT_SDIOIT) ||                             ((IT)  == SDIO_IT_CEATAEND))
N
N#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDIO_Read_Wait_Mode 
N  * @{
N  */
N
N#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
N#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
N#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
N                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
X#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) ||                                      ((MODE) == SDIO_ReadWaitMode_DATA2))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N/*  Function used to set the SDIO configuration to the default reset state ****/
Nvoid SDIO_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_ClockCmd(FunctionalState NewState);
Nvoid SDIO_SetPowerState(uint32_t SDIO_PowerState);
Nuint32_t SDIO_GetPowerState(void);
N
N/* DMA transfers management functions *****************************************/
Nvoid SDIO_DMACmd(FunctionalState NewState);
N
N/* Command path state machine (CPSM) management functions *********************/
Nvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
Nvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
Nuint8_t SDIO_GetCommandResponse(void);
Nuint32_t SDIO_GetResponse(uint32_t SDIO_RESP);
N
N/* Data path state machine (DPSM) management functions ************************/
Nvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nuint32_t SDIO_GetDataCounter(void);
Nuint32_t SDIO_ReadData(void);
Nvoid SDIO_WriteData(uint32_t Data);
Nuint32_t SDIO_GetFIFOCount(void);
N
N/* SDIO IO Cards mode management functions ************************************/
Nvoid SDIO_StartSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_StopSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
Nvoid SDIO_SetSDIOOperation(FunctionalState NewState);
Nvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
N
N/* CE-ATA mode management functions *******************************************/
Nvoid SDIO_CommandCompletionCmd(FunctionalState NewState);
Nvoid SDIO_CEATAITCmd(FunctionalState NewState);
Nvoid SDIO_SendCEATACmd(FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
NFlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
Nvoid SDIO_ClearFlag(uint32_t SDIO_FLAG);
NITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
Nvoid SDIO_ClearITPendingBit(uint32_t SDIO_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_SDIO_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 53 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_spi.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_spi.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the SPI 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_SPI_H
N#define __STM32L1xx_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  SPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_data_direction */
N
N  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
N                                         This parameter can be a value of @ref SPI_mode */
N
N  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
N                                         This parameter can be a value of @ref SPI_data_size */
N
N  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                         hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_Slave_Select_management */
N 
N  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                         used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                         @note The communication clock is derived from the master
N                                               clock. The slave clock does not need to be set. */
N
N  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
N}SPI_InitTypeDef;
N
N/** 
N  * @brief  I2S Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
N                                  This parameter can be a value of @ref SPI_I2S_Mode */
N
N  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Standard */
N
N  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Data_Format */
N
N  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                  This parameter can be a value of @ref SPI_I2S_MCLK_Output */
N
N  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Audio_Frequency */
N
N  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
N                                  This parameter can be a value of @ref SPI_I2S_Clock_Polarity */
N}I2S_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_Exported_Constants
N  * @{
N  */
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
N                                   ((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) ||                                    ((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3))
N#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3))
X#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3))
N
N/** @defgroup SPI_data_direction 
N  * @{
N  */
N  
N#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
N#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
N#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_mode 
N  * @{
N  */
N
N#define SPI_Mode_Master                 ((uint16_t)0x0104)
N#define SPI_Mode_Slave                  ((uint16_t)0x0000)
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_data_size 
N  * @{
N  */
N
N#define SPI_DataSize_16b                ((uint16_t)0x0800)
N#define SPI_DataSize_8b                 ((uint16_t)0x0000)
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
N                                   ((DATASIZE) == SPI_DataSize_8b))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) ||                                    ((DATASIZE) == SPI_DataSize_8b))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_Clock_Polarity 
N  * @{
N  */
N
N#define SPI_CPOL_Low                    ((uint16_t)0x0000)
N#define SPI_CPOL_High                   ((uint16_t)0x0002)
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase 
N  * @{
N  */
N
N#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
N#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management 
N  * @{
N  */
N
N#define SPI_NSS_Soft                    ((uint16_t)0x0200)
N#define SPI_NSS_Hard                    ((uint16_t)0x0000)
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_BaudRate_Prescaler 
N  * @{
N  */
N
N#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
N#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
N#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
N#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
N#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
N#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
N#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
N#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_MSB_LSB_transmission 
N  * @{
N  */
N
N#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
N#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Mode 
N  * @{
N  */
N
N#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
N#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
N#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
N#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx)|| \
N                           ((MODE) == I2S_Mode_MasterRx))
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx)||                            ((MODE) == I2S_Mode_MasterRx))
N/**
N  * @}
N  */
N  
N
N/** @defgroup SPI_I2S_Standard 
N  * @{
N  */
N
N#define I2S_Standard_Phillips           ((uint16_t)0x0000)
N#define I2S_Standard_MSB                ((uint16_t)0x0010)
N#define I2S_Standard_LSB                ((uint16_t)0x0020)
N#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
N#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_I2S_Data_Format 
N  * @{
N  */
N
N#define I2S_DataFormat_16b              ((uint16_t)0x0000)
N#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
N#define I2S_DataFormat_24b              ((uint16_t)0x0003)
N#define I2S_DataFormat_32b              ((uint16_t)0x0005)
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_MCLK_Output 
N  * @{
N  */
N
N#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
N#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Audio_Frequency 
N  * @{
N  */
N
N#define I2S_AudioFreq_192k               ((uint32_t)192000)
N#define I2S_AudioFreq_96k                ((uint32_t)96000)
N#define I2S_AudioFreq_48k                ((uint32_t)48000)
N#define I2S_AudioFreq_44k                ((uint32_t)44100)
N#define I2S_AudioFreq_32k                ((uint32_t)32000)
N#define I2S_AudioFreq_22k                ((uint32_t)22050)
N#define I2S_AudioFreq_16k                ((uint32_t)16000)
N#define I2S_AudioFreq_11k                ((uint32_t)11025)
N#define I2S_AudioFreq_8k                 ((uint32_t)8000)
N#define I2S_AudioFreq_Default            ((uint32_t)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
N                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) &&                                  ((FREQ) <= I2S_AudioFreq_192k)) ||                                  ((FREQ) == I2S_AudioFreq_Default))
N/**
N  * @}
N  */
N            
N/** @defgroup SPI_I2S_Clock_Polarity 
N  * @{
N  */
N
N#define I2S_CPOL_Low                    ((uint16_t)0x0000)
N#define I2S_CPOL_High                   ((uint16_t)0x0008)
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_DMA_transfer_requests 
N  * @{
N  */
N
N#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
N#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
N#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_NSS_internal_software_management 
N  * @{
N  */
N
N#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
N#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Transmit_Receive 
N  * @{
N  */
N
N#define SPI_CRC_Tx                      ((uint8_t)0x00)
N#define SPI_CRC_Rx                      ((uint8_t)0x01)
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_direction_transmit_receive 
N  * @{
N  */
N
N#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
N#define SPI_Direction_Tx                ((uint16_t)0x4000)
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_interrupts_definition 
N  * @{
N  */
N
N#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
N#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
N#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
N#define I2S_IT_UDR                      ((uint8_t)0x53)
N#define SPI_I2S_IT_FRE                  ((uint8_t)0x58)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                  ((IT) == SPI_I2S_IT_RXNE) || \
N                                  ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                   ((IT) == SPI_I2S_IT_RXNE) ||                                   ((IT) == SPI_I2S_IT_ERR))
N
N#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
N#define SPI_IT_MODF                     ((uint8_t)0x55)
N#define SPI_IT_CRCERR                   ((uint8_t)0x54)
N
N#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == SPI_IT_CRCERR)   || ((IT) == SPI_IT_MODF) || \
N                               ((IT) == SPI_I2S_IT_OVR)  || ((IT) == I2S_IT_UDR) ||\
N                               ((IT) == SPI_I2S_IT_FRE))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == SPI_IT_CRCERR)   || ((IT) == SPI_IT_MODF) ||                                ((IT) == SPI_I2S_IT_OVR)  || ((IT) == I2S_IT_UDR) ||                               ((IT) == SPI_I2S_IT_FRE))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_flags_definition 
N  * @{
N  */
N
N#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
N#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
N#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
N#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
N#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
N#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
N#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
N#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
N#define SPI_I2S_FLAG_FRE                ((uint16_t)0x0100)
N
N#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
N                                   ((FLAG) == SPI_I2S_FLAG_FRE))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)||                                    ((FLAG) == SPI_I2S_FLAG_FRE))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_polynomial 
N  * @{
N  */
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Legacy 
N  * @{
N  */
N
N#define SPI_DMAReq_Tx                SPI_I2S_DMAReq_Tx
N#define SPI_DMAReq_Rx                SPI_I2S_DMAReq_Rx
N#define SPI_IT_TXE                   SPI_I2S_IT_TXE
N#define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
N#define SPI_IT_ERR                   SPI_I2S_IT_ERR
N#define SPI_IT_OVR                   SPI_I2S_IT_OVR
N#define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
N#define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
N#define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
N#define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
N#define SPI_DeInit                   SPI_I2S_DeInit
N#define SPI_ITConfig                 SPI_I2S_ITConfig
N#define SPI_DMACmd                   SPI_I2S_DMACmd
N#define SPI_SendData                 SPI_I2S_SendData
N#define SPI_ReceiveData              SPI_I2S_ReceiveData
N#define SPI_GetFlagStatus            SPI_I2S_GetFlagStatus
N#define SPI_ClearFlag                SPI_I2S_ClearFlag
N#define SPI_GetITStatus              SPI_I2S_GetITStatus
N#define SPI_ClearITPendingBit        SPI_I2S_ClearITPendingBit
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the SPI configuration to the default reset state *****/ 
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/ 
Nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
Nuint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
N
N/* Hardware CRC Calculation functions *****************************************/
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
Nuint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
N
N/* DMA transfers management functions *****************************************/
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
Nvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_SPI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 54 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_syscfg.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_syscfg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_syscfg.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the SYSCFG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/*!< Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_SYSCFG_H
N#define __STM32L1xx_SYSCFG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SYSCFG
N  * @{
N  */ 
N  
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SYSCFG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup EXTI_Port_Sources 
N  * @{
N  */ 
N#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
N#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
N#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
N#define EXTI_PortSourceGPIOD       ((uint8_t)0x03)
N#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
N#define EXTI_PortSourceGPIOH       ((uint8_t)0x05)
N#define EXTI_PortSourceGPIOF       ((uint8_t)0x06)
N#define EXTI_PortSourceGPIOG       ((uint8_t)0x07)
N                                      
N#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOG) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOH)) 
X#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOB) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOC) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOD) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOE) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOF) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOG) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOH)) 
N/**
N  * @}
N  */
N
N/** @defgroup EXTI_Pin_sources 
N  * @{
N  */ 
N#define EXTI_PinSource0            ((uint8_t)0x00)
N#define EXTI_PinSource1            ((uint8_t)0x01)
N#define EXTI_PinSource2            ((uint8_t)0x02)
N#define EXTI_PinSource3            ((uint8_t)0x03)
N#define EXTI_PinSource4            ((uint8_t)0x04)
N#define EXTI_PinSource5            ((uint8_t)0x05)
N#define EXTI_PinSource6            ((uint8_t)0x06)
N#define EXTI_PinSource7            ((uint8_t)0x07)
N#define EXTI_PinSource8            ((uint8_t)0x08)
N#define EXTI_PinSource9            ((uint8_t)0x09)
N#define EXTI_PinSource10           ((uint8_t)0x0A)
N#define EXTI_PinSource11           ((uint8_t)0x0B)
N#define EXTI_PinSource12           ((uint8_t)0x0C)
N#define EXTI_PinSource13           ((uint8_t)0x0D)
N#define EXTI_PinSource14           ((uint8_t)0x0E)
N#define EXTI_PinSource15           ((uint8_t)0x0F)
N#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) || \
N                                       ((PINSOURCE) == EXTI_PinSource1) || \
N                                       ((PINSOURCE) == EXTI_PinSource2) || \
N                                       ((PINSOURCE) == EXTI_PinSource3) || \
N                                       ((PINSOURCE) == EXTI_PinSource4) || \
N                                       ((PINSOURCE) == EXTI_PinSource5) || \
N                                       ((PINSOURCE) == EXTI_PinSource6) || \
N                                       ((PINSOURCE) == EXTI_PinSource7) || \
N                                       ((PINSOURCE) == EXTI_PinSource8) || \
N                                       ((PINSOURCE) == EXTI_PinSource9) || \
N                                       ((PINSOURCE) == EXTI_PinSource10) || \
N                                       ((PINSOURCE) == EXTI_PinSource11) || \
N                                       ((PINSOURCE) == EXTI_PinSource12) || \
N                                       ((PINSOURCE) == EXTI_PinSource13) || \
N                                       ((PINSOURCE) == EXTI_PinSource14) || \
N                                       ((PINSOURCE) == EXTI_PinSource15))
X#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) ||                                        ((PINSOURCE) == EXTI_PinSource1) ||                                        ((PINSOURCE) == EXTI_PinSource2) ||                                        ((PINSOURCE) == EXTI_PinSource3) ||                                        ((PINSOURCE) == EXTI_PinSource4) ||                                        ((PINSOURCE) == EXTI_PinSource5) ||                                        ((PINSOURCE) == EXTI_PinSource6) ||                                        ((PINSOURCE) == EXTI_PinSource7) ||                                        ((PINSOURCE) == EXTI_PinSource8) ||                                        ((PINSOURCE) == EXTI_PinSource9) ||                                        ((PINSOURCE) == EXTI_PinSource10) ||                                        ((PINSOURCE) == EXTI_PinSource11) ||                                        ((PINSOURCE) == EXTI_PinSource12) ||                                        ((PINSOURCE) == EXTI_PinSource13) ||                                        ((PINSOURCE) == EXTI_PinSource14) ||                                        ((PINSOURCE) == EXTI_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_Memory_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_MemoryRemap_Flash       ((uint8_t)0x00)
N#define SYSCFG_MemoryRemap_SystemFlash ((uint8_t)0x01)
N#define SYSCFG_MemoryRemap_FSMC        ((uint8_t)0x02)
N#define SYSCFG_MemoryRemap_SRAM        ((uint8_t)0x03)
N   
N#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_FSMC) || \
N                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM))
X#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) ||                                                ((REMAP) == SYSCFG_MemoryRemap_FSMC) ||                                                ((REMAP) == SYSCFG_MemoryRemap_SRAM))
N
N/**
N  * @}
N  */
N  
N/** @defgroup RI_Resistor
N  * @{
N  */
N
N#define RI_Resistor_10KPU              COMP_CSR_10KPU
N#define RI_Resistor_400KPU             COMP_CSR_400KPU
N#define RI_Resistor_10KPD              COMP_CSR_10KPD
N#define RI_Resistor_400KPD             COMP_CSR_400KPD
N
N#define IS_RI_RESISTOR(RESISTOR)  (((RESISTOR) == COMP_CSR_10KPU) || \
N                                   ((RESISTOR) == COMP_CSR_400KPU) || \
N                                   ((RESISTOR) == COMP_CSR_10KPD) || \
N                                   ((RESISTOR) == COMP_CSR_400KPD))
X#define IS_RI_RESISTOR(RESISTOR)  (((RESISTOR) == COMP_CSR_10KPU) ||                                    ((RESISTOR) == COMP_CSR_400KPU) ||                                    ((RESISTOR) == COMP_CSR_10KPD) ||                                    ((RESISTOR) == COMP_CSR_400KPD))
N 
N/**
N  * @}
N  */ 
N
N/** @defgroup RI_Channel
N  * @{
N  */
N
N#define RI_Channel_3                   ((uint32_t)0x04000000)
N#define RI_Channel_8                   ((uint32_t)0x08000000)
N#define RI_Channel_13                  ((uint32_t)0x10000000)
N
N#define IS_RI_CHANNEL(CHANNEL)  (((CHANNEL) == RI_Channel_3) || \
N                                 ((CHANNEL) == RI_Channel_8) || \
N                                 ((CHANNEL) == RI_Channel_13))
X#define IS_RI_CHANNEL(CHANNEL)  (((CHANNEL) == RI_Channel_3) ||                                  ((CHANNEL) == RI_Channel_8) ||                                  ((CHANNEL) == RI_Channel_13))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RI_ChannelSpeed
N  * @{
N  */
N
N#define RI_ChannelSpeed_Fast           ((uint32_t)0x00000000)
N#define RI_ChannelSpeed_Slow           ((uint32_t)0x00000001)
N
N#define IS_RI_CHANNELSPEED(SPEED)  (((SPEED) == RI_ChannelSpeed_Fast) || \
N                                    ((SPEED) == RI_ChannelSpeed_Slow))
X#define IS_RI_CHANNELSPEED(SPEED)  (((SPEED) == RI_ChannelSpeed_Fast) ||                                     ((SPEED) == RI_ChannelSpeed_Slow))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RI_InputCapture
N  * @{
N  */ 
N  
N#define RI_InputCapture_IC1  RI_ICR_IC1    /*!< Input Capture 1 */
N#define RI_InputCapture_IC2  RI_ICR_IC2    /*!< Input Capture 2 */
N#define RI_InputCapture_IC3  RI_ICR_IC3    /*!< Input Capture 3 */
N#define RI_InputCapture_IC4  RI_ICR_IC4    /*!< Input Capture 4 */
N
N#define IS_RI_INPUTCAPTURE(INPUTCAPTURE) ((((INPUTCAPTURE) & (uint32_t)0xFFC2FFFF) == 0x00) && ((INPUTCAPTURE) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N  
N/** @defgroup TIM_Select
N  * @{
N  */ 
N  
N#define TIM_Select_None  ((uint32_t)0x00000000)    /*!< None selected */
N#define TIM_Select_TIM2  ((uint32_t)0x00010000)    /*!< Timer 2 selected */
N#define TIM_Select_TIM3  ((uint32_t)0x00020000)    /*!< Timer 3 selected */
N#define TIM_Select_TIM4  ((uint32_t)0x00030000)    /*!< Timer 4 selected */
N
N#define IS_RI_TIM(TIM) (((TIM) == TIM_Select_None) || \
N                        ((TIM) == TIM_Select_TIM2) || \
N                        ((TIM) == TIM_Select_TIM3) || \
N                        ((TIM) == TIM_Select_TIM4))
X#define IS_RI_TIM(TIM) (((TIM) == TIM_Select_None) ||                         ((TIM) == TIM_Select_TIM2) ||                         ((TIM) == TIM_Select_TIM3) ||                         ((TIM) == TIM_Select_TIM4))
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup RI_InputCaptureRouting
N  * @{
N  */ 
N                                                          /* TIMx_IC1 TIMx_IC2  TIMx_IC3  TIMx_IC4 */  
N#define RI_InputCaptureRouting_0   ((uint32_t)0x00000000) /* PA0       PA1      PA2       PA3      */
N#define RI_InputCaptureRouting_1   ((uint32_t)0x00000001) /* PA4       PA5      PA6       PA7      */
N#define RI_InputCaptureRouting_2   ((uint32_t)0x00000002) /* PA8       PA9      PA10      PA11     */
N#define RI_InputCaptureRouting_3   ((uint32_t)0x00000003) /* PA12      PA13     PA14      PA15     */
N#define RI_InputCaptureRouting_4   ((uint32_t)0x00000004) /* PC0       PC1      PC2       PC3      */
N#define RI_InputCaptureRouting_5   ((uint32_t)0x00000005) /* PC4       PC5      PC6       PC7      */
N#define RI_InputCaptureRouting_6   ((uint32_t)0x00000006) /* PC8       PC9      PC10      PC11     */
N#define RI_InputCaptureRouting_7   ((uint32_t)0x00000007) /* PC12      PC13     PC14      PC15     */
N#define RI_InputCaptureRouting_8   ((uint32_t)0x00000008) /* PD0       PD1      PD2       PD3      */
N#define RI_InputCaptureRouting_9   ((uint32_t)0x00000009) /* PD4       PD5      PD6       PD7      */
N#define RI_InputCaptureRouting_10  ((uint32_t)0x0000000A) /* PD8       PD9      PD10      PD11     */
N#define RI_InputCaptureRouting_11  ((uint32_t)0x0000000B) /* PD12      PD13     PD14      PD15     */
N#define RI_InputCaptureRouting_12  ((uint32_t)0x0000000C) /* PE0       PE1      PE2       PE3      */
N#define RI_InputCaptureRouting_13  ((uint32_t)0x0000000D) /* PE4       PE5      PE6       PE7      */
N#define RI_InputCaptureRouting_14  ((uint32_t)0x0000000E) /* PE8       PE9      PE10      PE11     */
N#define RI_InputCaptureRouting_15  ((uint32_t)0x0000000F) /* PE12      PE13     PE14      PE15     */
N
N#define IS_RI_INPUTCAPTURE_ROUTING(ROUTING) (((ROUTING) == RI_InputCaptureRouting_0) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_1) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_2) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_3) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_4) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_5) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_6) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_7) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_8) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_9) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_10) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_11) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_12) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_13) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_14) || \
N                                             ((ROUTING) == RI_InputCaptureRouting_15))
X#define IS_RI_INPUTCAPTURE_ROUTING(ROUTING) (((ROUTING) == RI_InputCaptureRouting_0) ||                                              ((ROUTING) == RI_InputCaptureRouting_1) ||                                              ((ROUTING) == RI_InputCaptureRouting_2) ||                                              ((ROUTING) == RI_InputCaptureRouting_3) ||                                              ((ROUTING) == RI_InputCaptureRouting_4) ||                                              ((ROUTING) == RI_InputCaptureRouting_5) ||                                              ((ROUTING) == RI_InputCaptureRouting_6) ||                                              ((ROUTING) == RI_InputCaptureRouting_7) ||                                              ((ROUTING) == RI_InputCaptureRouting_8) ||                                              ((ROUTING) == RI_InputCaptureRouting_9) ||                                              ((ROUTING) == RI_InputCaptureRouting_10) ||                                              ((ROUTING) == RI_InputCaptureRouting_11) ||                                              ((ROUTING) == RI_InputCaptureRouting_12) ||                                              ((ROUTING) == RI_InputCaptureRouting_13) ||                                              ((ROUTING) == RI_InputCaptureRouting_14) ||                                              ((ROUTING) == RI_InputCaptureRouting_15))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RI_IOSwitch
N  * @{
N  */ 
N  
N/* ASCR1 I/O switch: bit 31 is set to '1' to indicate that the mask is in ASCR1 register */
N#define RI_IOSwitch_CH0        ((uint32_t)0x80000001)
N#define RI_IOSwitch_CH1        ((uint32_t)0x80000002)
N#define RI_IOSwitch_CH2        ((uint32_t)0x80000004)
N#define RI_IOSwitch_CH3        ((uint32_t)0x80000008)
N#define RI_IOSwitch_CH4        ((uint32_t)0x80000010)
N#define RI_IOSwitch_CH5        ((uint32_t)0x80000020)
N#define RI_IOSwitch_CH6        ((uint32_t)0x80000040)
N#define RI_IOSwitch_CH7        ((uint32_t)0x80000080)
N#define RI_IOSwitch_CH8        ((uint32_t)0x80000100)
N#define RI_IOSwitch_CH9        ((uint32_t)0x80000200)
N#define RI_IOSwitch_CH10       ((uint32_t)0x80000400)
N#define RI_IOSwitch_CH11       ((uint32_t)0x80000800)
N#define RI_IOSwitch_CH12       ((uint32_t)0x80001000)
N#define RI_IOSwitch_CH13       ((uint32_t)0x80002000)
N#define RI_IOSwitch_CH14       ((uint32_t)0x80004000)
N#define RI_IOSwitch_CH15       ((uint32_t)0x80008000)
N#define RI_IOSwitch_CH31       ((uint32_t)0x80010000)
N#define RI_IOSwitch_CH18       ((uint32_t)0x80040000)
N#define RI_IOSwitch_CH19       ((uint32_t)0x80080000)
N#define RI_IOSwitch_CH20       ((uint32_t)0x80100000)
N#define RI_IOSwitch_CH21       ((uint32_t)0x80200000)
N#define RI_IOSwitch_CH22       ((uint32_t)0x80400000)
N#define RI_IOSwitch_CH23       ((uint32_t)0x80800000)
N#define RI_IOSwitch_CH24       ((uint32_t)0x81000000)
N#define RI_IOSwitch_CH25       ((uint32_t)0x82000000)
N#define RI_IOSwitch_VCOMP      ((uint32_t)0x84000000) /* VCOMP is an internal switch used to connect 
N                                                         selected channel to COMP1 non inverting input */
N#define RI_IOSwitch_CH27       ((uint32_t)0x88000000)
N#define RI_IOSwitch_CH28       ((uint32_t)0x90000000)
N#define RI_IOSwitch_CH29       ((uint32_t)0xA0000000)
N#define RI_IOSwitch_CH30       ((uint32_t)0xC0000000)
N
N/* ASCR2 IO switch: bit 31 is set to '0' to indicate that the mask is in ASCR2 register */  
N#define RI_IOSwitch_GR10_1     ((uint32_t)0x00000001)
N#define RI_IOSwitch_GR10_2     ((uint32_t)0x00000002)
N#define RI_IOSwitch_GR10_3     ((uint32_t)0x00000004)
N#define RI_IOSwitch_GR10_4     ((uint32_t)0x00000008)
N#define RI_IOSwitch_GR6_1      ((uint32_t)0x00000010)
N#define RI_IOSwitch_GR6_2      ((uint32_t)0x00000020)
N#define RI_IOSwitch_GR5_1      ((uint32_t)0x00000040)
N#define RI_IOSwitch_GR5_2      ((uint32_t)0x00000080)
N#define RI_IOSwitch_GR5_3      ((uint32_t)0x00000100)
N#define RI_IOSwitch_GR4_1      ((uint32_t)0x00000200)
N#define RI_IOSwitch_GR4_2      ((uint32_t)0x00000400)
N#define RI_IOSwitch_GR4_3      ((uint32_t)0x00000800)
N#define RI_IOSwitch_GR4_4      ((uint32_t)0x00008000)
N#define RI_IOSwitch_CH0b       ((uint32_t)0x00010000)
N#define RI_IOSwitch_CH1b       ((uint32_t)0x00020000)
N#define RI_IOSwitch_CH2b       ((uint32_t)0x00040000)
N#define RI_IOSwitch_CH3b       ((uint32_t)0x00080000)
N#define RI_IOSwitch_CH6b       ((uint32_t)0x00100000)
N#define RI_IOSwitch_CH7b       ((uint32_t)0x00200000)
N#define RI_IOSwitch_CH8b       ((uint32_t)0x00400000)
N#define RI_IOSwitch_CH9b       ((uint32_t)0x00800000)
N#define RI_IOSwitch_CH10b      ((uint32_t)0x01000000)
N#define RI_IOSwitch_CH11b      ((uint32_t)0x02000000)
N#define RI_IOSwitch_CH12b      ((uint32_t)0x04000000)
N#define RI_IOSwitch_GR6_3      ((uint32_t)0x08000000)
N#define RI_IOSwitch_GR6_4      ((uint32_t)0x10000000)
N#define RI_IOSwitch_GR5_4      ((uint32_t)0x20000000)
N
N
N#define IS_RI_IOSWITCH(IOSWITCH) (((IOSWITCH) == RI_IOSwitch_CH0) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH1) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH2) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH3) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH4) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH5) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH6) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH7) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH8) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH9) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH10) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH11) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH12) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH13) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH14) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH15) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH18) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH19) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH20) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH21) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH22) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH23) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH24) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH25) || \
N                                  ((IOSWITCH) == RI_IOSwitch_VCOMP) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH27) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH28) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH29) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH30) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH31) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR10_1) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR10_2) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR10_3) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR10_4) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR6_1) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR6_2) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR6_3) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR6_4) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR5_1) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR5_2) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR5_3) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR5_4) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR4_1) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR4_2) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR4_3) || \
N                                  ((IOSWITCH) == RI_IOSwitch_GR4_4) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH0b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH1b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH2b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH3b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH6b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH7b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH8b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH9b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH10b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH11b) || \
N                                  ((IOSWITCH) == RI_IOSwitch_CH12b))
X#define IS_RI_IOSWITCH(IOSWITCH) (((IOSWITCH) == RI_IOSwitch_CH0) ||                                   ((IOSWITCH) == RI_IOSwitch_CH1) ||                                   ((IOSWITCH) == RI_IOSwitch_CH2) ||                                   ((IOSWITCH) == RI_IOSwitch_CH3) ||                                   ((IOSWITCH) == RI_IOSwitch_CH4) ||                                   ((IOSWITCH) == RI_IOSwitch_CH5) ||                                   ((IOSWITCH) == RI_IOSwitch_CH6) ||                                   ((IOSWITCH) == RI_IOSwitch_CH7) ||                                   ((IOSWITCH) == RI_IOSwitch_CH8) ||                                   ((IOSWITCH) == RI_IOSwitch_CH9) ||                                   ((IOSWITCH) == RI_IOSwitch_CH10) ||                                   ((IOSWITCH) == RI_IOSwitch_CH11) ||                                   ((IOSWITCH) == RI_IOSwitch_CH12) ||                                   ((IOSWITCH) == RI_IOSwitch_CH13) ||                                   ((IOSWITCH) == RI_IOSwitch_CH14) ||                                   ((IOSWITCH) == RI_IOSwitch_CH15) ||                                   ((IOSWITCH) == RI_IOSwitch_CH18) ||                                   ((IOSWITCH) == RI_IOSwitch_CH19) ||                                   ((IOSWITCH) == RI_IOSwitch_CH20) ||                                   ((IOSWITCH) == RI_IOSwitch_CH21) ||                                   ((IOSWITCH) == RI_IOSwitch_CH22) ||                                   ((IOSWITCH) == RI_IOSwitch_CH23) ||                                   ((IOSWITCH) == RI_IOSwitch_CH24) ||                                   ((IOSWITCH) == RI_IOSwitch_CH25) ||                                   ((IOSWITCH) == RI_IOSwitch_VCOMP) ||                                   ((IOSWITCH) == RI_IOSwitch_CH27) ||                                   ((IOSWITCH) == RI_IOSwitch_CH28) ||                                   ((IOSWITCH) == RI_IOSwitch_CH29) ||                                   ((IOSWITCH) == RI_IOSwitch_CH30) ||                                   ((IOSWITCH) == RI_IOSwitch_CH31) ||                                   ((IOSWITCH) == RI_IOSwitch_GR10_1) ||                                   ((IOSWITCH) == RI_IOSwitch_GR10_2) ||                                   ((IOSWITCH) == RI_IOSwitch_GR10_3) ||                                   ((IOSWITCH) == RI_IOSwitch_GR10_4) ||                                   ((IOSWITCH) == RI_IOSwitch_GR6_1) ||                                   ((IOSWITCH) == RI_IOSwitch_GR6_2) ||                                   ((IOSWITCH) == RI_IOSwitch_GR6_3) ||                                   ((IOSWITCH) == RI_IOSwitch_GR6_4) ||                                   ((IOSWITCH) == RI_IOSwitch_GR5_1) ||                                   ((IOSWITCH) == RI_IOSwitch_GR5_2) ||                                   ((IOSWITCH) == RI_IOSwitch_GR5_3) ||                                   ((IOSWITCH) == RI_IOSwitch_GR5_4) ||                                   ((IOSWITCH) == RI_IOSwitch_GR4_1) ||                                   ((IOSWITCH) == RI_IOSwitch_GR4_2) ||                                   ((IOSWITCH) == RI_IOSwitch_GR4_3) ||                                   ((IOSWITCH) == RI_IOSwitch_GR4_4) ||                                   ((IOSWITCH) == RI_IOSwitch_CH0b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH1b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH2b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH3b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH6b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH7b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH8b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH9b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH10b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH11b) ||                                   ((IOSWITCH) == RI_IOSwitch_CH12b))
N
N/**
N  * @}
N  */
N
N/** @defgroup RI_Port
N  * @{
N  */
N
N#define RI_PortA                 ((uint8_t)0x01)   /*!< GPIOA selected */
N#define RI_PortB                 ((uint8_t)0x02)   /*!< GPIOB selected */
N#define RI_PortC                 ((uint8_t)0x03)   /*!< GPIOC selected */
N#define RI_PortD                 ((uint8_t)0x04)   /*!< GPIOD selected */
N#define RI_PortE                 ((uint8_t)0x05)   /*!< GPIOE selected */
N#define RI_PortF                 ((uint8_t)0x06)   /*!< GPIOF selected */
N#define RI_PortG                 ((uint8_t)0x07)   /*!< GPIOG selected */
N
N#define IS_RI_PORT(PORT) (((PORT) == RI_PortA) || \
N                          ((PORT) == RI_PortB) || \
N                          ((PORT) == RI_PortC) || \
N                          ((PORT) == RI_PortD) || \
N                          ((PORT) == RI_PortE) || \
N                          ((PORT) == RI_PortF) || \
N                          ((PORT) == RI_PortG))
X#define IS_RI_PORT(PORT) (((PORT) == RI_PortA) ||                           ((PORT) == RI_PortB) ||                           ((PORT) == RI_PortC) ||                           ((PORT) == RI_PortD) ||                           ((PORT) == RI_PortE) ||                           ((PORT) == RI_PortF) ||                           ((PORT) == RI_PortG))
N/**
N  * @}
N  */
N
N/** @defgroup RI_Pin define 
N  * @{
N  */
N#define RI_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */
N#define RI_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */
N#define RI_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */
N#define RI_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */
N#define RI_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */
N#define RI_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */
N#define RI_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */
N#define RI_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */
N#define RI_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */
N#define RI_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
N#define RI_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
N#define RI_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */
N#define RI_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */
N#define RI_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */
N#define RI_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */
N#define RI_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */
N#define RI_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
N
N#define IS_RI_PIN(PIN) ((PIN) != (uint16_t)0x00)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the SYSCFG and RI configuration to the default reset state **/
Nvoid SYSCFG_DeInit(void);
Nvoid SYSCFG_RIDeInit(void);
N
N/* SYSCFG Initialization and Configuration functions **************************/ 
Nvoid SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap);
Nuint32_t SYSCFG_GetBootMode(void);
Nvoid SYSCFG_USBPuCmd(FunctionalState NewState);
Nvoid SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
N
N/* RI Initialization and Configuration functions ******************************/ 
Nvoid SYSCFG_RITIMSelect(uint32_t TIM_Select);
Nvoid SYSCFG_RITIMInputCaptureConfig(uint32_t RI_InputCapture, uint32_t RI_InputCaptureRouting);
Nvoid SYSCFG_RIResistorConfig(uint32_t RI_Resistor, FunctionalState NewState);
Nvoid SYSCFG_RIChannelSpeedConfig(uint32_t RI_Channel, uint32_t RI_ChannelSpeed);
Nvoid SYSCFG_RISwitchControlModeCmd(FunctionalState NewState);
Nvoid SYSCFG_RIIOSwitchConfig(uint32_t RI_IOSwitch, FunctionalState NewState);
Nvoid SYSCFG_RIHysteresisConfig(uint8_t RI_Port, uint16_t RI_Pin, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_SYSCFG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 55 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_tim.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_tim.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the TIM firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_TIM_H
N#define __STM32L1xx_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  TIM Time Base Init structure definition
N  * @note   This structure is used with all TIMx except for TIM6 and TIM7.    
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N} TIM_TimeBaseInitTypeDef;       
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_state */
N
N  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N  
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM4) || \
N                                   ((PERIPH) == TIM5) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM9) || \
N                                   ((PERIPH) == TIM10) || \
N                                   ((PERIPH) == TIM11))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM4) ||                                    ((PERIPH) == TIM5) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM9) ||                                    ((PERIPH) == TIM10) ||                                    ((PERIPH) == TIM11))
N
N/* LIST1: TIM2, TIM3, TIM4, TIM5, TIM9, TIM10 and TIM11 */
N#define IS_TIM_LIST1_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM9) || \
N                                     ((PERIPH) == TIM10) || \
N                                     ((PERIPH) == TIM11))
X#define IS_TIM_LIST1_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM9) ||                                      ((PERIPH) == TIM10) ||                                      ((PERIPH) == TIM11))
N
N/* LIST3: TIM2, TIM3, TIM4 and TIM5 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5))
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5))
N
N/* LIST2: TIM2, TIM3, TIM4, TIM5 and TIM9 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM9))
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM9))
N
N/* LIST5: TIM2, TIM3, TIM4, TIM5, TIM6, TIM7 and TIM9 */
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) ||\
N                                     ((PERIPH) == TIM6) || \
N                                     ((PERIPH) == TIM7) ||\
N                                     ((PERIPH) == TIM9))
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                     ((PERIPH) == TIM6) ||                                      ((PERIPH) == TIM7) ||                                     ((PERIPH) == TIM9))
N
N/* LIST4: TIM2, TIM3, TIM4, TIM5, TIM6 and TIM7 */
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) ||\
N                                     ((PERIPH) == TIM6) || \
N                                     ((PERIPH) == TIM7))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                     ((PERIPH) == TIM6) ||                                      ((PERIPH) == TIM7))
N
N/* LIST6: TIM2, TIM3, TIM9, TIM10 and TIM11 */
N#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM9) || \
N                                     ((PERIPH) == TIM10) || \
N                                     ((PERIPH) == TIM11))
X#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM9) ||                                      ((PERIPH) == TIM10) ||                                      ((PERIPH) == TIM11))
N
N
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N                                 
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N
N/** @defgroup TIM_Output_Compare_state
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Capture_Compare_state 
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                      ((POLARITY) == TIM_ICPolarity_BothEdge))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling)||                                       ((POLARITY) == TIM_ICPolarity_BothEdge))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFFA0) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_Trigger))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_Trigger))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define TIM_DMABase_OR                     ((uint16_t)0x0013)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_DCR) || \
N                               ((BASE) == TIM_DMABase_OR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_DCR) ||                                ((BASE) == TIM_DMABase_OR))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFFA0) == 0x0000) && ((SOURCE) != 0x0000))                                          
N   
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N  
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OCReferenceClear 
N  * @{
N  */
N#define TIM_OCReferenceClear_ETRF          ((uint16_t)0x0008)
N#define TIM_OCReferenceClear_OCREFCLR      ((uint16_t)0x0000)
N#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) || \
N                                              ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
X#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) ||                                               ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Remap 
N  * @{
N  */
N
N#define TIM2_TIM10_OC                      ((uint32_t)0xFFFE0000)
N#define TIM2_TIM5_TRGO                     ((uint32_t)0xFFFE0001)
N
N#define TIM3_TIM11_OC                      ((uint32_t)0xFFFE0000)
N#define TIM3_TIM5_TRGO                     ((uint32_t)0xFFFE0001)
N
N#define TIM9_GPIO                          ((uint32_t)0xFFFC0000)
N#define TIM9_LSE                           ((uint32_t)0xFFFC0001)
N
N#define TIM9_TIM3_TRGO                     ((uint32_t)0xFFFB0000)
N#define TIM9_TS_IO                         ((uint32_t)0xFFFB0004)
N
N#define TIM10_GPIO                         ((uint32_t)0xFFF40000)
N#define TIM10_LSI                          ((uint32_t)0xFFF40001)
N#define TIM10_LSE                          ((uint32_t)0xFFF40002)
N#define TIM10_RTC                          ((uint32_t)0xFFF40003)
N#define TIM10_RI                           ((uint32_t)0xFFF40008)
N
N#define TIM10_ETR_LSE                      ((uint32_t)0xFFFB0000)
N#define TIM10_ETR_TIM9_TRGO                ((uint32_t)0xFFFB0004)
N
N#define TIM11_GPIO                         ((uint32_t)0xFFF40000)
N#define TIM11_MSI                          ((uint32_t)0xFFF40001)
N#define TIM11_HSE_RTC                      ((uint32_t)0xFFF40002)
N#define TIM11_RI                           ((uint32_t)0xFFF40008)
N
N#define TIM11_ETR_LSE                      ((uint32_t)0xFFFB0000)
N#define TIM11_ETR_TIM9_TRGO                ((uint32_t)0xFFFB0004)
N
N#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM2_TIM10_OC)|| \
N                                  ((TIM_REMAP) == TIM2_TIM5_TRGO)|| \
N                                  ((TIM_REMAP) == TIM3_TIM11_OC)|| \
N                                  ((TIM_REMAP) == TIM3_TIM5_TRGO)|| \
N                                  ((TIM_REMAP) == TIM9_GPIO)|| \
N                                  ((TIM_REMAP) == TIM9_LSE)|| \
N                                  ((TIM_REMAP) == TIM9_TIM3_TRGO)|| \
N                                  ((TIM_REMAP) == TIM9_TS_IO)|| \
N                                  ((TIM_REMAP) == TIM10_GPIO)|| \
N                                  ((TIM_REMAP) == TIM10_LSI)|| \
N                                  ((TIM_REMAP) == TIM10_LSE)|| \
N                                  ((TIM_REMAP) == TIM10_RTC)|| \
N                                  ((TIM_REMAP) == TIM10_RI)|| \
N                                  ((TIM_REMAP) == TIM10_ETR_LSE)|| \
N                                  ((TIM_REMAP) == TIM10_ETR_TIM9_TRGO)|| \
N                                  ((TIM_REMAP) == TIM11_GPIO)|| \
N                                  ((TIM_REMAP) == TIM11_MSI)|| \
N                                  ((TIM_REMAP) == TIM11_HSE_RTC)|| \
N                                  ((TIM_REMAP) == TIM11_RI)|| \
N                                  ((TIM_REMAP) == TIM11_ETR_LSE)|| \
N                                  ((TIM_REMAP) == TIM11_ETR_TIM9_TRGO))
X#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM2_TIM10_OC)||                                   ((TIM_REMAP) == TIM2_TIM5_TRGO)||                                   ((TIM_REMAP) == TIM3_TIM11_OC)||                                   ((TIM_REMAP) == TIM3_TIM5_TRGO)||                                   ((TIM_REMAP) == TIM9_GPIO)||                                   ((TIM_REMAP) == TIM9_LSE)||                                   ((TIM_REMAP) == TIM9_TIM3_TRGO)||                                   ((TIM_REMAP) == TIM9_TS_IO)||                                   ((TIM_REMAP) == TIM10_GPIO)||                                   ((TIM_REMAP) == TIM10_LSI)||                                   ((TIM_REMAP) == TIM10_LSE)||                                   ((TIM_REMAP) == TIM10_RTC)||                                   ((TIM_REMAP) == TIM10_RI)||                                   ((TIM_REMAP) == TIM10_ETR_LSE)||                                   ((TIM_REMAP) == TIM10_ETR_TIM9_TRGO)||                                   ((TIM_REMAP) == TIM11_GPIO)||                                   ((TIM_REMAP) == TIM11_MSI)||                                   ((TIM_REMAP) == TIM11_HSE_RTC)||                                   ((TIM_REMAP) == TIM11_RI)||                                   ((TIM_REMAP) == TIM11_ETR_LSE)||                                   ((TIM_REMAP) == TIM11_ETR_TIM9_TRGO))
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/* TimeBase management ********************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Output Compare management **************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
N
N/* Input Capture management ***************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
N
N/* Interrupts, DMA and flags management ***************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Clocks management **********************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
N
N
N/* Synchronization management *************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
N
N/* Specific interface management **********************************************/                   
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Specific remapping management **********************************************/
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint32_t TIM_Remap);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_TIM_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 56 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_usart.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_usart.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the USART 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_USART_H
N#define __STM32L1xx_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup USART
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/ 
N
N/** 
N  * @brief  USART Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                            - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (USART_InitStruct->USART_BaudRate)))
N                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 8 * (OVR8+1)) + 0.5 
N                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */
N
N  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_Word_Length */
N
N  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint16_t USART_Parity;              /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
N} USART_InitTypeDef;
N
N/** 
N  * @brief  USART Clock Init Structure definition  
N  */ 
N  
Ntypedef struct
N{
N
N  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
N                               This parameter can be a value of @ref USART_Clock */
N
N  uint16_t USART_CPOL;    /*!< Specifies the steady state of the serial clock.
N                               This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
N                               This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                               This parameter can be a value of @ref USART_Last_Bit */
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup USART_Exported_Constants
N  * @{
N  */ 
N  
N#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3) || \
N                                     ((PERIPH) == UART4) || \
N                                     ((PERIPH) == UART5))
X#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3) ||                                      ((PERIPH) == UART4) ||                                      ((PERIPH) == UART5))
N
N#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3))
X#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3))
N
N/** @defgroup USART_Word_Length 
N  * @{
N  */ 
N  
N#define USART_WordLength_8b                  ((uint16_t)0x0000)
N#define USART_WordLength_9b                  ((uint16_t)0x1000)
N                                    
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Stop_Bits 
N  * @{
N  */ 
N  
N#define USART_StopBits_1                     ((uint16_t)0x0000)
N#define USART_StopBits_0_5                   ((uint16_t)0x1000)
N#define USART_StopBits_2                     ((uint16_t)0x2000)
N#define USART_StopBits_1_5                   ((uint16_t)0x3000)
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_0_5) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_0_5) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Parity 
N  * @{
N  */ 
N  
N#define USART_Parity_No                      ((uint16_t)0x0000)
N#define USART_Parity_Even                    ((uint16_t)0x0400)
N#define USART_Parity_Odd                     ((uint16_t)0x0600) 
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Mode 
N  * @{
N  */ 
N  
N#define USART_Mode_Rx                        ((uint16_t)0x0004)
N#define USART_Mode_Tx                        ((uint16_t)0x0008)
N#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Hardware_Flow_Control 
N  * @{
N  */ 
N#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
N#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
N#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
N#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock 
N  * @{
N  */ 
N#define USART_Clock_Disable                  ((uint16_t)0x0000)
N#define USART_Clock_Enable                   ((uint16_t)0x0800)
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Polarity 
N  * @{
N  */
N  
N#define USART_CPOL_Low                       ((uint16_t)0x0000)
N#define USART_CPOL_High                      ((uint16_t)0x0400)
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Phase
N  * @{
N  */
N
N#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
N#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit
N  * @{
N  */
N
N#define USART_LastBit_Disable                ((uint16_t)0x0000)
N#define USART_LastBit_Enable                 ((uint16_t)0x0100)
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Interrupt_definition 
N  * @{
N  */
N  
N#define USART_IT_PE                          ((uint16_t)0x0028)
N#define USART_IT_TXE                         ((uint16_t)0x0727)
N#define USART_IT_TC                          ((uint16_t)0x0626)
N#define USART_IT_RXNE                        ((uint16_t)0x0525)
N#define USART_IT_IDLE                        ((uint16_t)0x0424)
N#define USART_IT_LBD                         ((uint16_t)0x0846)
N#define USART_IT_ORE_RX                      ((uint16_t)0x0325) /* In case interrupt is generated if the RXNEIE bit is set */
N#define USART_IT_CTS                         ((uint16_t)0x096A)
N#define USART_IT_ERR                         ((uint16_t)0x0060)
N#define USART_IT_ORE_ER                      ((uint16_t)0x0360) /* In case interrupt is generated if the EIE bit is set */
N#define USART_IT_NE                          ((uint16_t)0x0260)
N#define USART_IT_FE                          ((uint16_t)0x0160)
N
N/** @defgroup USART_Legacy 
N  * @{
N  */
N#define USART_IT_ORE                          USART_IT_ORE_ER               
N/**
N  * @}
N  */
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                 ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                 ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                 ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
N#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE_RX) || \
N                             ((IT) == USART_IT_ORE_ER) || ((IT) == USART_IT_NE) || \
N                             ((IT) == USART_IT_FE))
X#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                              ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                              ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                              ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE_RX) ||                              ((IT) == USART_IT_ORE_ER) || ((IT) == USART_IT_NE) ||                              ((IT) == USART_IT_FE))
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
N/**
N  * @}
N  */
N
N/** @defgroup USART_DMA_Requests 
N  * @{
N  */
N
N#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
N#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_WakeUp_methods
N  * @{
N  */
N
N#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
N#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
N#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                 ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                  ((WAKEUP) == USART_WakeUp_AddressMark))
N/**
N  * @}
N  */
N
N/** @defgroup USART_LIN_Break_Detection_Length 
N  * @{
N  */
N  
N#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
N#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N/**
N  * @}
N  */
N
N/** @defgroup USART_IrDA_Low_Power 
N  * @{
N  */
N
N#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
N#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Flags 
N  * @{
N  */
N
N#define USART_FLAG_CTS                       ((uint16_t)0x0200)
N#define USART_FLAG_LBD                       ((uint16_t)0x0100)
N#define USART_FLAG_TXE                       ((uint16_t)0x0080)
N#define USART_FLAG_TC                        ((uint16_t)0x0040)
N#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
N#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
N#define USART_FLAG_ORE                       ((uint16_t)0x0008)
N#define USART_FLAG_NE                        ((uint16_t)0x0004)
N#define USART_FLAG_FE                        ((uint16_t)0x0002)
N#define USART_FLAG_PE                        ((uint16_t)0x0001)
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
N                              
N#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x003D0901))
N#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the USART configuration to the default reset state ***/ 
Nvoid USART_DeInit(USART_TypeDef* USARTx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
Nvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/ 
Nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
Nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);
N
N/* Multi-Processor Communication functions ************************************/
Nvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
Nvoid USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
Nvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* LIN mode functions *********************************************************/
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SendBreak(USART_TypeDef* USARTx);
N
N/* Half-duplex mode function **************************************************/
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Smartcard mode functions ***************************************************/
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
N
N/* IrDA mode functions ********************************************************/
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* DMA transfers management functions *****************************************/
Nvoid USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_USART_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 57 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "stm32l1xx_wwdg.h"
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32l1xx_wwdg.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the WWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32L1xx_WWDG_H
N#define __STM32L1xx_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup WWDG_Prescaler 
N  * @{
N  */ 
N  
N#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
N#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
N#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
N#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*  Function used to set the WWDG configuration to the default reset state ****/  
Nvoid WWDG_DeInit(void);
N
N/* Prescaler, Refresh window and Counter configuration functions **************/
Nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(uint8_t WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(uint8_t Counter);
N
N/* WWDG activation functions **************************************************/
Nvoid WWDG_Enable(uint8_t Counter);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1xx_WWDG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 58 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N#include "misc.h"  /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
L 1 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\misc.h" 1
N/**
N  ******************************************************************************
N  * @file    misc.h
N  * @author  MCD Application Team
N  * @version V1.2.0
N  * @date    22-February-2013
N  * @brief   This file contains all the functions prototypes for the miscellaneous
N  *          firmware library functions (add-on to CMSIS functions).
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __MISC_H
N#define __MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32l1xx.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
N                                                   This parameter can be a value of @ref IRQn_Type 
N                                                   (For the complete STM32 Devices IRQ Channels list, please
N                                                    refer to stm32l1xx.h file) */
N
N  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
N                                                   specified in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
N                                                   in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */
N
N  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                                   will be enabled or disabled. 
N                                                   This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N
N/**  
N  *
N@verbatim   
N The table below gives the allowed values of the pre-emption priority and subpriority according
N to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
N  ============================================================================================================================
N    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
N  ============================================================================================================================
N   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority
N                         |                                   |                             |   4 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
N                         |                                   |                             |   3 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority
N                         |                                   |                             |   2 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
N                         |                                   |                             |   1 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------    
N   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority
N                         |                                   |                             |   0 bits for subpriority                       
N  ============================================================================================================================
N@endverbatim
N*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup Vector_Table_Base 
N  * @{
N  */
N
N#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
N#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N/**
N  * @}
N  */
N
N/** @defgroup System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup Preemption_Priority_Group 
N  * @{
N  */
N
N#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
N                                                            4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
N                                                            3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
N                                                            2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
N                                                            1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
N                                                            0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x0005FFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
Nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __MISC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 59 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to expanse the "assert_param" macro in the 
N   Standard Peripheral Library drivers code */
N/* #define USE_FULL_ASSERT    1 */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function which reports 
S  *         the name of the source file and the source line number of the call 
S  *         that failed. If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#endif /* __STM32L1xx_CONF_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 6317 "..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\stm32l1xx.h" 2
N#endif
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32L1XX_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\Libraries\STM32L1xx_StdPeriph_Driver\inc\stm32l1xx_adc.h" 2
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup ADC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  ADC Init structure definition  
N  */
N  
Ntypedef struct
N{
N  uint32_t ADC_Resolution;                /*!< Selects the resolution of the conversion.
N                                               This parameter can be a value of @ref ADC_Resolution */
N  
N  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in
N                                               Scan (multichannel) or Single (one channel) mode.
N                                               This parameter can be set to ENABLE or DISABLE */
N  
N  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in
N                                               Continuous or Single mode.
N                                               This parameter can be set to ENABLE or DISABLE. */
N  
N  uint32_t ADC_ExternalTrigConvEdge;      /*!< Selects the external trigger Edge and enables the
N                                               trigger of a regular group. This parameter can be a value
N                                               of @ref ADC_external_trigger_edge_for_regular_channels_conversion */
N  
N  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog
N                                               to digital conversion of regular channels. This parameter
N                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
N  
N  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.
N                                               This parameter can be a value of @ref ADC_data_align */
N  
N  uint8_t  ADC_NbrOfConversion;           /*!< Specifies the number of ADC conversions that will be done
N                                               using the sequencer for regular channel group.
N                                               This parameter must range from 1 to 27. */
N}ADC_InitTypeDef;
N
Ntypedef struct 
N{                                              
N  uint32_t ADC_Prescaler;                 /*!< Selects the ADC prescaler.
N                                               This parameter can be a value 
N                                               of @ref ADC_Prescaler */
N}ADC_CommonInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup ADC_Exported_Constants
N  * @{
N  */ 
N#define IS_ADC_ALL_PERIPH(PERIPH)                  ((PERIPH) == ADC1)
N#define IS_ADC_DMA_PERIPH(PERIPH)                  ((PERIPH) == ADC1)
N
N/** @defgroup ADC_Power_down_during_Idle_and_or_Delay_phase 
N  * @{
N  */ 
N#define ADC_PowerDown_Delay                        ((uint32_t)0x00010000)
N#define ADC_PowerDown_Idle                         ((uint32_t)0x00020000)
N#define ADC_PowerDown_Idle_Delay                   ((uint32_t)0x00030000)
N
N#define IS_ADC_POWER_DOWN(DWON) (((DWON) == ADC_PowerDown_Delay) || \
N                                 ((DWON) == ADC_PowerDown_Idle) || \
N                                 ((DWON) == ADC_PowerDown_Idle_Delay))
X#define IS_ADC_POWER_DOWN(DWON) (((DWON) == ADC_PowerDown_Delay) ||                                  ((DWON) == ADC_PowerDown_Idle) ||                                  ((DWON) == ADC_PowerDown_Idle_Delay))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_Prescaler 
N  * @{
N  */ 
N#define ADC_Prescaler_Div1                         ((uint32_t)0x00000000)
N#define ADC_Prescaler_Div2                         ((uint32_t)0x00010000)
N#define ADC_Prescaler_Div4                         ((uint32_t)0x00020000)
N
N#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div1) || \
N                                     ((PRESCALER) == ADC_Prescaler_Div2) || \
N                                     ((PRESCALER) == ADC_Prescaler_Div4))
X#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div1) ||                                      ((PRESCALER) == ADC_Prescaler_Div2) ||                                      ((PRESCALER) == ADC_Prescaler_Div4))
N/**
N  * @}
N  */ 
N
N
N
N/** @defgroup ADC_Resolution 
N  * @{
N  */ 
N#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
N#define ADC_Resolution_10b                         ((uint32_t)0x01000000)
N#define ADC_Resolution_8b                          ((uint32_t)0x02000000)
N#define ADC_Resolution_6b                          ((uint32_t)0x03000000)
N
N#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
N                                       ((RESOLUTION) == ADC_Resolution_10b) || \
N                                       ((RESOLUTION) == ADC_Resolution_8b) || \
N                                       ((RESOLUTION) == ADC_Resolution_6b))
X#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) ||                                        ((RESOLUTION) == ADC_Resolution_10b) ||                                        ((RESOLUTION) == ADC_Resolution_8b) ||                                        ((RESOLUTION) == ADC_Resolution_6b))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_external_trigger_edge_for_regular_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigConvEdge_None              ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConvEdge_Rising            ((uint32_t)0x10000000)
N#define ADC_ExternalTrigConvEdge_Falling           ((uint32_t)0x20000000)
N#define ADC_ExternalTrigConvEdge_RisingFalling     ((uint32_t)0x30000000)
N
N#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
X#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Rising) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Falling) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion
N  * @{
N  */ 
N
N/* TIM2 */
N#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x02000000)
N#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x03000000)
N#define ADC_ExternalTrigConv_T2_TRGO               ((uint32_t)0x06000000)
N
N/* TIM3 */
N#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x07000000)
N#define ADC_ExternalTrigConv_T3_CC3                ((uint32_t)0x08000000)
N#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x04000000)
N
N/* TIM4 */
N#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x05000000)
N#define ADC_ExternalTrigConv_T4_TRGO               ((uint32_t)0x09000000)
N
N/* TIM6 */
N#define ADC_ExternalTrigConv_T6_TRGO               ((uint32_t)0x0A000000)
N
N/* TIM9 */
N#define ADC_ExternalTrigConv_T9_CC2                ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConv_T9_TRGO               ((uint32_t)0x01000000)
N
N/* EXTI */
N#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x0F000000)
N
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T9_CC2)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T9_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC3)  || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T6_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T9_CC2)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T9_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC3)  ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T6_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_data_align 
N  * @{
N  */ 
N  
N#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
N#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels 
N  * @{
N  */ 
N/* ADC Bank A Channels -------------------------------------------------------*/  
N#define ADC_Channel_0                              ((uint8_t)0x00)
N#define ADC_Channel_1                              ((uint8_t)0x01)
N#define ADC_Channel_2                              ((uint8_t)0x02)
N#define ADC_Channel_3                              ((uint8_t)0x03)
N
N#define ADC_Channel_6                              ((uint8_t)0x06)
N#define ADC_Channel_7                              ((uint8_t)0x07)
N#define ADC_Channel_8                              ((uint8_t)0x08)
N#define ADC_Channel_9                              ((uint8_t)0x09)
N#define ADC_Channel_10                             ((uint8_t)0x0A)
N#define ADC_Channel_11                             ((uint8_t)0x0B)
N#define ADC_Channel_12                             ((uint8_t)0x0C)
N
N
N/* ADC Bank B Channels -------------------------------------------------------*/  
N#define ADC_Channel_0b                             ADC_Channel_0
N#define ADC_Channel_1b                             ADC_Channel_1
N#define ADC_Channel_2b                             ADC_Channel_2
N#define ADC_Channel_3b                             ADC_Channel_3
N
N#define ADC_Channel_6b                             ADC_Channel_6
N#define ADC_Channel_7b                             ADC_Channel_7
N#define ADC_Channel_8b                             ADC_Channel_8
N#define ADC_Channel_9b                             ADC_Channel_9
N#define ADC_Channel_10b                            ADC_Channel_10
N#define ADC_Channel_11b                            ADC_Channel_11
N#define ADC_Channel_12b                            ADC_Channel_12
N
N/* ADC Common Channels (ADC Bank A and B) ------------------------------------*/
N#define ADC_Channel_4                              ((uint8_t)0x04)
N#define ADC_Channel_5                              ((uint8_t)0x05)
N
N#define ADC_Channel_13                             ((uint8_t)0x0D)
N#define ADC_Channel_14                             ((uint8_t)0x0E)
N#define ADC_Channel_15                             ((uint8_t)0x0F)
N#define ADC_Channel_16                             ((uint8_t)0x10)
N#define ADC_Channel_17                             ((uint8_t)0x11)
N#define ADC_Channel_18                             ((uint8_t)0x12)
N#define ADC_Channel_19                             ((uint8_t)0x13)
N#define ADC_Channel_20                             ((uint8_t)0x14)
N#define ADC_Channel_21                             ((uint8_t)0x15)
N#define ADC_Channel_22                             ((uint8_t)0x16)
N#define ADC_Channel_23                             ((uint8_t)0x17)
N#define ADC_Channel_24                             ((uint8_t)0x18)
N#define ADC_Channel_25                             ((uint8_t)0x19)
N
N#define ADC_Channel_27                             ((uint8_t)0x1B)
N#define ADC_Channel_28                             ((uint8_t)0x1C)
N#define ADC_Channel_29                             ((uint8_t)0x1D)
N#define ADC_Channel_30                             ((uint8_t)0x1E)
N#define ADC_Channel_31                             ((uint8_t)0x1F)
N
N#define ADC_Channel_TempSensor                     ((uint8_t)ADC_Channel_16)
N#define ADC_Channel_Vrefint                        ((uint8_t)ADC_Channel_17)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  || ((CHANNEL) == ADC_Channel_1)  || \
N                                 ((CHANNEL) == ADC_Channel_2)  || ((CHANNEL) == ADC_Channel_3)  || \
N                                 ((CHANNEL) == ADC_Channel_4)  || ((CHANNEL) == ADC_Channel_5)  || \
N                                 ((CHANNEL) == ADC_Channel_6)  || ((CHANNEL) == ADC_Channel_7)  || \
N                                 ((CHANNEL) == ADC_Channel_8)  || ((CHANNEL) == ADC_Channel_9)  || \
N                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17) || \
N                                 ((CHANNEL) == ADC_Channel_18) || ((CHANNEL) == ADC_Channel_19) || \
N                                 ((CHANNEL) == ADC_Channel_20) || ((CHANNEL) == ADC_Channel_21) || \
N                                 ((CHANNEL) == ADC_Channel_22) || ((CHANNEL) == ADC_Channel_23) || \
N                                 ((CHANNEL) == ADC_Channel_24) || ((CHANNEL) == ADC_Channel_25) || \
N                                 ((CHANNEL) == ADC_Channel_27) || ((CHANNEL) == ADC_Channel_28) || \
N                                 ((CHANNEL) == ADC_Channel_29) || ((CHANNEL) == ADC_Channel_30) || \
N                                 ((CHANNEL) == ADC_Channel_31))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  || ((CHANNEL) == ADC_Channel_1)  ||                                  ((CHANNEL) == ADC_Channel_2)  || ((CHANNEL) == ADC_Channel_3)  ||                                  ((CHANNEL) == ADC_Channel_4)  || ((CHANNEL) == ADC_Channel_5)  ||                                  ((CHANNEL) == ADC_Channel_6)  || ((CHANNEL) == ADC_Channel_7)  ||                                  ((CHANNEL) == ADC_Channel_8)  || ((CHANNEL) == ADC_Channel_9)  ||                                  ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17) ||                                  ((CHANNEL) == ADC_Channel_18) || ((CHANNEL) == ADC_Channel_19) ||                                  ((CHANNEL) == ADC_Channel_20) || ((CHANNEL) == ADC_Channel_21) ||                                  ((CHANNEL) == ADC_Channel_22) || ((CHANNEL) == ADC_Channel_23) ||                                  ((CHANNEL) == ADC_Channel_24) || ((CHANNEL) == ADC_Channel_25) ||                                  ((CHANNEL) == ADC_Channel_27) || ((CHANNEL) == ADC_Channel_28) ||                                  ((CHANNEL) == ADC_Channel_29) || ((CHANNEL) == ADC_Channel_30) ||                                  ((CHANNEL) == ADC_Channel_31))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_sampling_times 
N  * @{
N  */ 
N
N#define ADC_SampleTime_4Cycles                     ((uint8_t)0x00)
N#define ADC_SampleTime_9Cycles                     ((uint8_t)0x01)
N#define ADC_SampleTime_16Cycles                    ((uint8_t)0x02)
N#define ADC_SampleTime_24Cycles                    ((uint8_t)0x03)
N#define ADC_SampleTime_48Cycles                    ((uint8_t)0x04)
N#define ADC_SampleTime_96Cycles                    ((uint8_t)0x05)
N#define ADC_SampleTime_192Cycles                   ((uint8_t)0x06)
N#define ADC_SampleTime_384Cycles                   ((uint8_t)0x07)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_4Cycles)   || \
N                                  ((TIME) == ADC_SampleTime_9Cycles)   || \
N                                  ((TIME) == ADC_SampleTime_16Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_24Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_48Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_96Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_192Cycles) || \
N                                  ((TIME) == ADC_SampleTime_384Cycles))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_4Cycles)   ||                                   ((TIME) == ADC_SampleTime_9Cycles)   ||                                   ((TIME) == ADC_SampleTime_16Cycles)  ||                                   ((TIME) == ADC_SampleTime_24Cycles)  ||                                   ((TIME) == ADC_SampleTime_48Cycles)  ||                                   ((TIME) == ADC_SampleTime_96Cycles)  ||                                   ((TIME) == ADC_SampleTime_192Cycles) ||                                   ((TIME) == ADC_SampleTime_384Cycles))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Delay_length 
N  * @{
N  */ 
N
N#define ADC_DelayLength_None                       ((uint8_t)0x00)
N#define ADC_DelayLength_Freeze                     ((uint8_t)0x10)
N#define ADC_DelayLength_7Cycles                    ((uint8_t)0x20)
N#define ADC_DelayLength_15Cycles                   ((uint8_t)0x30)
N#define ADC_DelayLength_31Cycles                   ((uint8_t)0x40)
N#define ADC_DelayLength_63Cycles                   ((uint8_t)0x50)
N#define ADC_DelayLength_127Cycles                  ((uint8_t)0x60)
N#define ADC_DelayLength_255Cycles                  ((uint8_t)0x70)
N
N#define IS_ADC_DELAY_LENGTH(LENGTH) (((LENGTH) == ADC_DelayLength_None)      || \
N                                     ((LENGTH) == ADC_DelayLength_Freeze)    || \
N                                     ((LENGTH) == ADC_DelayLength_7Cycles)   || \
N                                     ((LENGTH) == ADC_DelayLength_15Cycles)  || \
N                                     ((LENGTH) == ADC_DelayLength_31Cycles)  || \
N                                     ((LENGTH) == ADC_DelayLength_63Cycles)  || \
N                                     ((LENGTH) == ADC_DelayLength_127Cycles) || \
N                                     ((LENGTH) == ADC_DelayLength_255Cycles))
X#define IS_ADC_DELAY_LENGTH(LENGTH) (((LENGTH) == ADC_DelayLength_None)      ||                                      ((LENGTH) == ADC_DelayLength_Freeze)    ||                                      ((LENGTH) == ADC_DelayLength_7Cycles)   ||                                      ((LENGTH) == ADC_DelayLength_15Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_31Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_63Cycles)  ||                                      ((LENGTH) == ADC_DelayLength_127Cycles) ||                                      ((LENGTH) == ADC_DelayLength_255Cycles))
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_external_trigger_edge_for_injected_channels_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigInjecConvEdge_None          ((uint32_t)0x00000000)
N#define ADC_ExternalTrigInjecConvEdge_Rising        ((uint32_t)0x00100000)
N#define ADC_ExternalTrigInjecConvEdge_Falling       ((uint32_t)0x00200000)
N#define ADC_ExternalTrigInjecConvEdge_RisingFalling ((uint32_t)0x00300000)
N
N#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None)    || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising)  || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) || \
N                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
X#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None)    ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising)  ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) ||                                           ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion 
N  * @{
N  */ 
N
N
N/* TIM2 */
N#define ADC_ExternalTrigInjecConv_T2_TRGO          ((uint32_t)0x00020000)
N#define ADC_ExternalTrigInjecConv_T2_CC1           ((uint32_t)0x00030000)
N
N/* TIM3 */
N#define ADC_ExternalTrigInjecConv_T3_CC4           ((uint32_t)0x00040000)
N
N/* TIM4 */
N#define ADC_ExternalTrigInjecConv_T4_TRGO          ((uint32_t)0x00050000)
N#define ADC_ExternalTrigInjecConv_T4_CC1           ((uint32_t)0x00060000)
N#define ADC_ExternalTrigInjecConv_T4_CC2           ((uint32_t)0x00070000)
N#define ADC_ExternalTrigInjecConv_T4_CC3           ((uint32_t)0x00080000)
N
N/* TIM7 */
N#define ADC_ExternalTrigInjecConv_T7_TRGO          ((uint32_t)0x000A0000)
N
N/* TIM9 */
N#define ADC_ExternalTrigInjecConv_T9_CC1           ((uint32_t)0x00000000)
N#define ADC_ExternalTrigInjecConv_T9_TRGO          ((uint32_t)0x00010000)
N
N/* TIM10 */
N#define ADC_ExternalTrigInjecConv_T10_CC1          ((uint32_t)0x00090000)
N
N/* EXTI */
N#define ADC_ExternalTrigInjecConv_Ext_IT15         ((uint32_t)0x000F0000)
N
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T9_CC1)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T9_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T10_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T7_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T9_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T9_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T10_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T7_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_injected_channel_selection 
N  * @{
N  */ 
N#define ADC_InjectedChannel_1                      ((uint8_t)0x18)
N#define ADC_InjectedChannel_2                      ((uint8_t)0x1C)
N#define ADC_InjectedChannel_3                      ((uint8_t)0x20)
N#define ADC_InjectedChannel_4                      ((uint8_t)0x24)
N
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_analog_watchdog_selection 
N  * @{
N  */ 
N  
N#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200) 
N#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
N#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
N
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable)        || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable)      || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable)           || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable)         || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable)   || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable)        ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable)      ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable)           ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable)         ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable)   ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_interrupts_definition 
N  * @{
N  */ 
N  
N#define ADC_IT_AWD                                 ((uint16_t)0x0106) 
N#define ADC_IT_EOC                                 ((uint16_t)0x0205) 
N#define ADC_IT_JEOC                                ((uint16_t)0x0407)  
N#define ADC_IT_OVR                                 ((uint16_t)0x201A) 
N 
N#define IS_ADC_IT(IT) (((IT) == ADC_IT_AWD) || ((IT) == ADC_IT_EOC) || \
N                       ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
X#define IS_ADC_IT(IT) (((IT) == ADC_IT_AWD) || ((IT) == ADC_IT_EOC) ||                        ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_flags_definition 
N  * @{
N  */ 
N  
N#define ADC_FLAG_AWD                               ((uint16_t)0x0001)
N#define ADC_FLAG_EOC                               ((uint16_t)0x0002)
N#define ADC_FLAG_JEOC                              ((uint16_t)0x0004)
N#define ADC_FLAG_JSTRT                             ((uint16_t)0x0008)
N#define ADC_FLAG_STRT                              ((uint16_t)0x0010)
N#define ADC_FLAG_OVR                               ((uint16_t)0x0020)
N#define ADC_FLAG_ADONS                             ((uint16_t)0x0040)
N#define ADC_FLAG_RCNR                              ((uint16_t)0x0100)
N#define ADC_FLAG_JCNR                              ((uint16_t)0x0200) 
N  
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFC0) == 0x00) && ((FLAG) != 0x00))
N   
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD)   || ((FLAG) == ADC_FLAG_EOC)  || \
N                               ((FLAG) == ADC_FLAG_JEOC)  || ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT)  || ((FLAG)== ADC_FLAG_OVR)   || \
N                               ((FLAG) == ADC_FLAG_ADONS) || ((FLAG)== ADC_FLAG_RCNR)  || \
N                               ((FLAG) == ADC_FLAG_JCNR))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD)   || ((FLAG) == ADC_FLAG_EOC)  ||                                ((FLAG) == ADC_FLAG_JEOC)  || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT)  || ((FLAG)== ADC_FLAG_OVR)   ||                                ((FLAG) == ADC_FLAG_ADONS) || ((FLAG)== ADC_FLAG_RCNR)  ||                                ((FLAG) == ADC_FLAG_JCNR))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_thresholds 
N  * @{
N  */ 
N  
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_injected_offset 
N  * @{
N  */
N   
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_injected_length 
N  * @{
N  */
N   
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_injected_rank 
N  * @{
N  */ 
N  
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_regular_length 
N  * @{
N  */
N   
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 1) && ((LENGTH) <= 28))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_regular_rank 
N  * @{
N  */ 
N  
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 1) && ((RANK) <= 28))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_regular_discontinuous_mode_number 
N  * @{
N  */
N   
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Bank_Selection 
N  * @{
N  */ 
N#define ADC_Bank_A                                 ((uint8_t)0x00)
N#define ADC_Bank_B                                 ((uint8_t)0x01)  
N#define IS_ADC_BANK(BANK) (((BANK) == ADC_Bank_A)   || ((BANK) == ADC_Bank_B))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the ADC configuration to the default reset state *****/   
Nvoid ADC_DeInit(ADC_TypeDef* ADCx); 
N
N/* Initialization and Configuration functions *********************************/ 
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Nvoid ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank);
N
N/* Power saving functions *****************************************************/
Nvoid ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState);
Nvoid ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength);
N
N/* Analog Watchdog configuration functions ************************************/
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
N
N/* Temperature Sensor & Vrefint (Voltage Reference internal) management function */
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
N
N/* Regular Channels Configuration functions ***********************************/
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
N
N/* Regular Channels DMA Configuration functions *******************************/
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N
N/* Injected channels Configuration functions **********************************/
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge);
Nvoid ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
N
N/* Interrupts and flags management functions **********************************/
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32L1xx_ADC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 87 "..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_adc.c" 2
N#include "stm32l1xx_rcc.h"
N
N/** @addtogroup STM32L1xx_StdPeriph_Driver
N  * @{
N  */
N
N/** @defgroup ADC 
N  * @brief ADC driver modules
N  * @{
N  */
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* ADC DISCNUM mask */
N#define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
N   
N/* ADC AWDCH mask */
N#define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0) 
N  
N/* ADC Analog watchdog enable mode mask */
N#define CR1_AWDMODE_RESET         ((uint32_t)0xFF3FFDFF)
N  
N/* CR1 register Mask */
N#define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF) 
N   
N/* ADC DELAY mask */            
N#define CR2_DELS_RESET            ((uint32_t)0xFFFFFF0F)
N   
N/* ADC JEXTEN mask */
N#define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)
N  
N/* ADC JEXTSEL mask */
N#define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)
N  
N/* CR2 register Mask */
N#define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
N
N/* ADC SQx mask */
N#define SQR5_SQ_SET               ((uint32_t)0x0000001F)  
N#define SQR4_SQ_SET               ((uint32_t)0x0000001F)  
N#define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
N#define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
N#define SQR1_SQ_SET               ((uint32_t)0x0000001F)
N
N/* ADC L Mask */
N#define SQR1_L_RESET              ((uint32_t)0xFE0FFFFF) 
N
N/* ADC JSQx mask */
N#define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
N 
N/* ADC JL mask */
N#define JSQR_JL_SET               ((uint32_t)0x00300000) 
N#define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
N
N/* ADC SMPx mask */
N#define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
N#define SMPR2_SMP_SET             ((uint32_t)0x00000007)
N#define SMPR3_SMP_SET             ((uint32_t)0x00000007) 
N#define SMPR0_SMP_SET             ((uint32_t)0x00000007)
N
N/* ADC JDRx registers offset */
N#define JDR_OFFSET                ((uint8_t)0x30)   
N  
N/* ADC CCR register Mask */
N#define CR_CLEAR_MASK             ((uint32_t)0xFFFCFFFF) 
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N/** @defgroup ADC_Private_Functions
N  * @{
N  */
N
N/** @defgroup ADC_Group1 Initialization and Configuration functions
N *  @brief   Initialization and Configuration functions.
N *
N@verbatim    
N ===============================================================================
N          ##### Initialization and Configuration functions #####
N ===============================================================================
N    [..] This section provides functions allowing to:
N        (+) Initialize and configure the ADC Prescaler.
N        (+) ADC Conversion Resolution (12bit..6bit).
N        (+) Scan Conversion Mode (multichannel or one channel) for regular group.
N        (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
N            regular group.
N        (+) External trigger Edge and source of regular group.
N        (+) Converted data alignment (left or right).
N        (+) The number of ADC conversions that will be done using the sequencer 
N            for regular channel group.
N        (+) Enable or disable the ADC peripheral.
N    
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Deinitializes ADC1 peripheral registers to their default reset values.
N  * @param  None
N  * @retval None
N  */
Nvoid ADC_DeInit(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  if(ADCx == ADC1)
X  if(ADCx == ((ADC_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x2400)))
N  {
N    /* Enable ADC1 reset state */
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00000200), ENABLE);
N    /* Release ADC1 from reset state */
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00000200), DISABLE);
N  }
N}
N
N/**
N  * @brief  Initializes the ADCx peripheral according to the specified parameters
N  *         in the ADC_InitStruct.
N  * @note   This function is used to configure the global features of the ADC ( 
N  *         Resolution and Data Alignment), however, the rest of the configuration
N  *         parameters are specific to the regular channels group (scan mode 
N  *         activation, continuous mode activation, External trigger source and 
N  *         edge, number of conversion in the regular channels group sequencer).
N  * @param  ADCx: where x can be 1 to select the ADC peripheral.
N  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
N  *         the configuration information for the specified ADC peripheral.
N  * @retval None
N  */
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
N{
N  uint32_t tmpreg1 = 0;
N  uint8_t tmpreg2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
X  ((void)0); 
N  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
X  ((void)0); 
N  assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
X  ((void)0); 
N  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
X  ((void)0);    
N  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
X  ((void)0); 
N  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
X  ((void)0);
N  
N  /*---------------------------- ADCx CR1 Configuration -----------------*/
N  /* Get the ADCx CR1 value */
N  tmpreg1 = ADCx->CR1;
N  /* Clear RES and SCAN bits */ 
N  tmpreg1 &= CR1_CLEAR_MASK;
X  tmpreg1 &= ((uint32_t)0xFCFFFEFF);
N  /* Configure ADCx: scan conversion mode and resolution */
N  /* Set SCAN bit according to ADC_ScanConvMode value */
N  /* Set RES bit according to ADC_Resolution value */ 
N  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
N  /* Write to ADCx CR1 */
N  ADCx->CR1 = tmpreg1;
N  
N  /*---------------------------- ADCx CR2 Configuration -----------------*/
N  /* Get the ADCx CR2 value */
N  tmpreg1 = ADCx->CR2;
N  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
N  tmpreg1 &= CR2_CLEAR_MASK;
X  tmpreg1 &= ((uint32_t)0xC0FFF7FD);
N  /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
N  /* Set ALIGN bit according to ADC_DataAlign value */
N  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
N  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
N  /* Set CONT bit according to ADC_ContinuousConvMode value */
N  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
N              ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
N  /* Write to ADCx CR2 */
N  ADCx->CR2 = tmpreg1;
N  
N  /*---------------------------- ADCx SQR1 Configuration -----------------*/
N  /* Get the ADCx SQR1 value */
N  tmpreg1 = ADCx->SQR1;
N  /* Clear L bits */
N  tmpreg1 &= SQR1_L_RESET;
X  tmpreg1 &= ((uint32_t)0xFE0FFFFF);
N  /* Configure ADCx: regular channel sequence length */
N  /* Set L bits according to ADC_NbrOfConversion value */ 
N  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
N  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
N  /* Write to ADCx SQR1 */
N  ADCx->SQR1 = tmpreg1;
N}
N
N/**
N  * @brief  Fills each ADC_InitStruct member with its default value.
N  * @note   This function is used to initialize the global features of the ADC ( 
N  *         Resolution and Data Alignment), however, the rest of the configuration
N  *         parameters are specific to the regular channels group (scan mode 
N  *         activation, continuous mode activation, External trigger source and 
N  *         edge, number of conversion in the regular channels group sequencer).
N  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
N  *         be initialized.
N  * @retval None
N  */
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
N{
N  /* Reset ADC init structure parameters values */
N  /* Initialize the ADC_Resolution member */
N  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
X  ADC_InitStruct->ADC_Resolution = ((uint32_t)0x00000000);
N
N  /* Initialize the ADC_ScanConvMode member */
N  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
N
N  /* Initialize the ADC_ContinuousConvMode member */
N  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
N
N  /* Initialize the ADC_ExternalTrigConvEdge member */
N  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
X  ADC_InitStruct->ADC_ExternalTrigConvEdge = ((uint32_t)0x00000000);
N
N  /* Initialize the ADC_ExternalTrigConv member */
N  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
X  ADC_InitStruct->ADC_ExternalTrigConv = ((uint32_t)0x03000000);
N
N  /* Initialize the ADC_DataAlign member */
N  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
X  ADC_InitStruct->ADC_DataAlign = ((uint32_t)0x00000000);
N
N  /* Initialize the ADC_NbrOfConversion member */
N  ADC_InitStruct->ADC_NbrOfConversion = 1;
N}
N
N/**
N  * @brief  Initializes the ADCs peripherals according to the specified parameters
N  *          in the ADC_CommonInitStruct.
N  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
N  *         that contains the configuration information (Prescaler) for ADC1 peripheral.
N  * @retval None
N  */
Nvoid ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                           
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
X  ((void)0);
N
N  /*---------------------------- ADC CCR Configuration -----------------*/
N  /* Get the ADC CCR value */
N  tmpreg = ADC->CCR;
X  tmpreg = ((ADC_Common_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x2700))->CCR;
N
N  /* Clear ADCPRE bit */ 
N  tmpreg &= CR_CLEAR_MASK;
X  tmpreg &= ((uint32_t)0xFFFCFFFF);
N  
N  /* Configure ADCx: ADC prescaler according to ADC_Prescaler */                
N  tmpreg |= (uint32_t)(ADC_CommonInitStruct->ADC_Prescaler);        
N                
N  /* Write to ADC CCR */
N  ADC->CCR = tmpreg;
X  ((ADC_Common_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x2700))->CCR = tmpreg;
N}
N
N/**
N  * @brief  Fills each ADC_CommonInitStruct member with its default value.
N  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
N  *         which will be initialized.
N  * @retval None
N  */
Nvoid ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)                      
N{
N  /* Reset ADC init structure parameters values */
N  /* Initialize the ADC_Prescaler member */
N  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div1;
X  ADC_CommonInitStruct->ADC_Prescaler = ((uint32_t)0x00000000);
N}
N
N/**
N  * @brief  Enables or disables the specified ADC peripheral.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the ADCx peripheral.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the ADON bit to wake up the ADC from power down mode */
N    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
X    ADCx->CR2 |= (uint32_t)((uint32_t)0x00000001);
N  }
N  else
N  {
N    /* Disable the selected ADC peripheral */
N    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
X    ADCx->CR2 &= (uint32_t)(~((uint32_t)0x00000001));
N  }
N}
N
N/**
N  * @brief  Selects the specified ADC Channels Bank.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_Bank: ADC Channels Bank.
N  *     @arg ADC_Bank_A: ADC Channels Bank A.
N  *     @arg ADC_Bank_B: ADC Channels Bank B.
N  * @retval None
N  */
Nvoid ADC_BankSelection(ADC_TypeDef* ADCx, uint8_t ADC_Bank)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_BANK(ADC_Bank));
X  ((void)0);
N
N  if (ADC_Bank != ADC_Bank_A)
X  if (ADC_Bank != ((uint8_t)0x00))
N  {
N    /* Set the ADC_CFG bit to select the ADC Bank B channels */
N    ADCx->CR2 |= (uint32_t)ADC_CR2_CFG;
X    ADCx->CR2 |= (uint32_t)((uint32_t)0x00000004);
N  }
N  else
N  {
N    /* Reset the ADC_CFG bit to select the ADC Bank A channels */
N    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CFG);
X    ADCx->CR2 &= (uint32_t)(~((uint32_t)0x00000004));
N  }
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group2 Power saving functions
N *  @brief   Power saving functions 
N *
N@verbatim   
N ===============================================================================
N                    ##### Power saving functions #####
N ===============================================================================
N    [..] This section provides functions allowing to reduce power consumption.
N    [..] The two function must be combined to get the maximal benefits:
N         When the ADC frequency is higher than the CPU one, it is recommended to:
N         (#) Insert a freeze delay :
N             ==> using ADC_DelaySelectionConfig(ADC1, ADC_DelayLength_Freeze).
N         (#) Enable the power down in Idle and Delay phases :
N             ==> using ADC_PowerDownCmd(ADC1, ADC_PowerDown_Idle_Delay, ENABLE).
N
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Enables or disables the ADC Power Down during Delay and/or Idle phase.
N  * @note   ADC power-on and power-off can be managed by hardware to cut the 
N  *         consumption when the ADC is not converting.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_PowerDown: The ADC power down configuration.
N  *         This parameter can be one of the following values:
N  *     @arg ADC_PowerDown_Delay:      ADC is powered down during delay phase.
N  *     @arg ADC_PowerDown_Idle:       ADC is powered down during Idle phase.
N  *     @arg ADC_PowerDown_Idle_Delay: ADC is powered down during Delay and Idle phases.
N  * @note   The ADC can be powered down:
N  * @note   During the hardware delay insertion (using the ADC_PowerDown_Delay
N  *           parameter).
N  *           => The ADC is powered up again at the end of the delay.
N  * @note   During the ADC is waiting for a trigger event ( using the 
N  *           ADC_PowerDown_Idle parameter).
N  *           => The ADC is powered up at the next trigger event.
N  * @note   During the hardware delay insertion or the ADC is waiting for a 
N  *           trigger event (using the ADC_PowerDown_Idle_Delay parameter).
N  *            => The ADC is powered up only at the end of the delay and at the
N  *              next trigger event.
N  * @param  NewState: new state of the ADCx power down.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_PowerDownCmd(ADC_TypeDef* ADCx, uint32_t ADC_PowerDown, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  assert_param(IS_ADC_POWER_DOWN(ADC_PowerDown));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the ADC power-down during Delay and/or Idle phase */
N    ADCx->CR1 |= ADC_PowerDown;
N  }
N  else
N  {
N    /* Disable The ADC power-down during Delay and/or Idle phase */
N    ADCx->CR1 &= (uint32_t)~ADC_PowerDown;
N  }
N}
N
N/**
N  * @brief  Defines the length of the delay which is applied after a conversion 
N  *         or a sequence of conversion.
N  * @note   When the CPU clock is not fast enough to manage the data rate, a 
N  *         Hardware delay can be introduced between ADC conversions to reduce 
N  *         this data rate.
N  * @note   The Hardware delay is inserted after :
N  *         - each regular conversion.
N  *         - after each sequence of injected conversions.
N  * @note   No Hardware delay is inserted between conversions of different groups.
N  * @note   When the hardware delay is not enough, the Freeze Delay Mode can be 
N  *         selected and a new conversion can start only if all the previous data 
N  *         of the same group have been treated:
N  *         - for a regular conversion: once the ADC conversion data register has 
N  *           been read (using ADC_GetConversionValue() function) or if the EOC 
N  *           Flag has been cleared (using ADC_ClearFlag() function).
N  *         - for an injected conversion: when the JEOC bit has been cleared 
N  *           (using ADC_ClearFlag() function).
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_DelayLength: The length of delay which is applied after a 
N  *         conversion or a sequence of conversion. 
N  *   This parameter can be one of the following values:
N  *     @arg ADC_DelayLength_None: No delay.
N  *     @arg ADC_DelayLength_Freeze: Delay until the converted data has been read.
N  *     @arg ADC_DelayLength_7Cycles: Delay length equal to 7 APB clock cycles.
N  *     @arg ADC_DelayLength_15Cycles: Delay length equal to 15 APB clock cycles	
N  *     @arg ADC_DelayLength_31Cycles: Delay length equal to 31 APB clock cycles	
N  *     @arg ADC_DelayLength_63Cycles: Delay length equal to 63 APB clock cycles	
N  *     @arg ADC_DelayLength_127Cycles: Delay length equal to 127 APB clock cycles	
N  *     @arg ADC_DelayLength_255Cycles: Delay length equal to 255 APB clock cycles	
N  * @retval None
N  */
Nvoid ADC_DelaySelectionConfig(ADC_TypeDef* ADCx, uint8_t ADC_DelayLength)
N{
N  uint32_t tmpreg = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_DELAY_LENGTH(ADC_DelayLength));
X  ((void)0);
N
N  /* Get the old register value */    
N  tmpreg = ADCx->CR2;
N  /* Clear the old delay length */
N  tmpreg &= CR2_DELS_RESET;
X  tmpreg &= ((uint32_t)0xFFFFFF0F);
N  /* Set the delay length */
N  tmpreg |= ADC_DelayLength;
N  /* Store the new register value */
N  ADCx->CR2 = tmpreg;
N
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group3 Analog Watchdog configuration functions
N *  @brief   Analog Watchdog configuration functions. 
N *
N@verbatim   
N ===============================================================================
N                   ##### Analog Watchdog configuration functions #####
N ===============================================================================  
N    [..] This section provides functions allowing to configure the Analog Watchdog
N         (AWD) feature in the ADC.
N    [..] A typical configuration Analog Watchdog is done following these steps :
N         (#) the ADC guarded channel(s) is (are) selected using the 
N             ADC_AnalogWatchdogSingleChannelConfig() function.
N         (#) The Analog watchdog lower and higher threshold are configured using 
N             the ADC_AnalogWatchdogThresholdsConfig() function.
N         (#) The Analog watchdog is enabled and configured to enable the check, 
N             on one or more channels, using the  ADC_AnalogWatchdogCmd() function.
N
N@endverbatim
N  * @{
N  */
N  
N/**
N  * @brief  Enables or disables the analog watchdog on single/all regular
N  *         or injected channels.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single 
N  *          regular channel.
N  *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single 
N  *          injected channel.
N  *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a 
N  *          single regular or injected channel.
N  *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular 
N  *          channel.
N  *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected 
N  *          channel.
N  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all 
N  *           regular and injected channels.
N  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog.
N  * @retval None	  
N  */
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
N{
N  uint32_t tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR1;
N  /* Clear AWDEN, JAWDEN and AWDSGL bits */   
N  tmpreg &= CR1_AWDMODE_RESET;
X  tmpreg &= ((uint32_t)0xFF3FFDFF);
N  /* Set the analog watchdog enable mode */
N  tmpreg |= ADC_AnalogWatchdog;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg;
N}
N
N/**
N  * @brief  Configures the high and low thresholds of the analog watchdog.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  HighThreshold: the ADC analog watchdog High threshold value.
N  *         This parameter must be a 12bit value.
N  * @param  LowThreshold: the ADC analog watchdog Low threshold value.
N  *         This parameter must be a 12bit value.
N  * @retval None
N  */
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
N                                        uint16_t LowThreshold)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_THRESHOLD(HighThreshold));
X  ((void)0);
N  assert_param(IS_ADC_THRESHOLD(LowThreshold));
X  ((void)0);
N
N  /* Set the ADCx high threshold */
N  ADCx->HTR = HighThreshold;
N  /* Set the ADCx low threshold */
N  ADCx->LTR = LowThreshold;
N}
N
N/**
N  * @brief  Configures the analog watchdog guarded single channel.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
N  *   This parameter can be one of the following values:
N  *     @arg ADC_Channel_0: ADC Channel0 selected
N  *     @arg ADC_Channel_1: ADC Channel1 selected
N  *     @arg ADC_Channel_2: ADC Channel2 selected
N  *     @arg ADC_Channel_3: ADC Channel3 selected
N  *     @arg ADC_Channel_4: ADC Channel4 selected
N  *     @arg ADC_Channel_5: ADC Channel5 selected
N  *     @arg ADC_Channel_6: ADC Channel6 selected
N  *     @arg ADC_Channel_7: ADC Channel7 selected
N  *     @arg ADC_Channel_8: ADC Channel8 selected
N  *     @arg ADC_Channel_9: ADC Channel9 selected
N  *     @arg ADC_Channel_10: ADC Channel10 selected
N  *     @arg ADC_Channel_11: ADC Channel11 selected
N  *     @arg ADC_Channel_12: ADC Channel12 selected
N  *     @arg ADC_Channel_13: ADC Channel13 selected
N  *     @arg ADC_Channel_14: ADC Channel14 selected
N  *     @arg ADC_Channel_15: ADC Channel15 selected
N  *     @arg ADC_Channel_16: ADC Channel16 selected
N  *     @arg ADC_Channel_17: ADC Channel17 selected
N  *     @arg ADC_Channel_18: ADC Channel18 selected
N  *     @arg ADC_Channel_19: ADC Channel19 selected
N  *     @arg ADC_Channel_20: ADC Channel20 selected
N  *     @arg ADC_Channel_21: ADC Channel21 selected
N  *     @arg ADC_Channel_22: ADC Channel22 selected
N  *     @arg ADC_Channel_23: ADC Channel23 selected
N  *     @arg ADC_Channel_24: ADC Channel24 selected
N  *     @arg ADC_Channel_25: ADC Channel25 selected
N  *     @arg ADC_Channel_27: ADC Channel27 selected
N  *     @arg ADC_Channel_28: ADC Channel28 selected
N  *     @arg ADC_Channel_29: ADC Channel29 selected
N  *     @arg ADC_Channel_30: ADC Channel30 selected
N  *     @arg ADC_Channel_31: ADC Channel31 selected
N  *     @arg ADC_Channel_0b: ADC Channel0b selected
N  *     @arg ADC_Channel_1b: ADC Channel1b selected
N  *     @arg ADC_Channel_2b: ADC Channel2b selected
N  *     @arg ADC_Channel_3b: ADC Channel3b selected
N  *     @arg ADC_Channel_6b: ADC Channel6b selected
N  *     @arg ADC_Channel_7b: ADC Channel7b selected
N  *     @arg ADC_Channel_8b: ADC Channel8b selected
N  *     @arg ADC_Channel_9b: ADC Channel9b selected
N  *     @arg ADC_Channel_10b: ADC Channel10b selected
N  *     @arg ADC_Channel_11b: ADC Channel11b selected
N  *     @arg ADC_Channel_12b: ADC Channel12b selected
N  * @retval None
N  */
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
N{
N  uint32_t tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR1;
N  /* Clear the Analog watchdog channel select bits */
N  tmpreg &= CR1_AWDCH_RESET;
X  tmpreg &= ((uint32_t)0xFFFFFFE0);
N  /* Set the Analog watchdog channel */
N  tmpreg |= ADC_Channel;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg;
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group4 Temperature Sensor & Vrefint (Voltage Reference internal) management function
N *  @brief   Temperature Sensor & Vrefint (Voltage Reference internal) management function.
N *
N@verbatim   
N =========================================================================================
N ##### Temperature Sensor and Vrefint (Voltage Reference internal) management function #####
N =========================================================================================
N    [..] This section provides a function allowing to enable/ disable the internal 
N         connections between the ADC and the Temperature Sensor and the Vrefint 
N         source.
N    [..] A typical configuration to get the Temperature sensor and Vrefint channels 
N         voltages is done following these steps :
N         (#) Enable the internal connection of Temperature sensor and Vrefint sources 
N             with the ADC channels using ADC_TempSensorVrefintCmd() function.
N         (#) select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
N             ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions.
N         (#) Get the voltage values, using ADC_GetConversionValue() or 
N             ADC_GetInjectedConversionValue().
N@endverbatim
N  * @{
N  */
N  
N/**
N  * @brief  Enables or disables the temperature sensor and Vrefint channel.
N  * @param  NewState: new state of the temperature sensor and Vref int channels.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState)                
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the temperature sensor and Vrefint channel*/
N    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
X    ((ADC_Common_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x2700))->CCR |= (uint32_t)((uint32_t)0x00800000);
N  }
N  else
N  {
N    /* Disable the temperature sensor and Vrefint channel*/
N    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
X    ((ADC_Common_TypeDef *) ((((uint32_t)0x40000000) + 0x10000) + 0x2700))->CCR &= (uint32_t)(~((uint32_t)0x00800000));
N  }
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group5 Regular Channels Configuration functions
N *  @brief   Regular Channels Configuration functions.
N *
N@verbatim   
N ===============================================================================
N            ##### Regular Channels Configuration functions #####
N ===============================================================================
N    [..] This section provides functions allowing to manage the ADC regular channels,
N         it is composed of 2 sub sections :
N         (#) Configuration and management functions for regular channels: This 
N             subsection provides functions allowing to configure the ADC regular 
N             channels :
N             (++) Configure the rank in the regular group sequencer for each channel.
N             (++) Configure the sampling time for each channel.
N             (++) select the conversion Trigger for regular channels.
N             (++) select the desired EOC event behavior configuration.
N             (++) Activate the continuous Mode  (*).
N             (++) Activate the Discontinuous Mode.
N             -@@- Please Note that the following features for regular channels are 
N                  configurated using the ADC_Init() function : 
N                  (+@@) scan mode activation.
N                  (+@@) continuous mode activation (**).
N                  (+@@) External trigger source.
N                  (+@@) External trigger edge.
N                  (+@@) number of conversion in the regular channels group sequencer.
N             -@@- (*) and (**) are performing the same configuration.
N         (#) Get the conversion data: This subsection provides an important function 
N             in the ADC peripheral since it returns the converted data of the current 
N             regular channel. When the Conversion value is read, the EOC Flag is 
N             automatically cleared.
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Configures for the selected ADC regular channel its corresponding
N  *         rank in the sequencer and its sampling time.
N  * @param  ADCx: where x can be 1 to select the ADC peripheral.
N  * @param  ADC_Channel: the ADC channel to configure.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_Channel_0: ADC Channel0 selected
N  *     @arg ADC_Channel_1: ADC Channel1 selected
N  *     @arg ADC_Channel_2: ADC Channel2 selected
N  *     @arg ADC_Channel_3: ADC Channel3 selected
N  *     @arg ADC_Channel_4: ADC Channel4 selected
N  *     @arg ADC_Channel_5: ADC Channel5 selected
N  *     @arg ADC_Channel_6: ADC Channel6 selected
N  *     @arg ADC_Channel_7: ADC Channel7 selected
N  *     @arg ADC_Channel_8: ADC Channel8 selected
N  *     @arg ADC_Channel_9: ADC Channel9 selected
N  *     @arg ADC_Channel_10: ADC Channel10 selected
N  *     @arg ADC_Channel_11: ADC Channel11 selected
N  *     @arg ADC_Channel_12: ADC Channel12 selected
N  *     @arg ADC_Channel_13: ADC Channel13 selected
N  *     @arg ADC_Channel_14: ADC Channel14 selected
N  *     @arg ADC_Channel_15: ADC Channel15 selected
N  *     @arg ADC_Channel_16: ADC Channel16 selected
N  *     @arg ADC_Channel_17: ADC Channel17 selected
N  *     @arg ADC_Channel_18: ADC Channel18 selected 
N  *     @arg ADC_Channel_19: ADC Channel19 selected
N  *     @arg ADC_Channel_20: ADC Channel20 selected
N  *     @arg ADC_Channel_21: ADC Channel21 selected
N  *     @arg ADC_Channel_22: ADC Channel22 selected
N  *     @arg ADC_Channel_23: ADC Channel23 selected
N  *     @arg ADC_Channel_24: ADC Channel24 selected
N  *     @arg ADC_Channel_25: ADC Channel25 selected
N  *     @arg ADC_Channel_27: ADC Channel27 selected
N  *     @arg ADC_Channel_28: ADC Channel28 selected
N  *     @arg ADC_Channel_29: ADC Channel29 selected
N  *     @arg ADC_Channel_30: ADC Channel30 selected
N  *     @arg ADC_Channel_31: ADC Channel31 selected 
N  *     @arg ADC_Channel_0b: ADC Channel0b selected
N  *     @arg ADC_Channel_1b: ADC Channel1b selected
N  *     @arg ADC_Channel_2b: ADC Channel2b selected
N  *     @arg ADC_Channel_3b: ADC Channel3b selected
N  *     @arg ADC_Channel_6b: ADC Channel6b selected
N  *     @arg ADC_Channel_7b: ADC Channel7b selected
N  *     @arg ADC_Channel_8b: ADC Channel8b selected
N  *     @arg ADC_Channel_9b: ADC Channel9b selected
N  *     @arg ADC_Channel_10b: ADC Channel10b selected
N  *     @arg ADC_Channel_11b: ADC Channel11b selected
N  *     @arg ADC_Channel_12b: ADC Channel12b selected   
N  * @param  Rank: The rank in the regular group sequencer. This parameter
N  *               must be between 1 to 28.
N  * @param  ADC_SampleTime: The sample time value to be set for the selected 
N  *         channel.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles
N  *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
N  *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
N  *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
N  *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
N  *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
N  *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
N  *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
N  * @retval None
N  */
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
N{
N  uint32_t tmpreg1 = 0, tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N  assert_param(IS_ADC_REGULAR_RANK(Rank));
X  ((void)0);
N  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
X  ((void)0);
N
N  /* If ADC_Channel_30 or ADC_Channel_31 is selected */
N  if (ADC_Channel > ADC_Channel_29)
X  if (ADC_Channel > ((uint8_t)0x1D))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR0;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 30));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR0 = tmpreg1;
N  }
N  /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
N  else if (ADC_Channel > ADC_Channel_19)
X  else if (ADC_Channel > ((uint8_t)0x13))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 20));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR1 = tmpreg1;
N  }
N  /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
N  else if (ADC_Channel > ADC_Channel_9)
X  else if (ADC_Channel > ((uint8_t)0x09))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 10));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR2 = tmpreg1;
N  }
N  else /* ADC_Channel include in ADC_Channel_[0..9] */
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR3;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * ADC_Channel);
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR3 = tmpreg1;
N  }
N  /* For Rank 1 to 6 */
N  if (Rank < 7)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR5;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
X    tmpreg2 = ((uint32_t)0x0000001F) << (5 * (Rank - 1));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR5 = tmpreg1;
N  }
N  /* For Rank 7 to 12 */
N  else if (Rank < 13)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR4;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
X    tmpreg2 = ((uint32_t)0x0000001F) << (5 * (Rank - 7));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR4 = tmpreg1;
N  }  
N  /* For Rank 13 to 18 */
N  else if (Rank < 19)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR3;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
X    tmpreg2 = ((uint32_t)0x0000001F) << (5 * (Rank - 13));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR3 = tmpreg1;
N  }
N    
N  /* For Rank 19 to 24 */
N  else if (Rank < 25)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
X    tmpreg2 = ((uint32_t)0x0000001F) << (5 * (Rank - 19));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR2 = tmpreg1;
N  }   
N  
N  /* For Rank 25 to 28 */
N  else
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
X    tmpreg2 = ((uint32_t)0x0000001F) << (5 * (Rank - 25));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR1 = tmpreg1;
N  }
N}
N
N/**
N  * @brief  Enables the selected ADC software start conversion of the regular channels.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @retval None
N  */
Nvoid ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Enable the selected ADC conversion for regular group */
N  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
X  ADCx->CR2 |= (uint32_t)((uint32_t)0x40000000);
N}
N
N/**
N  * @brief  Gets the selected ADC Software start regular conversion Status.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @retval The new state of ADC software start conversion (SET or RESET).
N  */
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of SWSTART bit */
N  if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
X  if ((ADCx->CR2 & ((uint32_t)0x40000000)) != (uint32_t)RESET)
N  {
N    /* SWSTART bit is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* SWSTART bit is reset */
N    bitstatus = RESET;
N  }
N  /* Return the SWSTART bit status */
N  return  bitstatus;
N}
N
N/**
N  * @brief  Enables or disables the EOC on each regular channel conversion.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC EOC flag rising
N  *    This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC EOC rising on each regular channel conversion */
N    ADCx->CR2 |= ADC_CR2_EOCS;
X    ADCx->CR2 |= ((uint32_t)0x00000400);
N  }
N  else
N  {
N    /* Disable the selected ADC EOC rising on each regular channel conversion */
N    ADCx->CR2 &= (uint32_t)~ADC_CR2_EOCS;
X    ADCx->CR2 &= (uint32_t)~((uint32_t)0x00000400);
N  }
N}
N
N/**
N  * @brief  Enables or disables the ADC continuous conversion mode.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC continuous conversion mode.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC continuous conversion mode */
N    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
X    ADCx->CR2 |= (uint32_t)((uint32_t)0x00000002);
N  }
N  else
N  {
N    /* Disable the selected ADC continuous conversion mode */
N    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
X    ADCx->CR2 &= (uint32_t)(~((uint32_t)0x00000002));
N  }
N}
N
N/**
N  * @brief  Configures the discontinuous mode for the selected ADC regular
N  *         group channel.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  Number: specifies the discontinuous mode regular channel count value.
N  *         This number must be between 1 and 8.
N  * @retval None
N  */
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
N{
N  uint32_t tmpreg1 = 0;
N  uint32_t tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg1 = ADCx->CR1;
N  /* Clear the old discontinuous mode channel count */
N  tmpreg1 &= CR1_DISCNUM_RESET;
X  tmpreg1 &= ((uint32_t)0xFFFF1FFF);
N  /* Set the discontinuous mode channel count */
N  tmpreg2 = Number - 1;
N  tmpreg1 |= tmpreg2 << 13;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg1;
N}
N
N/**
N  * @brief  Enables or disables the discontinuous mode on regular group
N  *         channel for the specified ADC.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC discontinuous mode on regular 
N  *         group channel.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC regular discontinuous mode */
N    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
X    ADCx->CR1 |= (uint32_t)((uint32_t)0x00000800);
N  }
N  else
N  {
N    /* Disable the selected ADC regular discontinuous mode */
N    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
X    ADCx->CR1 &= (uint32_t)(~((uint32_t)0x00000800));
N  }
N}
N
N/**
N  * @brief  Returns the last ADCx conversion result data for regular channel.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @retval The Data conversion value.
N  */
Nuint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Return the selected ADC conversion value */
N  return (uint16_t) ADCx->DR;
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group6 Regular Channels DMA Configuration functions
N *  @brief   Regular Channels DMA Configuration functions.
N *
N@verbatim   
N ===============================================================================
N          ##### Regular Channels DMA Configuration functions #####
N ===============================================================================
N    [..] This section provides functions allowing to configure the DMA for ADC regular 
N         channels.Since converted regular channel values are stored into a unique 
N         data register, it is useful to use DMA for conversion of more than one 
N         regular channel. This avoids the loss of the data already stored in the 
N         ADC Data register.
N         When the DMA mode is enabled (using the ADC_DMACmd() function), after each
N         conversion of a regular channel, a DMA request is generated.
N    [..] Depending on the "DMA disable selection" configuration (using the 
N         ADC_DMARequestAfterLastTransferCmd() function), at the end of the last DMA 
N         transfer, two possibilities are allowed:
N         (+) No new DMA request is issued to the DMA controller (feature DISABLED).
N         (+) Requests can continue to be generated (feature ENABLED).
N
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Enables or disables the specified ADC DMA request.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC DMA transfer.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_DMA_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC DMA request */
N    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
X    ADCx->CR2 |= (uint32_t)((uint32_t)0x00000100);
N  }
N  else
N  {
N    /* Disable the selected ADC DMA request */
N    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
X    ADCx->CR2 &= (uint32_t)(~((uint32_t)0x00000100));
N  }
N}
N
N
N/**
N  * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode).
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC EOC flag rising
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC DMA request after last transfer */
N    ADCx->CR2 |= ADC_CR2_DDS;
X    ADCx->CR2 |= ((uint32_t)0x00000200);
N  }
N  else
N  {
N    /* Disable the selected ADC DMA request after last transfer */
N    ADCx->CR2 &= (uint32_t)~ADC_CR2_DDS;
X    ADCx->CR2 &= (uint32_t)~((uint32_t)0x00000200);
N  }
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group7 Injected channels Configuration functions
N *  @brief   Injected channels Configuration functions.
N *
N@verbatim   
N ===============================================================================
N            ##### Injected channels Configuration functions #####
N ===============================================================================
N    [..] This section provide functions allowing to configure the ADC Injected channels,
N         it is composed of 2 sub sections : 
N         (#) Configuration functions for Injected channels: This subsection provides 
N             functions allowing to configure the ADC injected channels :
N             (++) Configure the rank in the injected group sequencer for each channel.
N             (++) Configure the sampling time for each channel.
N             (++) Activate the Auto injected Mode.
N             (++) Activate the Discontinuous Mode.
N             (++) scan mode activation.
N             (++) External/software trigger source.
N             (++) External trigger edge.
N             (++) injected channels sequencer.
N    
N         (#) Get the Specified Injected channel conversion data: This subsection 
N             provides an important function in the ADC peripheral since it returns 
N             the converted data of the specific injected channel.
N
N@endverbatim
N  * @{
N  */ 
N
N/**
N  * @brief  Configures for the selected ADC injected channel its corresponding
N  *         rank in the sequencer and its sample time.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_Channel: the ADC channel to configure.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_Channel_0: ADC Channel0 selected
N  *     @arg ADC_Channel_1: ADC Channel1 selected
N  *     @arg ADC_Channel_2: ADC Channel2 selected
N  *     @arg ADC_Channel_3: ADC Channel3 selected
N  *     @arg ADC_Channel_4: ADC Channel4 selected
N  *     @arg ADC_Channel_5: ADC Channel5 selected
N  *     @arg ADC_Channel_6: ADC Channel6 selected
N  *     @arg ADC_Channel_7: ADC Channel7 selected
N  *     @arg ADC_Channel_8: ADC Channel8 selected
N  *     @arg ADC_Channel_9: ADC Channel9 selected
N  *     @arg ADC_Channel_10: ADC Channel10 selected
N  *     @arg ADC_Channel_11: ADC Channel11 selected
N  *     @arg ADC_Channel_12: ADC Channel12 selected
N  *     @arg ADC_Channel_13: ADC Channel13 selected
N  *     @arg ADC_Channel_14: ADC Channel14 selected
N  *     @arg ADC_Channel_15: ADC Channel15 selected
N  *     @arg ADC_Channel_16: ADC Channel16 selected
N  *     @arg ADC_Channel_17: ADC Channel17 selected
N  *     @arg ADC_Channel_18: ADC Channel18 selected 
N  *     @arg ADC_Channel_19: ADC Channel19 selected
N  *     @arg ADC_Channel_20: ADC Channel20 selected
N  *     @arg ADC_Channel_21: ADC Channel21 selected
N  *     @arg ADC_Channel_22: ADC Channel22 selected
N  *     @arg ADC_Channel_23: ADC Channel23 selected
N  *     @arg ADC_Channel_24: ADC Channel24 selected
N  *     @arg ADC_Channel_25: ADC Channel25 selected
N  *     @arg ADC_Channel_27: ADC Channel27 selected
N  *     @arg ADC_Channel_28: ADC Channel28 selected
N  *     @arg ADC_Channel_29: ADC Channel29 selected
N  *     @arg ADC_Channel_30: ADC Channel30 selected
N  *     @arg ADC_Channel_31: ADC Channel31 selected 
N  *     @arg ADC_Channel_0b: ADC Channel0b selected
N  *     @arg ADC_Channel_1b: ADC Channel1b selected
N  *     @arg ADC_Channel_2b: ADC Channel2b selected
N  *     @arg ADC_Channel_3b: ADC Channel3b selected
N  *     @arg ADC_Channel_6b: ADC Channel6b selected
N  *     @arg ADC_Channel_7b: ADC Channel7b selected
N  *     @arg ADC_Channel_8b: ADC Channel8b selected
N  *     @arg ADC_Channel_9b: ADC Channel9b selected
N  *     @arg ADC_Channel_10b: ADC Channel10b selected
N  *     @arg ADC_Channel_11b: ADC Channel11b selected
N  *     @arg ADC_Channel_12b: ADC Channel12b selected   
N  * @param  Rank: The rank in the injected group sequencer. This parameter
N  *         must be between 1 to 4.
N  * @param  ADC_SampleTime: The sample time value to be set for the selected 
N  *         channel. This parameter can be one of the following values:
N  *     @arg ADC_SampleTime_4Cycles: Sample time equal to 4 cycles
N  *     @arg ADC_SampleTime_9Cycles: Sample time equal to 9 cycles
N  *     @arg ADC_SampleTime_16Cycles: Sample time equal to 16 cycles
N  *     @arg ADC_SampleTime_24Cycles: Sample time equal to 24 cycles	
N  *     @arg ADC_SampleTime_48Cycles: Sample time equal to 48 cycles	
N  *     @arg ADC_SampleTime_96Cycles: Sample time equal to 96 cycles	
N  *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
N  *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
N  * @retval None
N  */
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
N{
N  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_RANK(Rank));
X  ((void)0);
N  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
X  ((void)0);
N  
N  /* If ADC_Channel_30 or ADC_Channel_31 is selected */
N  if (ADC_Channel > ADC_Channel_29)
X  if (ADC_Channel > ((uint8_t)0x1D))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR0;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 30));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR0 = tmpreg1;
N  }
N  /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
N  else if (ADC_Channel > ADC_Channel_19)
X  else if (ADC_Channel > ((uint8_t)0x13))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 20));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR1 = tmpreg1;
N  }  
N  /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
N  else if (ADC_Channel > ADC_Channel_9)
X  else if (ADC_Channel > ((uint8_t)0x09))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * (ADC_Channel - 10));
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR2 = tmpreg1;
N  }
N  else /* ADC_Channel include in ADC_Channel_[0..9] */
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR3;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
X    tmpreg2 = ((uint32_t)0x00000007) << (3 * ADC_Channel);
N    /* Clear the old sample time */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
N    /* Set the new sample time */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR3 = tmpreg1;
N  }
N  
N  /* Rank configuration */
N  /* Get the old register value */
N  tmpreg1 = ADCx->JSQR;
N  /* Get JL value: Number = JL+1 */
N  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
X  tmpreg3 =  (tmpreg1 & ((uint32_t)0x00300000))>> 20;
N  /* Calculate the mask to clear: ((Rank-1)+(4- (JL+1))) */ 
N  tmpreg2 = (uint32_t)(JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
X  tmpreg2 = (uint32_t)(((uint32_t)0x0000001F) << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
N  /* Clear the old JSQx bits for the selected rank */
N  tmpreg1 &= ~tmpreg2;
N  /* Calculate the mask to set: ((Rank-1)+(4- (JL+1))) */ 
N  tmpreg2 = (uint32_t)(((uint32_t)(ADC_Channel)) << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1))));
N  /* Set the JSQx bits for the selected rank */
N  tmpreg1 |= tmpreg2;
N  /* Store the new register value */
N  ADCx->JSQR = tmpreg1;
N}
N
N/**
N  * @brief  Configures the sequencer length for injected channels.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  Length: The sequencer length.
N  *         This parameter must be a number between 1 to 4.
N  * @retval None
N  */
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
N{
N  uint32_t tmpreg1 = 0;
N  uint32_t tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_LENGTH(Length));
X  ((void)0);
N  
N  /* Get the old register value */
N  tmpreg1 = ADCx->JSQR;
N  /* Clear the old injected sequence length JL bits */
N  tmpreg1 &= JSQR_JL_RESET;
X  tmpreg1 &= ((uint32_t)0xFFCFFFFF);
N  /* Set the injected sequence length JL bits */
N  tmpreg2 = Length - 1; 
N  tmpreg1 |= tmpreg2 << 20;
N  /* Store the new register value */
N  ADCx->JSQR = tmpreg1;
N}
N
N/**
N  * @brief  Set the injected channels conversion value offset.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected.
N  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected.
N  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected.
N  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected.
N  * @param  Offset: the offset value for the selected ADC injected channel
N  *         This parameter must be a 12bit value.
N  * @retval None
N  */
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
N{
N  __IO uint32_t tmp = 0;
X  volatile uint32_t tmp = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
X  ((void)0);
N  assert_param(IS_ADC_OFFSET(Offset));  
X  ((void)0);  
N  
N  tmp = (uint32_t)ADCx;
N  tmp += ADC_InjectedChannel;
N  
N  /* Set the selected injected channel data offset */
N  *(__IO uint32_t *) tmp = (uint32_t)Offset;
X  *(volatile uint32_t *) tmp = (uint32_t)Offset;
N}
N
N/**
N  * @brief  Configures the ADCx external trigger for injected channels conversion.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected 
N  *    conversion. This parameter can be one of the following values:
N  *     @arg ADC_ExternalTrigInjecConv_T9_CC1: Timer9 capture compare1 selected 
N  *     @arg ADC_ExternalTrigInjecConv_T9_TRGO: Timer9 TRGO event selected 
N  *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected
N  *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected
N  *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected
N  *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
N  *     @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected
N  *     @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
N  *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected
N  *     @arg ADC_ExternalTrigInjecConv_T10_CC1: Timer10 capture compare1 selected
N  *     @arg ADC_ExternalTrigInjecConv_T7_TRGO: Timer7 TRGO event selected
N  *     @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected
N  * @retval None
N  */
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
N{
N  uint32_t tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR2;
N  /* Clear the old external event selection for injected group */
N  tmpreg &= CR2_JEXTSEL_RESET;
X  tmpreg &= ((uint32_t)0xFFF0FFFF);
N  /* Set the external event selection for injected group */
N  tmpreg |= ADC_ExternalTrigInjecConv;
N  /* Store the new register value */
N  ADCx->CR2 = tmpreg;
N}
N
N/**
N  * @brief  Configures the ADCx external trigger edge for injected channels conversion.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger
N  *         edge to start injected conversion.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_ExternalTrigConvEdge_None: external trigger disabled for 
N  *          injected conversion.
N  *     @arg ADC_ExternalTrigConvEdge_Rising: detection on rising edge
N  *     @arg ADC_ExternalTrigConvEdge_Falling: detection on falling edge
N  *     @arg ADC_ExternalTrigConvEdge_RisingFalling: detection on 
N  *          both rising and falling edge
N  * @retval None
N  */
Nvoid ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
N{
N  uint32_t tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR2;
N  /* Clear the old external trigger edge for injected group */
N  tmpreg &= CR2_JEXTEN_RESET;
X  tmpreg &= ((uint32_t)0xFFCFFFFF);
N  /* Set the new external trigger edge for injected group */
N  tmpreg |= ADC_ExternalTrigInjecConvEdge;
N  /* Store the new register value */
N  ADCx->CR2 = tmpreg;
N}
N
N/**
N  * @brief  Enables the selected ADC software start conversion of the injected 
N  *         channels.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @retval None
N  */
Nvoid ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  /* Enable the selected ADC conversion for injected group */
N  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
X  ADCx->CR2 |= (uint32_t)((uint32_t)0x00400000);
N}
N
N/**
N  * @brief  Gets the selected ADC Software start injected conversion Status.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @retval The new state of ADC software start injected conversion (SET or RESET).
N  */
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of JSWSTART bit */
N  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
X  if ((ADCx->CR2 & ((uint32_t)0x00400000)) != (uint32_t)RESET)
N  {
N    /* JSWSTART bit is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* JSWSTART bit is reset */
N    bitstatus = RESET;
N  }
N  /* Return the JSWSTART bit status */
N  return  bitstatus;
N}
N
N/**
N  * @brief  Enables or disables the selected ADC automatic injected group
N  *         conversion after regular one.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC auto injected
N  *         conversion.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC automatic injected group conversion */
N    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
X    ADCx->CR1 |= (uint32_t)((uint32_t)0x00000400);
N  }
N  else
N  {
N    /* Disable the selected ADC automatic injected group conversion */
N    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
X    ADCx->CR1 &= (uint32_t)(~((uint32_t)0x00000400));
N  }
N}
N
N/**
N  * @brief  Enables or disables the discontinuous mode for injected group
N  *         channel for the specified ADC.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  NewState: new state of the selected ADC discontinuous mode
N  *         on injected group channel. This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC injected discontinuous mode */
N    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
X    ADCx->CR1 |= (uint32_t)((uint32_t)0x00001000);
N  }
N  else
N  {
N    /* Disable the selected ADC injected discontinuous mode */
N    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
X    ADCx->CR1 &= (uint32_t)(~((uint32_t)0x00001000));
N  }
N}
N
N/**
N  * @brief  Returns the ADC injected channel conversion result.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_InjectedChannel: the converted ADC injected channel.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
N  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
N  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
N  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
N  * @retval The Data conversion value.
N  */
Nuint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
N{
N  __IO uint32_t tmp = 0;
X  volatile uint32_t tmp = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
X  ((void)0);
N
N  tmp = (uint32_t)ADCx;
N  tmp += ADC_InjectedChannel + JDR_OFFSET;
X  tmp += ADC_InjectedChannel + ((uint8_t)0x30);
N  
N  /* Returns the selected injected channel conversion data value */
N  return (uint16_t) (*(__IO uint32_t*)  tmp); 
X  return (uint16_t) (*(volatile uint32_t*)  tmp); 
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Group8 Interrupts and flags management functions
N *  @brief   Interrupts and flags management functions.
N *
N@verbatim   
N ===============================================================================
N            ##### Interrupts and flags management functions #####
N ===============================================================================
N    [..] This section provides functions allowing to configure the ADC Interrupts 
N         and get the status and clear flags and Interrupts pending bits.
N  
N    [..] The ADC provide 4 Interrupts sources and 9 Flags which can be divided into 
N         3 groups:
N  *** Flags and Interrupts for ADC regular channels ***
N  =====================================================
N    [..]
N        (+)Flags :
N           (##) ADC_FLAG_OVR : Overrun detection when regular converted data are 
N                lost.
N           (##) ADC_FLAG_EOC : Regular channel end of conversion + to indicate 
N                (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
N                the end of :
N                (+++) a regular CHANNEL conversion.
N                (+++) sequence of regular GROUP conversions.
N
N
N           (##) ADC_FLAG_STRT: Regular channel start + to indicate when regular 
N                CHANNEL conversion starts.
N           (##) ADC_FLAG_RCNR: Regular channel not ready + to indicate if a new 
N                regular conversion can be launched.
N        (+)Interrupts :
N           (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
N                event.
N           (##) ADC_IT_EOC : specifies the interrupt source for Regular channel 
N                end of conversion event.
N  
N  *** Flags and Interrupts for ADC Injected channels ***
N  ======================================================
N        (+)Flags :
N           (##) ADC_FLAG_JEOC : Injected channel end of conversion+ to indicate at 
N                the end of injected GROUP conversion.
N           (##) ADC_FLAG_JSTRT: Injected channel start +  to indicate hardware when 
N                injected GROUP conversion starts.
N           (##) ADC_FLAG_JCNR: Injected channel not ready + to indicate if a new 
N                injected conversion can be launched.
N        (+)Interrupts 
N           (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
N                end of conversion event.
N  *** General Flags and Interrupts for the ADC ***
N  ================================================
N        (+)Flags :
N           (##) ADC_FLAG_AWD: Analog watchdog + to indicate if the converted voltage 
N                crosses the programmed thresholds values.
N           (##) ADC_FLAG_ADONS: ADC ON status + to indicate if the ADC is ready 
N                to convert.
N        (+)Interrupts :
N           (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog 
N                event.
N  
N    [..] The user should identify which mode will be used in his application to 
N         manage the ADC controller events: Polling mode or Interrupt mode.
N  
N    [..] In the Polling Mode it is advised to use the following functions:
N         (+) ADC_GetFlagStatus() : to check if flags events occur.
N         (+) ADC_ClearFlag()     : to clear the flags events.
N  
N    [..] In the Interrupt Mode it is advised to use the following functions:
N         (+) ADC_ITConfig()       : to enable or disable the interrupt source.
N         (+) ADC_GetITStatus()    : to check if Interrupt occurs.
N         (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
N             (corresponding Flag).
N@endverbatim
N  * @{
N  */ 
N
N/**
N  * @brief  Enables or disables the specified ADC interrupts.
N  * @param  ADCx: where x can be 1 to select the ADC peripheral.
N  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_IT_EOC: End of conversion interrupt
N  *     @arg ADC_IT_AWD: Analog watchdog interrupt
N  *     @arg ADC_IT_JEOC: End of injected conversion interrupt
N  *     @arg ADC_IT_OVR: overrun interrupt
N  * @param  NewState: new state of the specified ADC interrupts.
N  *         This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
N{
N  uint32_t itmask = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  assert_param(IS_ADC_IT(ADC_IT)); 
X  ((void)0); 
N
N  /* Get the ADC IT index */
N  itmask = (uint8_t)ADC_IT;
N  itmask = (uint32_t)0x01 << itmask;    
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC interrupts */
N    ADCx->CR1 |= itmask;
N  }
N  else
N  {
N    /* Disable the selected ADC interrupts */
N    ADCx->CR1 &= (~(uint32_t)itmask);
N  }
N}
N
N/**
N  * @brief  Checks whether the specified ADC flag is set or not.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_FLAG: specifies the flag to check.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_FLAG_AWD: Analog watchdog flag
N  *     @arg ADC_FLAG_EOC: End of conversion flag
N  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
N  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
N  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
N  *     @arg ADC_FLAG_OVR: Overrun flag
N  *     @arg ADC_FLAG_ADONS: ADC ON status
N  *     @arg ADC_FLAG_RCNR: Regular channel not ready
N  *     @arg ADC_FLAG_JCNR: Injected channel not ready
N  * @retval The new state of ADC_FLAG (SET or RESET).
N  */
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
X  ((void)0);
N
N  /* Check the status of the specified ADC flag */
N  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
N  {
N    /* ADC_FLAG is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* ADC_FLAG is reset */
N    bitstatus = RESET;
N  }
N  /* Return the ADC_FLAG status */
N  return  bitstatus;
N}
N
N/**
N  * @brief  Clears the ADCx's pending flags.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_FLAG: specifies the flag to clear.
N  *   This parameter can be any combination of the following values:
N  *     @arg ADC_FLAG_AWD: Analog watchdog flag
N  *     @arg ADC_FLAG_EOC: End of conversion flag
N  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
N  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
N  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
N  *     @arg ADC_FLAG_OVR: overrun flag
N  * @retval None
N  */
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
X  ((void)0);
N
N  /* Clear the selected ADC flags */
N  ADCx->SR = ~(uint32_t)ADC_FLAG;
N}
N
N/**
N  * @brief  Checks whether the specified ADC interrupt has occurred or not.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_IT: specifies the ADC interrupt source to check.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_IT_EOC: End of conversion interrupt
N  *     @arg ADC_IT_AWD: Analog watchdog interrupt
N  *     @arg ADC_IT_JEOC: End of injected conversion interrupt
N  *     @arg ADC_IT_OVR: Overrun interrupt
N  * @retval The new state of ADC_IT (SET or RESET).
N  */
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
N{
N  ITStatus bitstatus = RESET;
N  uint32_t itmask = 0, enablestatus = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_IT(ADC_IT));
X  ((void)0);
N
N  /* Get the ADC IT index */
N  itmask = (uint32_t)((uint32_t)ADC_IT >> 8);
N
N  /* Get the ADC_IT enable bit status */
N  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)); 
N
N  /* Check the status of the specified ADC interrupt */
N  if (((uint32_t)(ADCx->SR & (uint32_t)itmask) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
N  {                                                         
N    /* ADC_IT is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* ADC_IT is reset */
N    bitstatus = RESET;
N  }
N  /* Return the ADC_IT status */
N  return  bitstatus;
N}
N
N/**
N  * @brief  Clears the ADCx's interrupt pending bits.
N  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
N  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
N  *   This parameter can be one of the following values:
N  *     @arg ADC_IT_EOC: End of conversion interrupt
N  *     @arg ADC_IT_AWD: Analog watchdog interrupt
N  *     @arg ADC_IT_JEOC: End of injected conversion interrupt
N  *     @arg ADC_IT_OVR: Overrun interrupt
N  * @retval None
N  */
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
N{
N  uint8_t itmask = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_IT(ADC_IT)); 
X  ((void)0); 
N
N  /* Get the ADC IT index */
N  itmask = (uint8_t)(ADC_IT >> 8);
N
N  /* Clear the selected ADC interrupt pending bits */
N  ADCx->SR = ~(uint32_t)itmask;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
